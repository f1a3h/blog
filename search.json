[{"categories":["ACG"],"content":"从 17 年底到 24 年初，从初二到大二，从懵懂无知的中二少年到现在的成熟稳重（？）、即将迈入大人的世界，六年半载，回想起来，塞尔达竟几乎承载了我几乎整个中学时代。\n想当年，全校第二，拿到 5000 元奖学金，终于趁爹妈高兴的时候要到了一台当年新出的 Switch，还记得这台 Switch 是托亲戚从英国带回来的，花了🐭🐭2800+大洋，肉痛的一批。当然了，Switch 到手之后第一款游戏当然要买当时正大火的「塞尔达传说：旷野之息」啦！于是，那名初二少年开启了在海拉鲁大陆上的旅程。\n一开始 Switch 没有中文，塞尔达就更不用说了，我试过拍屏翻译，然而体验实在太差于是开始自主探险。好景不长，我怎么也没办法离开那片小小的初始台地，就这样瞎探索了 20h+，我回去监狱上学了。\n再之后 Switch 和塞尔达终于支持中文了，我兴高采烈地换了个号重新开始在海拉鲁大陆的生活，但是还是好景不长，因为初三的时候由于很多机缘巧合要去长沙读书了，能当摸鱼勇者的时间就更宝贵了。\n时光荏苒，很快便来到了我记忆最深刻的那段时光——高一寒假，也就是著名的新冠爆发的那个时候（谁又能想到 3 年后我居然来了武汉读书呢）。那个时候正是我的低谷时期，期末考的稀烂，竞赛又出了强基计划，像我这种机房打了半年多摆终于觉醒要开始认真刷题的家伙来说这无疑是晴天霹雳，很显然，我退组了，也因为期末考的太烂把当时的 QQ 标签删完了留下一个“我太菜了”。看到这里大概都会觉得我会开始「未来可期，感谢经历，沉淀」罢，不过连我自己都没想到回家之后第一件事是玩「塞尔达传说」。毫无疑问，结局就是被我妈狠狠批斗了一顿然后就滚去自己房间用电脑摸鱼了（感谢在组里练就的摸鱼神功）。\n高中三年，很失败，直到最后了都没能成功证明自己，但还是很怀念在学校摸鱼的日子。自那次被批斗之后，我再也没碰过塞尔达传说了，一直到大学了才重新拾起来。\n2024.2.11，时隔六年半，我才终于通关了塞尔达传说的第一部。当年讲求探索，迷你任务、呀哈哈、神庙，追求完满，甚至花了不少时间攒钱买房，哪怕直到现在我也只进过那间小木屋里一次，堪称海拉鲁王国的败家骑士，纯纯一个摸鱼勇者，公主无数次提醒血月来临也没能让我从摸鱼中醒过来。但是从去年暑假开始，我林克一改过去“步步为营”的探险风格，目标明确，拯救最后的火蜥蜴神兽，拔出大师之剑，直奔王国城堡，善用 SL 大法，各种投机取巧打摆了灾厄盖侬，借助公主的力量完成了最后一场战役。没错，从一开始只会摸鱼的狗骑士到最后拯救王国的真正的勇士，我花了六年半的时间才完成这样的蜕变，那么，坐在电脑屏幕面前一字一句敲下这段文字的你又会在什么时候拔出属于你的大师之剑呢？\n","description":"一场孤独的冒险","tags":["Game","ARPG"],"title":"「塞尔达传说：旷野之息」: 一场孤独的冒险","uri":"/posts/zelda-breath-of-the-world/"},{"categories":["ACG"],"content":" 即便说出再多的言语，堆砌的话语，也无法打动你的心。\n可即便如此，我也想要传达。\n所以，请听我的言语吧，这微不足道的爱恋\n纵使心中有千言万语，却不知从何说起…… 既然如此，那只能从 default 选项 —— 时间顺序开始谈起了。\n故事的开头是从洸太郎的回忆开始的，孩提时真挚的感情、心急如焚地等待后迟迟没能收到的回复，配合背景里的钢琴曲，给人的感觉就是一股名为感伤的溪流缓缓流过。\n直到后来樱花树下的再会，一份不可名状的感情迸发出来，很难不让人感受到洸太郎心中交错重叠的情感，进而也对画面里这个呆呆的女孩产生一种憧憬。\n之后则是平淡的校园生活。不得不提到的是在这段故事的叙述，不对，准确来说是整个故事的叙述中，都是交替夹杂着洸太郎甜蜜、苦涩的回忆，她究竟怎么看待的那一封信？到底为什么什么也不说就默默地离开了？音乐的梦想最后又怎么样了？名为姬野星奏的少女身上隐藏着太多的谜团了，其实我只想单推星奏，但是不把其余的线推完没法进入最终章，如果不最后才推星奏的话又怕丢失了最初的感动，因此回学校准备期末考试前我只不甘地推完了彩音线，尽管在紧张旗鼓地复习预习中也仍然会时不时思考着星奏身上的谜团。这就是你大物考的一坨的原因吗\n考完试回来之后我快进解决了剩余的 2 条线，进入了星奏线。本以为星奏答应了之后就已经成功传达到了心中的话语，故事的最终会在甜甜的情侣生活之后以 Happy Ending 的方式结束，但是没想到 Glorious Days 的突然出现、星奏莫名的恐惧、少女偶像与星奏之间像是说教一般的对话打破了这一切。这之后，星奏再一次默默地离开了，哪怕是已经成为了情侣之后她所做的也仅仅只是比上次多留了一则内容简单到不能再简单的邮件。\n她有可能一直在等我，但也有可能离开了\n这一路上，有可能下雨，也有可能天晴\n我甚至可能无法到达\n但是，即便如此，\n我还是想尽一些全力，向你走去\n还会再见面吗？我如是想着。故事还远远没有结束，下一次认真的再会是在洸太郎成为了老师之后了。\n这一次的再会甚至都到了送戒指的环节，但是第二天星奏还是又一次抛弃了洸太郎奏了。看到这里实在很难继续对这个整整欺骗你三次感情的女人再抱有什么好的看法，哪怕内心中仍然在无力为她辩解着。\n不过，这种「坏女人」的看法还是在洸太郎痴情地成为记者开始追寻星奏的背影后被扭转了。与星奏昔日队友之间的对话让我明白了星奏确实是实实在在地爱着洸太郎的，但是大概是觉得伤害了几次洸太郎的自己没有资格继续呆在他身边，再加上队友、大人的 PUA，才会选择再次离开洸太郎的吧，甚至许诺永远不会再出现在洸太郎的面前，永远不会再利用洸太郎了。心痛是我知晓这一切后最大的想法，最后一幕中，在洸太郎的想象里星奏回来了，尽管是半开放式的结局，我仍然相信洸太郎的话语有好好传达到了星奏的心中，那个名为姬野星奏的女人一定还是再次回到了洸太郎的身边。\n看到网上大部分人都认为星奏是坏女人（其实我也是因为这个梗才玩的恋彼女），但是我并不认为这是一种背叛。至少星奏在感情上从来没有背叛过洸太郎，只是她无法传达出自己的爱恋，不能将心中的想法和感情传达给洸太郎才会导致这样一而再再而三的默默离开以至于被理解为「背叛」。诚然，大部分二次元作品中，女主在梦想与爱情中一定会毫无悬念的选择与男主在一起，但是星奏却一反常态多次都选择了追逐虚无缥缈的梦想，在队友与事务所的大人的 PUA 选择妥协，我觉得这也是无可厚非的，怀抱幼稚的想法大胆追梦的妄想战士们又有什么错呢？问题的根源还是在于「想要传达给你的爱恋」，推完了整个星奏线，这句话大概更适合用来形容星奏吧，小心翼翼地、笨拙地传达给你的爱恋，最后却仍然没能鼓起勇气以话语的方式传达。\n总而言之，从来没想过会为他人的爱情故事感动到落泪，玩的第一部 galgame ATRI 没能给我留下太多的感动，反而让我感到有点无聊，断断续续花了得有 1 年多才终于推完，而《想要传达给你的爱恋》则不同，最终章的故事实在是有点太过好哭，给我带来的后劲居然如此之大，这大概是我的第一部青春伤痛文学了罢。\n我们······我和你······\n没准还挺像的\n牺牲了一切追寻着你，最后等待我的或许只有寂寞\n全力追求着你的我，最后同样变得一无所有\n但是回头一想，那个季节是多么耀眼动人\n真是无可替代的至宝\n你没有给我回信，一言不发地离开我。到了现在，我感觉自己能理解你为什么这么做了\n你只是尽了自己的全力\n一心为着那些你应当付出全力的事物\n正因为这是就是你，所以你最后的最后写在信里的话语，肯定满含着无比的决心吧\n你发誓不会再来见我了\n如果这是你的决意，那我会郑重接受\n但是即便如此，我还是想再尽一些全力说出来\n我想见你\n我喜欢你\n再一次打开最终章，眼中不知何时噙满了泪水······\n","description":"此情可待成追忆 只是当时已惘然","tags":["Galgame"],"title":"「恋×シンアイ彼女」: 届不到的爱恋","uri":"/posts/koikakeru/"},{"categories":["Study Notes","Program Analysis"],"content":" Info\n南京大学「软件分析」课程 Soundness and Soundiness 部分的学习笔记。\nSoundness and Soundiness 前面提到 static program analysis 追求的 goal 是 soundness，但是无论是在学术界还是在工业界，由于一些语言的 hard language features 的存在，对现实世界的大型 program 想要实现完全的 soundness 是（目前）做不到的。\nHard-to-analyze features: an aggressively conservative treatment to these features will likely make the analysis too imprecise to scale, rendering the analysis useless.\n于是，为了避免 papers 中写 soundness 会误导读者，所以引入了 soundy 的概念：a soundy analysis typically means that the analysis is mostly sound, with well-identified unsound treatments to hard/specific language features.\nHard Language Feature: Java Reflection java reflection 会在 run-time 将 class、method、field 等转换为 metaobject，并且用一个 string 作为它们的 identifier，如图所示。\n在 run-time 对代码作出一些改变会产生一些 static analysis 无法预测的行为，这也是 static analysis 的硬伤。\nstring mName 无法分析，那么 m.invoke 具体调用了哪个方法也就无法得知，于是对某些可能的 method 的忽略优化很有可能会导致我们少检测到一些 bug 在进行 verification optimization 时，我们可能会忽略 reflection 产生的作用等同于 a.fld = a 的语句 f.set(a, a)，那么在分析 B b = (B) a.fld 就会得到 false negative 考虑到 reflection 产生的很多不确定行为都是由于 string 具体值的未知而导致的，因此我们可以用 string constant analysis + pointer analysis1 来完成对 reflection 的分析。\n但是实际上的很多 string 都是 statically unknown，所以这种方法仍然具有很大的局限性。\n除了直接对 string 进行分析，我们还在 usage points 对可能的 reflective targets 进行推断，概括来说就是 type inference + string analysis + pointer analysis，实践上，这种方法的准确度也很高。2\n不仅仅是根据 usage point 时的 parameters 对 method 进行推断，对其他的 metaobject 也是有效的3。\n另外，我们也可以根据 run-time 的特性利用 dynamic analysis 辅助 static analysis4。具体一点说就是利用一部分程序进行 dynamic analysis 分析得到的数据进行 static analysis，但是有限的程序量很难 cover 所有可能的 data。\nHard Language Feature: Native Code 在 java 中如果想要 print，就需要与 OS 进行交互，于是就不得不调用一些底层的 C/C++ 代码，这些代码被称为 native code。\n由于 java 是运行在 jvm 上的，所以 jvm 需要一个 function module 作为 interface 便于它 (jvm) 与 native code 调用的 native libraries 进行交互，也可以与 OS 进行交互、复用已有的 C/C++ 代码，这个 interface 就是 JNI。\n由于我们的 analyzer 针对的是 java 代码，而 native code 用的是 C/C++ 代码，所以我们无法进行分析。\n目前对于这个问题使用最广泛的方法是 manually models critical native code，比如调用 arraycopy 方法就将其改写为 java 语言的循环赋值语句然后再进行分析。\n最近的研究工作有使用 binary scanning 在 native code 中识别 java calls 的5。\n最后，想要了解更多 soundiness，可以访问 soundiness.org.\nBenjamin Livshits, John Whaley, Monica S. Lam. Stanford University, \"Reflection Analysis for Java\". APLAS, 2005. ↩︎\nYue Li, Tian Tan, Yulei Sui, Jingling Xue. UNSW Sydney, \"Self-Inferencing Reflection Resolution for Java\". ECOOP, 2014. ↩︎\nYue Li, Tian Tan, Jingling Xue, \"Understanding and Analyzing Java Reflection\". TOSEM, 2019. ↩︎\nEric Bodden, Andreas Sewe, Jan Sinschek, Hela Oueslati, Mira Mezini. Technische Universität Darmstadt, \"Taming reflection: Aiding static analysis in the presence of reflection and custom class loaders\". ICSE, 2011. ↩︎\nGeorge Fourtounis, Leonidas Triantafyllou, Yannis Smaragdakis, University of Athens, \"Identifying Java Calls in Native Code via Binary Scanning\". ISSTA, 2020. ↩︎\n","description":"Soundness and Soundiness","tags":["Program Analysis"],"title":"NJU「软件分析」学习笔记：Soundness and Soundiness","uri":"/posts/nju-spa-soudiness/"},{"categories":["Study Notes","Program Analysis"],"content":" Info\n南京大学「软件分析」课程 CFL-Reachability and IFDS 部分的学习笔记。\nFeasible and Realizable Paths infeasible paths 指的是在 CFG 并不会实际执行到的路径，例如 if 语句中某些不可能到达的分支。由于 infeasible paths 的判定与程序的 semantics 相关，所以总体上是 undecidable 的。\nrealizable paths 指的是 “returns” 与 “call” 相对应的路径，例子参考 slides。realizable paths 不一定是 executable 的 (feasible paths)，但是 unrealizable paths 一定不是 executable 的 (infeasible paths)。\nCFL-Reachability 使用 context sensitive 的技术可以去除 unrealizable paths，但是这里要介绍的技术是 CFL-Reachability。\nCFG-reachability: A path is considered to connect two nodes A and B, or B is reachable from A, only if the concatenation of the labels on the edges of the path is a word in a specified context-free language.（懒得翻译成中文了）\nCFG-reachability 其实采用的就是一种括号匹配的技术来判断 A 到 B 的路径是否合法，如果合法就说 A 到 B 有一条边，有点路径压缩的感觉🤔。\nA valid sentence in language L must follow L’s grammar.（即括号匹配的规则：左括号与右括号匹配） A context-free language is a language generated by a context-free grammar (CFG). 通过 CFL 解决 partially balanced-parenthesis problem：\n每个右括号 $)_i$ 需要相应的左括号 $(_i$ 来平衡，但是左括号不需要，如下图中 realizable 的第二种可能所示 对于 call edge 和 return edge，我们用打上标记的左右括号来标识 其他的普通 edge 用 $e$ 标识 realizable 的可能形式如下图所示，matched 表示的是 fully balanced-parenthesis，可能形式如下：\nOverview of IFDS IFDS1 (Interprocedural, Finite, Distributive, Subset Problem) 使用 distributive flow functions over finite domains 来解决 interprocedural dataflow analysis。\nMRP IFDS 提供了一种名为 meet-over all realizable paths (MRP) 的方法，与前面的 MOP 相似。\n但是 CFG 中某些 path 是 not executable 的，也会有 unbounded、not enumerable 的路径，所以显然 MOP 是 not fully precise、impractical 的。2\n由于 MRP 针对的是 realizable paths，一些没有出口的函数都显然不会是 realizable paths，这保证了 MRP 是可以终止的、more precise than MOP、practical 的，并且可以看出 MRP $\\subseteq$ MOP。\n$$ \\mathrm{MRP_n}=\\bigcup_{p\\in\\mathrm{RPaths}(start, n)}pf_p(\\bot) $$\nIFDS 给定一个 program P 和一个 dataflow analysis problem Q，IFDS 解决步骤如下：\n基于 Q 给 P 建立一个 supergraph G*，给每条边定义一个 flow function 将 flow function 转换为它表示的映射关系建立一个 exploded supergraph G# 此时 Q 已经被转化为 graph reachability problem，通过在 G# 上应用 tabulation algorithm 来解决 graph reachability problem: Let $n$ be a program point, data fact $d \\in \\mathrm{MRP_n}$ , iff there is a realizable path in G# from $\u003cs_{main}, 0\u003e$ to $\u003cn, d\u003e$ Supergraph and Flow Functions Supergraph supergraph 以 G* = (N*, E*) 的形式表示，它由多个 flowgraph G 组成，其中每个 Gp 都表示了一个 procedure，在每一个 Gp 中都有一个 start node $s_p$ 和 exit node $e_p$，对于 procedure call，它使用一个 call node $Call_p$ 和一个 return-site node $Ret_p$ 来表示 nodes，还使用了 call-to-return-site edge (denoted by purple)、call-to-start edge (green)、exit-to-return-site edge (blue) 表示 edges。\nDesign Flow Functions 以 Q = \"Possibly-uninitialized variables\": for each node n ∈ N*, determine the set of variables that may be uninitialized before execution reaches n. 为例。\nflow functions 以 lambda 表达式的形式表示：$\\lambda e_{param}.e_{body}$。\n在 IFDS 中，我们需要针对每条边都设计一个 flow function，需要注意的是，对于 global variable $g$，在 call-to-return edge 的 flow function 中我们需要设计为 $\\lambda S.S-\\{g\\}$：\n如果 $g$ 在另一个 procedure 中被 initialize 了，那么这么做显然没问题 如果 $g$ 没有被 initialize，那么 call-to-return edge 和 exit-to-return edge 的 facts 合并后会加上 $g$ 于是这样做可以减少 false positive 从而提高 precision。\nExploded Supergraph and Tabulation Algorithm Build Exploded Supergraph 在 exploded supergraph G# 中，G* 中的每个 node 都被拆分成 D+1 个 nodes，并且 edge $n_1\\to n_2$ 也会被拆分为这条边的 flow function 的 representation relation，类似于一种函数映射关系。\ndefault edge: $0\\to 0$ S 表示 statement D 表示的是 flow function 的 domain $\\lambda S.S$ 表示 identity function，即输出 = 输入 关于为什么要加一个 0 结点，个人理解是为了减少类似于 $\\lambda S.\\{a\\}$ 这样的恒等函数需要多连出来的很多边，于是搞一个 default 选项 0，将这 D 条边改成 $0\\to a$ 这一条边从而减小时空复杂度，这样一来就有可能出现图不连通的情况，为了保证图的连通性所以每次必须加一个 $0\\to 0$ 的边。\n一个可能的 exploded supergraph 如下图所示。\nTabulation Algorithm tabulation algorithm 可以在 exploded supergraph G# 上通过找出所有的从 $\u003cs_{main}, 0\u003e$ 开始的 realizable paths 来给出 MRP solution，时间复杂度 $\\mathcal{O}(ED^3)$。\ncore working mechanism:\n在 $\u003cCall_p, d_m\u003e$ 和 $\u003cRet_p, d_n\u003e$ 之间会有一条 summary edge (denoted by pink)，这条边用来表明 $d_n$ is reachable from $d_m$，当我们走 call-to-return edge 时就可以跳过 procedure $p$ 中的 redundant work 了 处理 exit node ($e_{p^1}$) 时会进行 call-to-return matching: 先找出 call $p^1$ 的 call sites，再根据 call sites 的信息找出它们分别对应的 return sites，这一步保证了 IFDS 是 context sensitive 的 在最开始，所有表示 data fact 的 circle 都是白色的，当一个 circle 变为蓝色的时候就表明 $\u003cn, d\u003e$ is reachable from $\u003cs_{main}, 0\u003e$（类似于染色法） Understanding the Distributivity of IFDS 考虑两个问题：\nIFDS 可以解决 constant propagation 吗？ constant propagation 的 domain 是 infinite 的，这与 IFDS 要求的 flow function 的 domain 应该是 finite 的矛盾，因此不行 IFDS 可以解决 pointer analysis 吗？ 也不行，我们可以通过 IFDS 的 distributivity 来解释 用 $f(x\\land y)=f(x)\\land f(y)$ 可以抽象的表达 distributivity 的含义，感性理解一下吧（\n观察 IFDS 的 flow function，可以发现它的输入与输出是 $1\\colon n$ 的关系，而 constant propagation 的 flow function 则是 $n\\colon 1$ 的关系，显然是不行的。\n现在我们考虑一个简单的 pointer analysis，尝试用 IFDS 来解决这个问题，如图所示。\n从图中的红边可以看出 IFDS 会漏掉 alias information，想要包含 alias information 就必然会要有 multiple inputs，这与 IFDS 的 flow functions 的设计是不符合的，所以 standard IFDS 是不能解决 pointer analysis 的。\n一个简单的 rule 来判断一个问题是否能用 IFDS：对于一个 statement $s$，如果我们需要考虑 multiple input data facts 来得到正确的 output data facts，那么这个问题就不能采用 IFDS。\n另外，IFDS 还有以下两个特点：\n无后效性：每个 data fact (circle) 和它的 propagation (edges) 都可以被独立解决，也就是说，上一个 circle 或者 edge 的分析结果不会对当前这个 circle 或 edge 的分析造成影响 另一种意义上的「单射」：representation relation 的 rule 保证了每个 output node 最多只会被一个 input node 指向 Thomas Reps, Susan Horwitz, and Mooly Sagiv, \"Precise Interprocedural Dataflow Analysis via Graph Reachability\". POPL'95 ↩︎\nNJU「软件分析」学习笔记：Data Flow Analysis ↩︎\n","description":"CFL-Reachability and IFDS","tags":["Program Analysis"],"title":"NJU「软件分析」学习笔记：CFL-Reachability and IFDS","uri":"/posts/nju-spa-ifds/"},{"categories":["Study Notes","Program Analysis"],"content":"新年第一天，从「恋×シンアイ彼女」开始！\n新年第一天，从 Program Analysis 开始！\nInfo\n南京大学「软件分析」课程 Datalog-Based Program Analysis 部分的学习笔记。\nMotivation imperative: how to do (~implementation) E.g. C. 需要告诉机器要如何去实现 declarative: what to do (~specification) E.g. SQL. 仅仅需要指明你想要什么，如何实现则交给程序（DBMS）自行选择 在 program analysis 中，我们指明对于不同的 statement 对应不同的 rule，这就是一种 specification，而在 algorithm 中，我们则指明了每一步具体要怎么做，在实际的代码实现里更是要考虑更多的 implementation details。可以看出，前面所学的 program analysis 即是 declarative 也是 imperative 的。\n在 tai-e assignments 中，我们使用 imperative 的方式实现 program analysis，同样的，我们也可以通过 declarative 的方式来实现。(via Datalog)\nIntroduction to Datalog datalog 最早是以 database language 的身份出现的1，现在有了更广泛的应用。\nDatalog = Data + Logic (and, or, not) no side-effects no control flows no functions not turing-complete Predicates (Data) 在 datalog 中，一个 predicate (relation) 就是值一系列的 statemetns，本质上其实是 a table of data。而 fact 则是指这个 table 中某个 tuple。\natoms 是 datalog 的 basic elements。\nP(X1, X2, ..., Xn) 的形式表示一个 relation atom，其中 P 是 predicate 的名字，Xi 则是 arguments， 它的值可以是一个 variable 也可以是 constant。一个 relation atom 的值为 true 当且仅当 P 中存在 (X1, X2, ..., Xn) 这个 tuple。\n除了 relation atoms，datalog 还有 arithmetic atoms。\nDatalog Rules (Logic) rule 用来表示 logic inferences，并且表明 facts 是如何被 deduced 的，它的形式为 H \u003c- B1, B2, ,,,, Bn ，其中 head 和 body 中的每一项都是 atom，Bi 也被称为 subgoal。\n一个 datalog program 由 facts 和 rules 组成。更多的语法直接看 slides 吧，懒得写了（\ndatalog 的 predicates 被分为 EDB 和 IDB 两种：\nEDB (extensional database) 提前定义好的 predicates relations are immutable 可以看作 input relations IDB (intensional database) 由 rules 推导出的 predicates 可以看作是 output relations datalog 支持 recursive rules，从而可以从自身进行 deduce。\n考虑以下两条 rules：\nA(x) \u003c- B(y), x \u003e y. A(x) \u003c- B(y), !C(x, y). 可以发现它们都有可能使得 A 称为一个 infinite relation，但是这并不是我们使用 datalog 想要得到的结果，所以我们要避免 infinite relation，也就因此引入了 rule safety 的概念。\n注意到 EDB 的元素是有限个的，因此对于一个 non-negated realtion atom，它能 deduce 的元素也会是有限的，所以我们只需要保证 head 中的每一个 variable 至少被一个 non-negated atom relation 给限制住了即可。在 datalog 中，只有满足 safe rules 是被允许的。\n再考虑这条 rule：\nA(x) \u003c- B(x), !A(x) 显然这是一条自相矛盾的 rule，但是它满足了 safe rule 的条件，因此我们需要另外添加限制。观察可以发现这种 contradictory rule 必然也是 recursive 的形式，并且是在 body 中对 head 进行 negate，因此，在 datalog 中，我们规定 recursion and negation of an atom must be separated。\nExecution of Datalog Programs datalog 使用 datalog engine 根据 EDB 和 rules 进行 deduce 并输出 IDB monotonicity: facts 只会从 rules 中产生而不会因为 deduction 而减少 termination: 通过 rule safety 保证了能被 deduce 的 facts 必然是 finite 的，因此 datalog program 必然是可以终止的 Pointer Analysis via Datalog 其实只要用 datalog 的语言描述出前面 pointer analysis 的 rules 即可，同样也需要考虑一些细节以及每个 atom 的 arguments 要如何设计。\nTaint Analysis via Datalog 使用 datalog 来实现 program analysis 有以下优点和缺点：\npros 简洁、可读性高 容易实现，写 bug 的概率也小很多 off-the-shelf optimized datalog engines 可以让你少考虑一些优化上的细节，make your life easier cons 表达能力有限，某些 logics 很难用 datalog 表示甚至根本表示不了 datalog engine 作为一个 black box 的存在使得我们很难用更优秀、更有针对性的 algorithm 来实现更优越的性能 David Maier, K. Tuncay Tekle, Michael Kifer, and David S. Warren, \"Datalog: Concepts, History, and Outlook\". Chapter, 2018. ↩︎\n","description":"Datalog-Based Program Analysis","tags":["Program Analysis"],"title":"NJU「软件分析」学习笔记：Datalog-Based Program Analysis","uri":"/posts/nju-spa-datalog/"},{"categories":["Study Notes","Program Analysis"],"content":" Info\n南京大学「软件分析」课程 Static Analysis for Security 部分的学习笔记。\nsecurity 指的是在存在 adversaries 的情况下能够成功达到一些 goals。\ncomputer security 中非常重要的一个 topic 就是 information flow。\nInformation Flow Security information flow security 的目的就是阻止通过阻止 unwanted information flow 来保护 information security。\n保护 sensitive data 的方式主要有 access control 和 information flow security 两种。\naccess control: a standard way 检查程序是否有权利 access 某些 information how information is accessed 不关心程序是如何使用这些 information 的 information flow security: end-to-end 跟踪 information flow how information is propagated \"A practical system needs both access and flow control to satisfy all security requirements\"\n— D.Denning, 1976\ninformation flow1 指的是如果有 information 从 variable $x$ 流入 variable $y$，就说存在信息流 $x\\to y$。\n而 information flow security 则通过将 variables 分为不同的 security levels、指定这些 levels 之间哪些 information flow 是允许的来达到 safe 的目的。\nSecurity Levels (Classes) 不同 levels 的 classification 可以被划分成一个 topo 图的结构，更准确的说，可以被 modeled as lattice2.\nInformation Flow Policy information flow security 用来限制在不同的 security levels 之间的 information flow。\n一个经典的 policy 是 noninterference policy3，它要求通过 low variables 不能推断出任何 high information，具体来说就是禁止从 high variable 到 low variable 的 inforrmation flow，换句话说就是保证 information 只会在 lattice 上向上走。但是它允许了 low variable 到 high variable 的 information flow，这使得它仍然不能到达它的目的。\nConfidentiality and Integrity confidentiality 指的是阻止 secret information 泄漏，也就是上面的 noninterference policy 做到的。\n而 integrity 指的是阻止 untrusted information 破坏 critical information4，有关的最广泛的 vulnerabilities 的造成原因就是 injection errors5 (SQL injection etc.)。\nintegrity 的广泛的定义是指以下三点：\ncorrectness: E.g. critical data 不应该被 untrusted data 破坏 completeness (broader than consistency): E.g. 一个 DBS 应该完整保存整个 data consistency: E.g. 一个文件传输系统一个保证 sender 和 receiver 之间传输的文件内容是一致的 Explicit Flows and Covert Channels 通过直接 copy 进行的 information flow 称为 explicit flow。相应地，由 secret information 影响的 control flow 造成的 information flow 称为 implicit flow，implicit flow 同样可以产生 information leak。\n上面这个程序存在一个从 secret 到 publik 的一个 implicit flow 并且会造成 leakage，但是并没有从 secret 到 publik 的 data flow，可以看出 information flow 和 data flow 的区别所在。\n通过一个 computing system 来 signal information 的 mechanisms 被称为 channels。而目的不是 information transfer 的 channels 被称为 covert channels6。\n常见的几种 covert channels 包括 implicit flows、termination channels、timing channels、exceptions。\n由于 explicit flows 通常会比 covert channels 传递更多的 critical information，所以主要考虑 explicit flows。\nTaint Analysis taint analysis 是最常用的 information flow analysis。它将 data 分为两类：\ntainted data: 与 critical information 有关的 data，在 taint analysis 中将其打上一个 label untainted data tainted data 的 sources 就被称为 sources，实践中它们往往是某些 methods (E.g. getPassword()) 的返回值。\ntaint analysis 的原理就是跟踪 tainted data，并观察它们是否有可能 flow 到某些 sensitive methods（可能造成 unsafe 的 methods，被称为 sinks）。\ntaint analysis 既能应用于 confidentiality 也能应用于 integrity 的检测：\nconfidentiality source: source of secret data sink: leakage validation: information leaks integrity source: source of untrusted data sink: critical computation validation: injection errors 将 tainted data 看作 objects，sources 看作 allocation sites，可以看出来 taint analysis 要做的事就是 pointer analysis 的工作，因此我们可以沿用 pointer analysis 的方法来完成 taint analysis7。\n在 domain and notations 中，我们只需额外增加一栏 tainted data，其余的保持不变：\n对于 inputs \u0026 outputs，taint analysis 需要我们输入 sources 和 sinks，然后会输出一系列由 source 和 sink calls 组成的 tuples 的 taintflows。\n为了标记 tainted data 并输出 taintflows，taint analysis 对于 call 的 rules 也有所不同：\nDorothy E. Denning and Peter J. Denning, \"Certification of Programs for Secure Information Flow\". CACM 1977. ↩︎\nDorothy E. Denning, \"A Lattice Model of Secure Information Flow\". CACM 1976. ↩︎\nJ. A. Goguen and J. Meseguer, \"Security policies and security models\". S\u0026P 1982. ↩︎\nKen Biba, \"Integrity Considerations for Secure Computer Systems\". Technical Report, ESD-TR-76-372, USAF Electronic Systems Division, Bed-ford, MA, 1977. ↩︎\nNational Vulnerability Database, https://nvd.nist.gov/ ↩︎\nButler W. Lampson, \"A Note on the Confinement Problem\". CACM 1973. ↩︎\nNeville Grech and Yannis Smaragdakis, \"P Taint: Unified Points-to and Taint Analysis\". OOPSLA 2017. ↩︎\n","description":"Static Analysis for Security","tags":["Program Analysis"],"title":"NJU「软件分析」学习笔记：Static Analysis for Security","uri":"/posts/nju-spa-security/"},{"categories":["Study Notes","Program Analysis"],"content":" Info\n南京大学「软件分析」课程 Pointer Analysis 部分的学习笔记。\nIntroduction Motivation CHA 只关注 class hierarchy 存在很大的局限性，在形如 Number n = new One() 的声明后调用 n 的某个 method 会得到多个 call target，实际其中只有一个 target 是真的，同时运用 constant propagation 会得到 NAC 的结果，是 inefficient 且 imprecise 的。\n而 pointer analysis 是基于 point-to relation 的，不会出现上述情况。\nIntroduction to Pointer Analysis pointer analysis 是一个 fundamental 的 analysis，对于 OOPL，它需要解决的问题是一个指针可能指向哪些 object，同样也是为了 safety，使用的是一种 may-analysis (over-approximation)。\nalias analysis 解决的问题是两个指针是否指向的是同一个 object，可以从 pointer analysis 中推导得出。\n\"Pointer analysis is one of the most fundamental static program analyses, on which virtually all others are built.\"1\nKey Factors of Pointer Analysis pointer analysis 是一个较为复杂的系统性的分析，不同的 factors 会影响整个系统的 efficiency 和 precision。\nfactors 主要有四种：heap abstraction、context sensitivity、flow sensitivity、analysis scope。\nHeap Abstraction heap abstraction 解决的是 how to model heap memory 的问题。\n在 dynamic execution 中，堆栈大小可能是 unbounded 的（例如 non-tail-recursion），我们的目标就是将 dynamically allocated、unbounded concrete objects 依照它们的一些共性抽象为 finite abstract objects。\n2\n解决方式主要分为两大流派：store baesd 和 storeless，其中 store based model 下的 allocation sites 方法使用最为广泛。\nallocation-site 依照 allocation site 来进行 abstract，可以理解为进行 allocate 的代码所在位置，如下图所示，其中 $o_2$ 表示第二行的 allocate 的 object：\nWhy Allocation-Site 每一次 allocation 必然对应一个 allocation site，而 allocation sites 必然是有限的，因此可以依据这个共性来进行 abstract。 Context Sensitivity context sensitivity 解决的是 how to model calling contexts 的问题。\nContext-sensitive Context-insensitive Distinguish different calling contexts of a method Merge all calling contexts of a method Analyze each method multiple times, once for each context Analyze each method once context-sensitive 是非常有用的技术，而 context-insensitive 则是提高了 efficiency 但是丢掉了 precision 的技术。\nFlow Sensitivity flow sensitivity 解决的是 how to model control flow 的问题。\nFlow-sensitive Flow-insensitive Respect the execution order of the statements Ignore the control-flow order, treat the program as a set of unordered statements Maintain a map of points-to relations at each program location Maintain one map of points-to relations for the whole program 由于 flow-insensitive 忽略了 statements 的 order，所以下图中对 s 的求解有两个值（橙色），其中一个为 false positive。 对于 C 语言，flow-sensitive 是十分有效的技术，但是对于 Java，目前没有证据表明 flow-sensitive 明显优于 flow-insensitive，并且 flow-sensitive 的开销较大，所以对于 Java 通常选择后者。\nAnalysis Scope analysis scope 解决的是 what parts of program should be analyzed 的问题。\nWhole-program Demand-driven Compute points-to information for all pointers in the program Only compute points-to information for the pointers that may affect specific sites of interest (on demand) Provide information for all possible clients Provide information for specific clients 在 demand-driven 中对特定 clients 的求解可能需要 traverse 整个 program 的很大一部分，并且一部分 clients 的求解依赖于非 demanded clients 的求解，所以实际上 demand-driven 的 efficiency 并不见得优秀多少。\nPointer Analysis in This Course Concerned Statements 在 pointer analysis 中，我们只关注 pointer-affecting statements。\n在 Java 中，pointers 可以分为以下几类：\nlocal variable: x\nstatic field: C.f $\\leftarrow$ sometimes referred as global variable\ninstance field: x.f $\\leftarrow$ modeled as an object with a field\narray element: array[i] $\\leftarrow$ ignore indexes. modeled as an object with a single field (may point to any value in array)\n由于在实际的代码中，array 的下标往往是以变量的形式在循环中进行访问的，这在 static analysis 中是无法进行分析的，所以我们需要忽略下标抽象为一个 object with a single field 进行 may-analysis。 pointer-affecting statement 可以分为以下几类：\nnew: x = new T() assign: x = y store: x.f = y load: y = x.f call: r = x.k(a, ...) $\\leftarrow$ Complex memory-accesses will be converted to three-address code focus on virtual call Foundations Rules How to Implement Pointer Analysis pointer analysis 的本质是在 pointers 之间 propagate point-to information，所以它的关键在于当 $pt(x)$ 改变时，要如何将 changed part propagate 到相关的 pointers。\nAndersen style analysis: Pointer analysis as solving a system of inclusion constraints for pointers.3\n类似于前面 control-flow 的解决方法，我们同样构建一张有向图，point-to information 可以通过有向边进行流动从而更新结点信息。\nnodes: Pointer = $V\\cup (O\\times F)$ edges: Ponter $\\times$ Pointer (may flow to) 注意前面提到的这里的 pointer analysis 是 flow-insensitive 的。 对于 c.f = a 这种涉及 $o_i.f$ 的语句， $o_i.f$ 才是真正的 \"variable\"，因此在图上使用 $o_i.f$ 表示一个 node。\n构建好 PGF 之后，pointer analysis 可以通过计算 PGF 上的 transitive closure 得到。\n由于前面提到的 $o_i.f$ 在图上的表示问题（variable 和 $o_i.f$ 之间连边或者 $o.f$ 之间连边），我们可以看出来 build PFG 和 propagate point-to information on PFG 两者是互相依赖的，也就是说，PGF 是在 pointer analysis 的过程中 dynamically updated。\nAlogorithms 目前的这个 context-insensitive 的算法还是比较 trivial 的，仍然是一个 SPFA（那个已经死掉了的算法）的思路，不过这里将 4 个 rules 分别进行处理，analysis 和 build PGF 的过程是相互依赖的，analysis 的初始化对应 x = new T() rule，而 build PGF 的初始化对应 x = y rule，处理完之后利用 worklist 对 x.f = y 和 y = x.f 一边 analysis 一边 build。\n需要注意的是这里的 differencial propagation $\\Delta=pts-pt(n)$ ，这是一种在 program analysis 中常见且非常有效的方法，可以降低时间复杂度和空间复杂度。\nPointer Analysis with Method Calls 显然，inter-procedural pointer analysis 需要建立 call graph。在 call graph 的建立上，CHA 根据 declared type of $a$ 来解决 call targets，而 pointer analysis 根据 $pt(a)$ 来判断。由前面对 CHA 的分析可以知道，CHA 会引入 spurious call graph edges 和 point-to relations。\nPFG 中对于 call statement 的 rule 如下图所示。\n由于在 $pt(x)$ 中不同的 $o_i$ 对应的 method 可能不同，所以 PFG 中不会添加 $x\\to m_{this}$ 这条边。\n与 PFG 的 build 一样，call graph 和 pointer analysis 也是互相依赖、同时进行的（也被称为 on-the-fly call graph construction）。在 pointer analysis 中，call graph 形成的是一个「reachable world」，除了 entry methods 以外所有的 reachable methods 都是在 pointer analysis 的过程中逐渐发现的，并且我们只会分析 reachable methods。\npointer analysis with method calls 的算法与前面的算法大体相同，除了图中的黄色部分是新加入的。\nContext Sensitivity Introduction 在动态执行的过程中，一个 method 可能在不同的 context 中被 call，使用 context insensitive (C.I.) 的分析方法会使得不同上下文中的不同的 object 流入一个 method 造成 spurious data flow，于是我们需要引入 context sensitive (C.S.) 的分析方法来提升精度。\nC.S. 区分上下文有很多种方法，下面以 call site 方法为例。在 C.S. 中，最直接的引入上下文的分析方式是 clone-based context sensitive analysis：将 variables 和 methods 通过 contexts 进行 qualify，在每一个 context 下都维护 variables 和 methods 的 clone。\nOOPs 通常是 heap-intensive 的，对于每一个 object 也用 context (heap-context) 进行 qualify，通常使用被 allocate 时的 context 作为标识。\nRules 在 context sensitive 的分析的表示方法中，每个 domain 都加入了一维 context。\n值得注意的是，在对 call 的处理中加入了一个 Select(c, l, c': o_i) 函数，基于 call site $l$ 时的信息来选择对应的 context\nAlgorithms context sensitive pointer analysis 其实就相当于在 C.I. 的基础上加入一维信息作为 context，同时在处理 method call 时需要使用一个 select 函数选取这个 method 的 context。\n以上这张图是一个 example，如果我们将第二行的 y = id(n2) 改成 x = id(n2) 那么使用 C.S. 方法分析得到的 i 可能的 pointers 中仍然会有 spurious target，这种问题对应的则是 flow sensitivity。\nC.S. 的算法如下：\n可以看出 C.S. 的处理方法和 C.I. 的处理方法几乎一致，而 AddEdge 和 Propagate 更是一样。\nContext Sensitivity Variants context sensitivity variants 可以有很多种，这里仅仅介绍了 call-site、object、type 这三种。\nCall-Site Sensitivity4 在 call-site sensitivity 中，context 被看作是一系列 call sites 组成的 stack (call chain)，每次进入一个 method call 就将这个 call site 加入 stack 中然后传入这个 method（相当于 select 得到的结果就是原来的 call chain 加上当前的 call site）。\ncall-site sensitivity 也被称为 call-string sensitivity 或者 $k$-CFA。\n当遇到非 tail-recursion 的递归函数时，call-site sensitivity 可能会得到一串很长的 call chain，甚至可能会出现 unbounded 的 call chain 从而导致 PA 无法 terminate。但是，真正起作用的 call sites 终究是 bounded 的，因此我们通过限制 call chain 的最大长度（$k$）来避免出现这种情况。\n在实际中，$k$ 往往是一个很小的数（$\\le 3$），并且 method context 和 heap context 的 $k$ 可能不同，例如 $k_{\\mathrm{method}}=2, k_{\\mathrm{heap}}=1$。\nC.I. vs. C.S.(1-Call-Site) Object Sensitivity5 在 object sensitivity 中，将一系列的使用 allocation site 表示的 objects 作为 context，每次遇到一个 method call 就将 receiver object 加到它的 heap context 后面作为这个 method 的 context。\n与 call-site sensitivity 不同的是，object sensitivity 针对的是流入每个 object 的 data，可以说 object sensitivity 是针对 OOPLs 设计的方法，由于使用 allocation site 来识别一个 object，所以它本质上是一种 allocation-site sensitivity。\nC.S. (1-Object) vs. C.S. (1-Call-Site) 不同情况下他们的 precision 也会不同，因此这两种方法不能直接进行比较，但是在大量的数据之下进行对比，object sensitivity 对于 Java 这样的 OOPLs 是要优于 call-site sensitivity 的，考虑到 Java 的特性，并且 object sensitivity 针对的是 OOPLs，所以这也是很 intuitive 的嘛。（也许可以认为是 object sensitivity 一定程度上丢失了 generalization 但是换来了在 OOPLs 上更好的性能🤔）\nType Sensitivity6 type sensitivity 将 context 看作是一系列包含了 allocation-site of the receiver object 的 type 的集合，很显然它的精度一定是严格小于等于 object sensitivity 的，相当于一种将在同一个 class 下 allocate 的 objects 合并了的一种 object sensitivity，但是尽管丢失了精度，它换来了更好的速度。\nCall-Site vs. Object vs. Type Sensitivity 7\n三者对比之下，可以看出 type sensitivity 仍然是由于 call-site sensitivity 的。\nPrecision: object \u003e type \u003e call-site Efficiency: type \u003e object \u003e call-site Pointer Analysis - Report from Dagstuhl Seminar 13162. 2013. ↩︎\nVini Kanvar, Uday P. Khedker, \"Heap Abstractions for Static Analysis\". ACM CSUR 2016. ↩︎\nLars Ole Andersen, 1994. \"Program Analysis and Specialization for the C Programming Language\". Ph.D. Thesis. University of Copenhagen. ↩︎\nOlin Shivers, 1991. \"Control-Flow Analysis of Higher-Order Languages\". Ph.D. Dissertation. Carnegie Mellon University. ↩︎\nAna Milanova, Atanas Rountev, and Barbara G. Ryder. \"Parameterized Object Sensitivity for Points-to and Side-Effect Analyses for Java\". ISSTA 2002. ↩︎\nYannis Smaragdakis, Martin Bravenboer, and Ondrej Lhoták. \"Pick Your Contexts Well: Understanding Object-Sensitivity\". POPL 2011. ↩︎\nYue Li, Tian Tan, Anders Møller, and Yannis Smaragdakis. \"A Principled Approach to Selective Context Sensitivity for Pointer Analysis\". TOPLAS 2020. ↩︎\n","description":"Pointer Analysis","tags":["Program Analysis"],"title":"NJU「软件分析」学习笔记：Pointer Analysis","uri":"/posts/nju-spa-pa/"},{"categories":["Study Notes","Program Analysis"],"content":" Info\n南京大学「软件分析」课程 Interprocedural Analysis 部分的学习笔记。\nMotivation 为了处理 method calls，我们可以做最 conservative assumptions 来直接不管这个 method 的具体形态，但是这样会产生很大的 imprecision，于是，针对 method calls 这种特殊形态，我们需要一个 Interprocedural Analysis。\nCall Graph Construction (CHA) call graph: a representation of calling relationships in the program.\n对于 OOPLs，call graph construction 主要有以下几种方法：\nMethod Call 在 Java 中，有 3 中 method calls，如下图所示\n其中 virtual call 是最大的难点也是 call graph construction 的重点。\n在 run-time，virtual call 基于以下两点决定调用哪个方法：\ntype of the receiver object $\\to c$ method signature(identifier of a method) at the call site: \u003cC: T foo(P, Q, R)\u003e $\\to m$ signature = class type(C) + method name(foo) + descriptor(T, P, Q, R) descriptor: return type + parameter types 我们使用 $Dispatch(c, m)$ 函数来描述 run-time 时 virtual call 的 dispatch 过程，实际就是递归向 parent 寻找对应的 method call 的过程。\nClass Hierarchy Analysis class hierarchy analysis (CHA) 是一种用来解决 method call 的方法，它需要整个程序的 class hierarchy information，并基于 declared type of receiver variable ($a$) of call site 和 $a$ 可能指向任意子类或父类的假设来解决 virtual call。\nCHA 只考虑 declared type of receiver variable at the call-site 和它的 inheritance hierarchy，完全忽略 data- he control-flow 的信息，因此它具有 fast 的优势也有 imprecision 的劣势，它的一个运用场景就是 IDEA。\nCall Graph Construction Interprocedural Control-Flow Graph CFG 展示的只是一个 individual method 的 structure，而 ICFG 则是在 CFG 的基础上加入了 call edges, return edges 来展示整个程序的 structure。\n可以看到图中黄色部分的边连接了 call edge 和 return edge 的起点与终点，它的作用是让当前 CFG 中的 data-flow 信息可以直接流向下一个 BB 而不是从 call edge 然后经过一大段冗余的路径才到达下一个 BB。\nInterprocedural Data-Flow Analysis interprocedural data-flow analysis 就是基于 ICFG 对整个程序进行分析。相比于 intraprocedural 的 CFG，ICFG 加入了 call 和 return edges，相应的 transfer function 也要从 node transfer 加上 edge transfer。\ncall edge transfer: transfer data flow from call site to the entry node of callee return edge: transfer: transfer data flow from the exit node of the callee to the return site 对于 intraprocedural 的 constant propagation，interprocedural 的 node transfer function 只在 call nodes 上有所不同：相比于直接将 LHS variable 设置为 NAC，我们先将这个 variable kill 掉，然后将其 flow 到 edge transfer，最后经由 return edge transfer 进行合并。\nin summary:\nnode transfer call nodes: identity other nodes: same as intraprocedural edge transfer normal edges: identity call-to-return edges: kill the LHS variable, then propagate others call edges: pass argument values return edges: pass return values 以下是一个 interprocedural data-flow analysis 的 example:\n再与 intraprocedural data-flow analysis 进行，对比，很显然 interprocedural 的结果是更 precise 的。\n","description":"Interprocedural Analysis","tags":["Program Analysis"],"title":"NJU「软件分析」学习笔记：Interprocedural Analysis","uri":"/posts/nju-spa-ia/"},{"categories":["CS"],"content":" Info\n南京大学「软件分析」课程作业踩坑记录。\n本来想一步步 git commit 传到 github 上的，后来发现不能直接上传解题代码，遂删库跑路（在写完 A1 之前 qwq）。\n写到 A2 的时候就已经踩了不少坑，感觉还是有必要记录一下，万一真有幸运读者看到这个辣鸡的博客之后就成功 AC 了呢（\nA1: 活跃变量分析和迭代求解器 活跃变量分析 SetFact newBoundaryFact(CFG) 和 SetFact newInitialFact() 返回一个空的 SetFact 即可 boolean transferNode(Stmt,SetFact,SetFact) 注意拷贝要用 out.copy() 方法而不是直接赋值 要将一个 interface 实例当成某个 implementation class 的实例使用需要先用 instanceof 判断然后用 (Var) 强制转换 迭代求解器 Solver.initializeBackward(CFG,DataflowResult) 为了实现 meetInto 方法，需要将 IN 和 OUT 都赋上初值 A2: 常量传播和 Worklist 求解器 常量传播 CPFact newBoundaryFact(CFG) 为了 safety 的考虑，这里要初始化为 NAC 我们要将所有出现在 CFG 中的 variables 全部初始化，所以需要用到 cfg.getIR().getParams() 初始化的时候需要注意，对于 variable $v$，先检查是否属于 Integer 再进行初始化 Value meetValue(Value,Value) 就是课上讲到的 lattice 上的 $\\cap$ 操作，分类讨论一下即可 boolean transferNode(Stmt,CPFact,CPFact) 只需要考虑 DefinitionStmt 可以使用 CPFact 的 copyFrom() 方法更新的同时返回是否改变 同样要考虑 variable 是否满足 canHoldInt Value evaluate(Exp,CPFact) 根据这个判断 exp 分类讨论进行处理 对应 Var 类型应该调用 in.get(v) 来得到 variable $v$ 的值 对应 ArithmeticExp 类型中的 DIV 或者 REM 时注意判断除数/模数如果是 0 要返回 NAC 对于 exp 的 operand lhs 和 rhs，两个中有一个为 NAC 时也要考虑如果 rhs 是 Constant 并且为 0 的情况 最后如果 exp 不属于上图中的任一类型，应该返回 NAC 而不是 Undef，作业网站上有提到但是我没注意到（ Worklist 求解器 Solver.initializeForward(CFG,DataflowResult) 和 A1 一样记得 IN 和 OUT 都要赋值 WorkListSolver.doSolveForward(CFG,DataflowResult) worklist 本质只是一个元素不重复的普通的容器，你可以使用任意满足上述要求数据结构存储，但是用一个 HashSet 更省心（ A3: 死代码检测 死代码检测器 Preparation: 把前两次作业的代码蒯进来，记得合并一下 backward 和 forward 的部分 Set\u003cStmt\u003e analyze(IR) 主要注意一下 switch 语句可能会 fall through 的情况，本来以为这里需要用到 dfs，但是看了一眼 CFG 图，貌似 hit 到的 case 后面会有边连接到会 fall through 的 case，所以直接把 hit 的 case 加进来之后不管就行了 其他基本就是一个大模拟了，建议先做一遍猪国杀练练手（bushi ","description":"踩坑记录","tags":["Program Analysis"],"title":"Tai-e Assignments 踩坑记录","uri":"/posts/tai-e-assignments/"},{"categories":["Algorithm"],"content":"由于 4 年半前（惊了，居然已经过了这么久了吗 QAQ）学过一次，所以这严格上来说应该是 Re: 从零开始的 mancher 重拾笔记（话说我怎么和初学的状态一样啊）\nIntroduction 我们还是套路式的从 intro 开始吧（\n如果想要单独求出某一个回文串，显然弄两个指针 $\\mathcal{O}(n)$ 比较一遍就好了，但是如果要求出所有的字符串呢？最容易想到的一个优化就是，只要求出了以下标 $i$ 为中心的最长回文串，那么我们其实也就求出了以下标 $i$ 为中心的所有回文串。在考虑了这个优化下的暴力算法复杂度是 $\\mathcal{O}(n^2)$ 的，但是这还是不够优秀。\n如果使用字符串哈希呢？仍然采用上面的 trick，要求最长的长度我们就再套一个二分，这样可以在 $\\mathcal{O}(n\\log n)$ 的时间内求出来。\n但是啊，这玩意有一个很简单的算法可以在 $\\mathcal{O}(n)$ 的时间内求出来，那就是 manacher 算法（点题！）。道理和 KMP 是类似的，充分利用回文串的性质，需要有强大的注意力。\nManacher 过程很简单，由于偶数长度的回文串的求解可以通过在原字符串中添加奇奇怪怪的字符转化为对奇数长度的回文串的求解，因此下面只考虑对奇数长度的回文串的求解。\n首先，我们维护一个右端点具有最大下标的回文串的中心下标 $id$ 和右端点下标 $r$，记 $d[i]$ 表示以下标 $i$ 为中心的最长奇数长度回文串的半径大小。\n枚举中心 $i$，假如当前枚举的下标 $i\u003cr$，那么由回文串的性质，将 $i$ 以 $id$ 为中心对称过去得到对应的下标 $j=id*2-i$，则几乎可以认为 $d[i]=d[j]$，在下图中这是很显然的（图片来自 oi-wiki）：\n不过考虑到 $j$ 的最长回文串的左端点可能落在 $id$ 的最长回文串之外，因此我们需要砍掉多出去的部分，然后再暴力向外扩展 $d[i]$。\n另一种情况是，如果当前枚举的下标 $i\\ge r$，那么就直接暴力枚举。\n最后都要记得用 $i$ 的结果更新 $id$ 和 $r$。\nComplexity 在以上过程中，只要 $i$ 的最长回文串是完整落在 $id$ 的最长回文串内部的，那么对于 $i$ 的求解是 $\\mathcal{O}(1)$ 的，而一旦 $i$ 的最长回文串落在了 $id$ 的最长回文串外，我们只会枚举落在外面的部分，并且枚举完成后会立即更新 $id$ 和 $r$，也就是说每个下标最多只会被枚举两次，一次是成为左端点，另一次是成为右端点，所以 manacher 算法是 $\\mathcal{O}(n)$ 的。\nSome Naive Thoughts 总觉得这种字符串中 KMP 和 manacher 解决的问题和对数组进行排序的问题有点像（强行联想），但是为什么字符串中这两个算法都能做到 $\\mathcal{O}(n)$ 而排序的上限平均就是 $\\mathcal{O}(n\\log n)$ 的呢？\n想起之前在知乎上刷到过为什么排序算法的上限是 $\\mathcal{O}(n\\log n)$ 的问题，底下关于信息论的回答令我大呼妙哉，居然还有这种角度？！自此之后，信息论成为了我心中的一本圣经，总觉得这玩意简直就是这世界的真理，它可以回答任何问题，可以求出任何优化的极限，用信息论看问题简直和开了神之眼俯视世界一样。\n我们再回到这个例子，用（我以为的）信息论来考虑，那一定是 $d[]$ 和 $next[]$ 数组相比于排序问题仅仅提供了大小关系，他们提供了更丰富的信息来降低不确定性，信息量更大，因此优化的理论极限复杂度会更低。话说这不是扯了一堆最后结论是句废话嘛\n但是嘛，一直没找到时间好好学学信息论，所以这仅仅是一些「naive thoughts」QwQ\n有空的时候一定会认真学信息论的（确信\nProblems 板子就不特意放上来了，仅仅处理奇数长度回文串的板子和使用 trick 求出奇偶长度回文串的板子都在这两题里有体现。\n「Luogu P4555」[国家集训队]最长双回文串 Luogu\n递推求出下标 $i$ 分别作为回文串（不一定是 manacher 中的最长回文串）的左右端点时的最长的回文串长度，然后枚举割点取 max 即可。\n当然也可以二分答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u003cbits/stdc++.h\u003e using std::cin;\tusing std::cout; using std::string;\tusing std::vector; const int N = 1e5 + 5; int n; char s[N], t[N \u003c\u003c 1]; vector \u003cint\u003e l(N \u003c\u003c 1), r(N \u003c\u003c 1), R(N \u003c\u003c 1); int modify() { int len = 0; t[++len] = '$', t[++len] = '#'; for (int i = 0; i \u003c strlen(s); ++i) t[++len] = s[i], t[++len] = '#'; t[++len] = '\\0'; return len; } void manacher() { int mx = 0, mid = 0; for (int i = 1; i \u003c= n; ++i) { R[i] = (i \u003c mx) ? std::min(R[(mid \u003c\u003c 1) - i], mx - i + 1) : 1; while (i - R[i] \u003e 0 \u0026\u0026 i + R[i] \u003c= n \u0026\u0026 t[i + R[i]] == t[i - R[i]]) R[i]++; if (R[i] + i - 1 \u003e mx) mx = R[i] + i - 1, mid = i; l[i - R[i] + 1] = std::max(l[i - R[i] + 1], R[i] - 1); r[i + R[i] - 1] = std::max(r[i + R[i] - 1], R[i] - 1); } } int main() { std::ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); cin \u003e\u003e s; n = modify(); manacher(); for (int i = 2; i \u003c= n; i += 2) l[i] = std::max(l[i], l[i - 2] - 2); for (int i = n - 2; i \u003e 0; i -= 2) r[i] = std::max(r[i], r[i + 2] - 2); int ans = 0; for (int i = 2; i \u003c= n; i += 2) if (l[i] \u0026\u0026 r[i]) ans = std::max(ans, l[i] + r[i]); cout \u003c\u003c ans; return 0; } 「Luogu P1659」[国家集训队]拉拉队排练 Luogu\n只需要求出奇数长度的最长回文串，按照长度 sort 一遍枚举即可，注意这里需要用到快速幂。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u003cbits/stdc++.h\u003e using std::cin;\tusing std::cout; using std::string;\tusing std::vector; using i64 = long long; const int mod = 19930726; const int N = 1e6 + 5; int n; i64 k, ans; string s; vector \u003cint\u003e r, d; void manacher() { r = vector \u003cint\u003e (n); for (int i = 0, id = 0, rr = -1; i \u003c n; ++i) { r[i] = (i \u003c rr) ? std::min(r[(id \u003c\u003c 1) - i], rr - i + 1) : 1; while (i - r[i] \u003e= 0 \u0026\u0026 i + r[i] \u003c n \u0026\u0026 s[i - r[i]] == s[i + r[i]]) ++r[i]; if (i + r[i] - 1 \u003e rr) id = i, rr = i + r[i] - 1; } } i64 qpow(i64 a, int b) { i64 ret = 1; while (b) { if (b \u0026 1) ret = ret * a % mod; a = a * a % mod; b \u003e\u003e= 1; } return ret; } void count() { int cnt = 0; i64 tot = 0; ans = 1; for (int len = r[0], p = 0; len \u003e 0 \u0026\u0026 tot \u003c k; len -= 2) { while (p \u003e= 0 \u0026\u0026 r[p] == len) cnt++, p++; if (cnt \u003e k - tot) cnt = k - tot; ans = ans * qpow(1ll * len, cnt) % mod; tot += cnt; } } int main() { std::ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); cin \u003e\u003e n \u003e\u003e k; cin \u003e\u003e s; manacher(); std::sort(r.begin(), r.end(), [](int a, int b) { return a \u003e b; }); for (int i = 0; i \u003c n; ++i) r[i] = (r[i] \u003c\u003c 1) - 1; count(); cout \u003c\u003c ans; return 0; } ","description":"线性求所有长度的回文串：manacher","tags":["Palindrome","String"],"title":"manacher 算法学习笔记","uri":"/posts/manacher-study-notes/"},{"categories":["Study Notes","Program Analysis"],"content":" Info\n南京大学「软件分析」课程 Data Flow Analysis 部分的学习笔记。\nData Flow Analysis - Applications Overview of Data Flow Analysis data flow analysis 的核心就是 how data flows on CFG?，将这句话拆开了讲就是：\nhow application-specific data：对数据的 abstraction，例如 +、-、0 等 flows through the：根据分析的类型作出 approximation may-analysis: outputs information that may be true. 是一种 over-approximation，也是大多数静态分析采用的类型 must-analysis: output information that must be true. 是一种 under-approximation nodes and: 数据如何 transfer，用 transfer function 表示，例如 + op - = - 等 edges of: 数据流如何处理，例如两个控制流汇入一个结点 CFG Preliminaries of Data Flow Analysis Each execution of an IR statement transforms an input state to a new output state.\nEvery input/output state is associated with a program point, corresponds to an edge of CFG.\n对于每一个 program point，我们用一个 data-flow value 表示对于当前所有可能的 program states 的 abstraction。\ntransfer function's contraints: 分为 forward analysis 和 backward analysis 两种，用 $f_s$ 表示经过 definition $s$ 的 transfer function\ncontrol flow's contraints:\nwithin a BB: IN[$s_{i+1}$] = OUT[$s_i$] among BBs: OUT[B] = $f_B($IN[B]$)$，其中 $f_B$ 是 $f_{s_i}$ 的复合函数 Reaching Definitions Analysis 为了减少复杂性，这里的 RDA 不包括 method calls 和 aliases。\n一个 definition $d$ 可以 reach program point $q$ 当且仅当存在一条路径 $p$ 到 $q$ 使得 $d$ 不会在这条路径上被 kill 掉。\n对于变量 $v$ 的 definition 就是指对 $v$ 的赋值语句，如果原来的 definition $d_1$ 对 $v$，经过的某个 BB 中有另一个 $d_2$ 也对 $v$ 进行了赋值，那么就说 $d_1$ 被 kill 掉了。\n在 reaching definition analysis 中，data flow value 被设置为长度与 definitions 的数量相等的 bit vector，每个 bit 对应一个 definition，0/1 表示到达这个 program point 时对应的 definition 是否被 kill 了。\n由于每个 definition 都被定义为独一无二的，所以每经过一个 BB 就会“产生新的 definition”，因此 transfer function 被定义为 $\\mathrm{OUT[B]}=gen_B\\cup(\\mathrm{IN[B]}-kill_B)$。\nRDA 的 algorithm 如下图所示：\n由于 $gen_B$ 和 $kill_B$ 是始终不变的，因此只要 $\\mathrm{IN[B]}$ 不变那么 $\\mathrm{OUT[B]}$ 也一定不会变。每次经过一轮迭代，上一轮 $\\mathrm{IN[B]}$ 中为 1 的 bit 仍然会是 1，从而 $\\mathrm{IN[B]}$ \"never shrinks\"，因此 $\\mathrm{OUT[B]}$ 也会是 \"never shrinks\" 的，而 bit 的数目是有限的，所以 $\\mathrm{OUT[B]}$ 迟早会 reach a fixed point，从而这个算法一定可以终止。\nLive Variables Analysis 如果存在一条以 program point $p$ 为起点的路径，使得 variable $v$ 在这条路径上能够被使用（$use(v)$），同时没有在被使用前 redefined，就称 $v$ is live at $p$，否则就称 $v$ is dead at $p$.\nLVA 对于 data flow values 的设置是与 RDA 类似的，只是将 definition 换成了 variable。\n基于以上定义，LVA 的 algorithm 是一种 backward analysis，我们根据 $\\mathrm{OUT[B]}$ 来求出 $\\mathrm{IN[B]}$，对应的 transfer function 为 $\\mathrm{IN[B]}=use_B\\cup(\\mathrm{OUT[B]}-def_B)$。\nLVA 的 algorithm 如下图所示：\nAvailable Expressions Analysis 表达式 x op y($e$) 在 program point $p$ 是 available 的当且仅当以下两个条件成立：\n从 Entry 到 $p$ 的所有路径都需要经过 the evaluation of $e$ 在经过最后一次 evaluation of $e$ 之后没有再对 $x$ 或者 $y$ 进行 redefine AEA 的 flow data values 也是 bit vector 的形式。\n显然 AEA 中的 $gen_B$ 是指 B 中新的 expression，$kill_B$ 指的是 B 中对 $\\mathrm{IN[B]}$ 的 expressions 的 variables 的 redefine 语句。\nAEA 允许我们在有多条路径可以到达 $p$ 时，无需重复计算 expression $e$，而是直接用 last evaluation of $e$ 的值进而达到优化的目的。\n从 AEA 的定义中，不难看出这是一种 must-analysis，并且 $\\mathrm{IN[B]}$ 需要取的是前继的交集。\nAEA 的 algorithm 如下图所示：\n需要注意的是，$\\mathrm{OUT[B]}$ 的初始化与前面的 may-analysis 是不同的。\nReaching Definitions Live Variables Available Expressions Domain Set of definitions Set of variables Set of expressions Direction Forwards Backwards Forwards May/Must May May Must Boundary OUT[entry]=∅ IN[exit]=∅ OUT[entry]=∅ Initialization OUT[B]=∅ IN[B]=∅ OUT[B]=U Transfer function $\\mathrm{OUT[B]}=gen_B\\cup(\\mathrm{IN[B]}-kill_B)$ $\\mathrm{IN[B]}=use_B\\cup(\\mathrm{OUT[B]}-def_B)$ $\\mathrm{OUT[B]}=gen_B\\cup(\\mathrm{IN[B]}-kill_B)$ Meet $\\cup$ $\\cup$ $\\cap$ Data Flow Analysis - Foundations Iterative Algorithm, Another View 在前面 DFA 的迭代算法中，以 forward analysis 为例，假设一共有 k 个 node，每次迭代后所有的 $\\mathrm{OUT[B]}$ 可以抽象为一个 k-tuple，令 domain 为 $V$，迭代的过程可以看作一个函数 $F\\colon V^k\\to V^k$，而迭代的出口就是到达这个函数的不动点 $X=F(X)$。\n由以上的抽象，我们可以考虑几个问题：\n这个函数是否一定存在不动点？ 是否会存在多个不动点？如果是，我们的算法求出的不动点是否是最优解？ 什么时候才能到达不动点？ Data Flow Analysis Framework via Lattice 一个 data flow analysis framework $(D,L,F)$ 由以下几个部分组成：\n$D$: forward / backward analysis $L$: lattice, includes the domain and the meet/join operator $F$: a family of transfer functions from $V$ to $V$ 从 lattice 的角度来看，data flow analysis 的算法相当于迭代地在一个 lattice 上运用 transfer function 和 meet/join 操作。\nMonotonicity and Fixed Point Theorem 再回到前面提出的几个问题。\n由 $\\mathrm{OUT}$ 是 “never shrinks” 的性质，我们可以推出这个 transfer function 一定存在不动点。\n关于第二个问题，仅仅从函数的角度上考虑，一个函数的不动点实则是它与直线 $y=x$ 的交点，那么很显然，不动点是可能存在多个的。\n但是这里的函数是 lattice 上的函数，自然也会具有一些特性。\nmonotonicity: 如果函数 $f\\colon L\\to L(L\\ is\\ a\\ lattice)$ 满足任给 $x,y\\in L$，有 $x\\le y\\rArr f(x)\\le f(y)$ 就称它是 monotonic 的 fixed point theorem: 对于一个 complete lattice $(L,\\le)$，如果 $L$ 上的函数 $f$ 是 monotonic 的，并且 $L$ 是 finite 的，那么 最小的 fixed point 可以通过不断迭代 $f(\\bot),f(f(\\bot)),\\dots,f^k(\\bot)$ 直到 reach a fixed point 的方式找到 最大的 fixed point 可以通过不断迭代 $f(\\top),f(f(\\top)),\\dots,f^k(\\top)$ 直到 reach a fixed point 的方式找到 证明 fixed point theorem 可以分为以下两个部分进行证明：\nexistence of fixed point: 由于 $f$ 是 monotonic 的，因此我们对 $\\bot$ 进行每次迭代的值都是递增的，而这个 lattice 又是 finite 的，那么一定会达到一个最大值不动，这个最大值就是一个不动点，对 $\\top$ 做的迭代也是类似的。 least fixed point: 反证法。假设 $x$ 是最小的 fixed point，由 $\\bot$ 的定义，必然有 $\\bot \\le x$，然后对两边一直做迭代，左边会达到一个非最小的不动点 $p$，右边仍然是 $x$，由 monotonicity 的定义可知，$p\\le x$，这与 $x$ 是最小的 fixed point 的假设矛盾，因此 least fixed point 的算法是正确的，同理，greatest fixed point 的算法也是正确的。 我们之前设计的 DFA 的算法都是从 $\\bot$ 或者 $\\top$ 开始迭代，因此求出的不动点一定是 least/greatest fixed point，在某些定义上可以认为我们的算法求出来的是最优解。\n以上关于函数性质的论证都是基于 lattice 的，要证明我们的 DFA 迭代算法也有同样的性质，还需要（尽可能）将我们的算法与 fixed point theorem 建立关联。\nRelate Iterative Algorithm to Fixed Point Theorem 根据 fixed point theorem 的条件，我们首先 relate iterative algorithm 中的 fact 和 lattice。\n假设有 $k$ 个 node，那么经过 $i$ 轮迭代后得到的 fact 的形式为 $(v_1^i,v_2^i,\\dots,v_k^i)$，对于 node $j$，每轮迭代产生的 $v_j^i$ 组成的集合与集合的 $\\subset$ 关系可以看作一个 finite 且 complete 的 lattice $L$，从而整个 fact 就是这些 lattice 的笛卡尔积 $L^k$，从而 fact 也是一个 finite 且 complete 的 lattice。\n之后只需 relate transfer + meet/join function 与 monotonic 的函数 $f\\colon L\\to L(L\\ is\\ a\\ lattice)$。\n从前面证明 $\\mathrm{OUT}$ 是 never shrinks 的过程中，我们已经可以知道 transfer function 是满足 monotonic 的条件的了。而对于 meet/join function，我们根据 monotonic 的定义可以很简单的证明。\n因此，我们可以 relate the algorithm to the fixed point theorem。也就可以很自信的认为对前两个问题的回答是正确的了。\n现在我们回答第三个问题。我们定义 lattice 的高度是从 $\\top$ 到 $\\bot$ 的最长路径的长度，假设单个结点的 lattice 的高度是 $h$，CFG 的结点数为 $j$，每次迭代至少可以让一个结点往上爬一个高度，所以最坏的情况下的迭代次数是 $h\\cdot k$。\nMay and Must Analysis, a Lattice View MOP and Distributivity Meet Over All Paths Solution (MOP) 是考虑所有可能到达结点 $s_i$ 的路径，将这些路径的 OUT 取 meet/join 来得到 $s_i$ 的 IN 或者说 MOP[$s_i$]，也就是根据所有路径的计算结果取 lub/glb。\n但是 CFG 中某些 path 是 not executable 的，也会有 unbounded、not enumerable 的路径，所以显然 MOP 是 not fully precise、impractical 的。\n对比 iterative algorithm，可以发现我们算法的形式是 $F(x\\cup y)$ 的，而 MOP 的形式是 $F(x)\\cup F(y)$ 的，由 $F$ 是 monotonic 的和 lattice 的性质可以推出 $F(x)\\cup F(y)\\le F(x\\cup y)$ ，所以 iterative algorithm 的精度是不如 MOP 的。\n但是，当 $F$ 是 distributive 时，iterative algorithm 的精度是和 MOP 一样的。再分析 iterative algorithm 的 $F$，可以发现 bit-vector 或 gen/kill problems 都是 distributive 的，所以前面介绍的几种算法精度都是与 MOP 相当的。\nConstant Propagation 决策在 program point $p$ 的一个 variable $x$ 是否是一个常量的问题就是 constant propagation。\ndirection: forward analysis lattice: OUT: a set of pairs $(x,v)$ domain of $v$: UNDEF / values(-2, -1, 0…) / NAC $\\cap$: NAC $\\cap$ $v$ = NAC UNDEF $\\cap$ $v$ = $v$ transfer function: $F\\colon \\mathrm{OUT}[s]=gen\\cup (\\mathrm{IN}[s]-{(x,_)})$ s: x = c or x = y or x = y op z 从下图中的简单例子可以看出 constant propagation 的 $F$ 是 non-distributive 的：\nWorklist Algorithm worklist algorithm 实现了对 iterative algorithm 的优化：如果经过一个 BB，它的 IN 没有变化，那么之后这个 BB 的 OUT 一定不会变化。因此，我们只需维护一个 worklist of BBs，如果当前的 BB 的 OUT 发生了变化，我们才将它所有的后继加入 worklist。\n","description":"Data Flow Analysis","tags":["Program Analysis"],"title":"NJU「软件分析」学习笔记：Data Flow Analysis","uri":"/posts/nju-spa-dfa/"},{"categories":["Math"],"content":" Note\n去年刚学不定积分的时候敲的表，之前懒得搬，最近上概率论需要用到感觉还是有必要再把这篇旧文给搬上来的 QwQ\n设 $k, \\mu, a(a\u003e0, a\\not ={1})$ 是常数.\n$\\int k \\ \\mathrm{d}x=kx+C$ $\\int\\dfrac{1}{x}\\mathrm{d}x=\\ln{|x|}+C$ $\\int x^{\\mu}\\ \\mathrm{d}x=\\dfrac{x^{\\mu+1}}{\\mu+1}+C$, 特例 $\\int\\dfrac{1}{x^2}\\mathrm{d}x=-\\dfrac{1}{x}+C, \\int\\dfrac{1}{\\sqrt{x}}\\mathrm{d}x=2\\sqrt{x}+C$ $\\int a^x\\ \\mathrm{d}x=\\dfrac{a^x}{\\ln{a}}+C$, 特例 $\\int e^x\\ \\mathrm{d}x=e^x+C$ $\\int\\cos{x} \\ \\mathrm{d}x=\\sin{x}+C$ $\\int\\sin{x} \\ \\mathrm{d}x=-\\cos{x}+C$ $\\int\\dfrac{1}{\\cos^2{x}}\\mathrm{d}x=\\int\\sec^2{x}\\ \\mathrm{d}x=\\tan{x}+C$ $\\int\\dfrac{1}{\\sin^2{x}}\\mathrm{d}x=\\int\\csc^2{x}\\ \\mathrm{d}x=-\\cot{x}+C$ $\\int\\dfrac{1}{a^2+x^2}\\mathrm{d}x=\\dfrac{1}{a}\\arctan{\\dfrac{x}{a}}+C$, 特例 $\\int\\dfrac{1}{1+x^2}\\mathrm{d}x=\\arctan{x}+C$ $\\int\\dfrac{1}{a^2-x^2}\\mathrm{d}x=\\dfrac{1}{2a}\\ln{\\left|\\dfrac{a+x}{a-x}\\right|}+C$, 特例 $\\int\\dfrac{1}{1-x^2}\\mathrm{d}x=\\mathrm{arth}\\ x+C$ $\\int\\dfrac{1}{\\sqrt{a^2-x^2}}\\mathrm{d}x=\\arcsin{\\dfrac{x}{a}}+C$, 特例 $\\int\\dfrac{1}{\\sqrt{1-x^2}}\\mathrm{d}x=\\arcsin{x}+C$ $\\int\\dfrac{1}{\\sqrt{x^2\\pm a^2}}\\mathrm{d}x=\\ln{\\left|x+\\sqrt{x^2\\pm a^2}\\right|+C}$, 特例 $\\int\\dfrac{1}{\\sqrt{x^2+1}}\\mathrm{d}x=\\mathrm{arsh}\\ x+C$ $\\int\\ch{x}\\ \\mathrm{d}x=\\sh{x}+C$ $\\int\\sh{x}\\ \\mathrm{d}x=\\ch{x}+C$ $\\int\\sec{x}\\ \\mathrm{d}x=\\ln{\\left|\\sec{x}+\\tan{x}\\right|}+C$ $\\int\\csc{x}\\ \\mathrm{d}x=\\ln{\\left|\\csc{x}-\\cot{x}\\right|}+C$ 其中,\n$\\sh{x}(\\sinh{x})=\\dfrac{e^x-e^{-x}}{2}$ 为双曲正弦函数\n$\\ch{x}(\\cosh{x})=\\dfrac{e^x+e^{-x}}{2}$ 为双曲余弦函数\n$\\th{x}(\\tanh{x})=\\dfrac{\\sh{x}}{\\ch{x}}=\\dfrac{e^x-e^{-x}}{e^x+e^{-x}}$ 为双曲正切函数\n","description":"Infinite Integral Formula Table","tags":["Calculus"],"title":"不定积分公式表","uri":"/posts/infinite-integral-formula-table/"},{"categories":["Algorithm","Writeup"],"content":"不想复习计网就来写算法题解了（\n上一次写算法相关的博客是什么时候呢🤔\n之前立下的好好刷题的 flag 执行了没有一天就被回收了吗（悲）\n从今天开始一定认真执行😤\n题目 Sue 和 Sandy 最近迷上了一个电脑游戏，这个游戏的故事发在美丽神秘并且充满刺激的大海上，Sue 有一支轻便小巧的小船。然而，Sue 的目标并不是当一个海盗，而是要收集空中漂浮的彩蛋，Sue 有一个秘密武器，只要她将小船划到一个彩蛋的正下方，然后使用秘密武器便可以在瞬间收集到这个彩蛋。然而，彩蛋有一个魅力值，这个魅力值会随着彩蛋在空中降落的时间而降低，Sue 要想得到更多的分数，必须尽量在魅力值高的时候收集这个彩蛋，而如果一个彩蛋掉入海中，它的魅力值将会变成一个负数，但这并不影响 Sue 的兴趣，因为每一个彩蛋都是不同的，Sue 希望收集到所有的彩蛋。\n然而 Sandy 就没有 Sue 那么浪漫了，Sandy 希望得到尽可能多的分数，为了解决这个问题，他先将这个游戏抽象成了如下模型：\n将大海近似的看做 $x$ 轴，以 Sue 所在的初始位置作为坐标原点建立一个竖直的平面直角坐标系。\n一开始空中有 $N$ 个彩蛋，对于第 $i$ 个彩蛋，他的初始位置用整数坐标 $(x_{i}, y_{i})$ 表示，游戏开始后，它匀速沿 $y$ 轴负方向下落,速度为 $v_{i}$ 单位距离/单位时间。Sue 的初始位置为 $(x_{0}, 0)$，Sue 可以沿 $x$ 轴的正方向或负方向移动，Sue 的移动速度是 $1$ 单位距离/单位时间，使用秘密武器得到一个彩蛋是瞬间的，得分为当前彩蛋的 $y$ 坐标的千分之一。\n现在，Sue 和 Sandy 请你来帮忙，为了满足 Sue 和 Sandy 各自的目标，你决定在收集到所有彩蛋的基础上，得到的分数最高。\nLuogu\n分析 一开始一直在想普通的 dp 究竟要怎么设状态，可是无论怎么设都无法在避免前面的彩蛋对后面所有彩蛋造成的影响，如果要避免的话复杂度里总是会有个坐标轴值域大小，显然会 T，而且初始位置在彩蛋的中间更不好按照彩蛋的顺序转移了，于是只好看题解。\n第一篇题解引用了论文「对一类动态规划问题的研究」By 湖南省长沙市第一中学 徐源盛 ，主旨是如果当前的决策对未来的行动会造成影响，那么决策的时候就把影响计算出来就是了。\n不过在这之前，我们需要先注意到一点：从起点到当前位置的路径上的彩蛋是必然会拿的，这是很显然的，但是为什么我当时没有注意到啊 kora！，也就是说每次拿取到的彩蛋必然是一段区间，所以当然要用区间 DP 而不是普通的 DP 啦！\n然后我们将论文中的思想运用到这道题中，其实思想也很 intuitive，感觉主要困扰我的是没有想到用区间 DP（哭）。在这道题中，我们设 $f[i][j]$ 表示已经取得了区间 i 到 j 的彩蛋的得分，但是很快发现下一步拓展到 $i-1$ 和 $j+1$ 的计算结果会和当前的位置是在 $i$ 还是 $j$ 有关，这个简单，加一维分别表示最后是在左边还是右边就好了，于是有了 $f[0][i][j]$ 和 $f[1][i][j]$ 分别表示在 $i$ 和在 $j$。\n这样一来，状态转移方程就很简单了，如果是求 $f[0][i][j]$，分别考虑是从 $f[0][i+1][j]$ 还是 $f[1][i+1][j]$ 拓展来的就好了。\n假设彩蛋的收益是 $y$，位置为 $x$，我们已经取得了的彩蛋区间为 $[i,j]$，去取彩蛋 $i$ 所需要的时间为 $t$，那么对所有未取得的彩蛋的影响为 $cost=(\\sum_{k=1}^nv_k-\\sum_{k=i+1}^jv_k)t$，于是有状态转移方程：\n$$ f[0][i][j]=y_i+\\max(f[0][i+1][j]-cost*(x_{i+1}-x_i)),f[1][i+1][j]-cost*(x_j-x_i)) $$\n第一维取值为 1 的状态转移方程也是类似的。\n最后要吐槽的是我居然忘了区间 DP 枚举的第一维是区间长度而不是区间左边的值，如果按照区间 $[i,j]$ 这样来枚举 $i$ 和 $j$ 会导致两个都需要求的 $f$ 互相调用对方的值来求得自己的值，这样就假了，因为每次转移是从区间长度小 1 的状态转移来的，把区间长度作为第 1 维进行枚举的话就可以保证每次转移依赖的值都是已经求解过的真值。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u003cbits/stdc++.h\u003e using std::cin;\tusing std::cout; using std::max; using i64 = long long; const int N = 1005; struct egg { i64 x, y, v; } e[N]; int n; i64 m; i64 f[2][N][N], s[N]; int main() { std::ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; ++i) cin \u003e\u003e e[i].x; for (int i = 1; i \u003c= n; ++i) cin \u003e\u003e e[i].y; for (int i = 1; i \u003c= n; ++i) cin \u003e\u003e e[i].v; e[++n] = (egg){ m, 0, 0 }; std::sort(e + 1, e + 1 + n, [](egg T1, egg T2) { return T1.x \u003c T2.x; }); int pos = 0; for (int i = 1; i \u003c= n; ++i) { if (e[i].x == m) pos = i; s[i] = s[i - 1] + e[i].v; } memset(f, -0x3f3f3f3f, sizeof(f)); f[0][pos][pos] = f[1][pos][pos] = 0; auto cost = [](int i, int j) { return s[n] - (s[j] - s[i - 1]); }; for (int k = 1; k \u003c= n; ++k) { for (int i = 1, j; i + k \u003c= n; ++i) { j = i + k; f[0][i][j] = e[i].y + max(f[0][i + 1][j] - (e[i + 1].x - e[i].x) * cost(i + 1, j), f[1][i + 1][j] - (e[j].x - e[i].x) * cost(i + 1, j)); f[1][i][j] = e[j].y + max(f[0][i][j - 1] - (e[j].x - e[i].x) * cost(i, j - 1), f[1][i][j - 1] - (e[j].x - e[j - 1].x) * cost(i, j - 1)); } } printf(\"%.3lf\", 1.0 * max(f[0][1][n], f[1][1][n]) / 1000); return 0; } ","description":"","tags":["区间DP"],"title":"「Luogu P2466」[SDOI2008] Sue 的小球","uri":"/posts/luogu-p2466/"},{"categories":["Study Notes","CNATDA"],"content":"Introduction control plane 计算 forwarding 和 flow tables 有两种方式：\nper-router control: router 之间进行交流，分别计算自己的 forwarding table logically centralized control: 由一个 remote controller 收集信息，计算并分发结果 Routing Algorithms 在 routing algorithms 中，network 被抽象为一张图，综合考虑 physical length、link speed、monetary cost 等作为边权。\nrouting algorithm 可以分为以下几类：\ncentralized / decentralized: 计算过程中是否知道整张图的信息 static / dynamic: 是否对网络负载、拓扑结构等的变化作出响应 load-sensitive / load-insensitive: 是否考虑 congestion 的状况 The Link-State (LS) Routing Algorithm LS 是 centralized routing algorithm，需要每个结点将 attached links 的信息进行广播 (link-state broadcast) 让所有结点拥有整张图的信息，再用 Dijkstra 等算法计算最短路。\n对于 load-sensitive routing algorithm，traffic load 的改变可能会导致出现 oscillations，解决办法就是改成 load-insensitive 的或者保证不是所有结点都在同时运行 LS。\nThe Distance-Vector (DV) Routing Algorithm DV 是 distributed、 iterative、decentralized 的 routing algorithm。\n每个结点维护自己到其他每个结点的 distance vector，当自己的 distance vector 更新了就将自己的 distance vector 发送给 neighbor，并且也会由 neighbor 的 distance vector 更新自己的，当 link state 发生改变时，DV 会经过多轮迭代并进行传播最终收敛。\n当 link-cost 减小时，收敛较快。但是当 link-cost 增大时，由于不在这个 link 上的那个结点的消息滞后性，可能会导致 $y$ 用 $z$ 来更新 $D_y(x)$，然后 $z$ 用 $y$ 来更新 $D_z(x)$，两者互相更新最终需要边权值域大小次的迭代（称为 count to infinity problem），并在过程中产生 routing loop，如下图所示：\n使用 poisoned reverse 可以避免出现二元环：如果 $u$ 通过 $v$ 走了 $(u, w)$ 这条路径，则在 $u$ 通知 $v$ 的时候将 $D_u(w)$ 改成 $\\infty$。\n当出现大于 2 个结点的 loop 时，poisoned reverse 会失效。\nA Comparison of LS and DV Routing Algorithms message complexity: LS 需要每个结点获得全局的信息，而且需要结点将信息送到很远的地方；DV 仅仅需要结点知道 neighbor 的信息。 speed of convergence: LS 时间复杂度较低（Dijkstra 可以使用优先队列优化到 $\\mathcal{O}(n\\log n)$ ）； DV 则较慢，过程中可能出现 routing loop，还有 count-to-infonity problem。 robustness: 在 LS 中每个结点可以发送错误的 link state 给其他结点，但是由于每个结点只计算自己的 forwarding table，不依赖于其他结点的，所以影响较小；DV 中每个结点的计算结果都是其他结点的结果的一部分，影响较大。 实际上 Internet 同时采用了这两种算法。\nIntra-AS Routing in the Internet: OSPF 如果统一管理所有的 routers，会规模过大性能无法接受，也不能满足自治的需求。因此，routers 被划分成了很多个 autonomous system (AS)，每个 AS 有一个 ICANN 赋予的编号，每个 ISP 可能管理一个或多个 AS。\n每个 AS 内部都会使用一种 intra-AS routing protocol，例如 OSPF (Open Shortest Path First)。\nOSPF 使用 LS routing algorithm，边权由管理员设定，router 向整个 AS 内部 broadcast link state（当 link state 发送改变时/周期性地）。\nOSPF 有以下一些 advances:\nsecurity: routers 之间的信息可以利用 MD5 进行 authentication multiple same-cost paths: 当有多条路径的 cost 相同时可以同时使用这些路径 有 MOSPF 拓展来支持 unicast 和 multicast hierarchy within a single AS: 可以将 AS 划分成多个 area 来形成 AS 内部的 hierarchy，每个 area 内部走最段路，不同 area 之间通过走 area 的 border router 来走 backbone area Routing Among the ISPs: BGP BGP (Border Gateway Protocol) 是一个 decentralized、asynchronous 的 inter-AS routing protocol。\nThe Role of BGP 在 BGP 中，destination 的不是确定的 IP 地址，而是 CIDR prefix。\nBGP 使得一个 AS 可以向其他 AS advertise prefix，并计算出到达各个 prefix 的 route。\nAdvertise BGP Route Information 不同的 router 之间会建立称为 BGP connection 的 TCP connection，负责连接两个 AS 的 gateway router 之间会建立 external BGP (eBGP) connection，AS 内部的 router 两两之间会建立 internal BGP (iBGP)。\n假设要向所有 router advertise 前往 prefix $x$ 的路径：\n$x$ 所在的 AS 的 gateway router 会向周围 AS 的 gateway router 发送 eBGP message，类似于 AS3 x 其他 AS 的 gateway router 收到后会向 AS 内部广播 iBGP message: AS3 x 之后其他的 gateway router 会继续向相邻的 AS 的 gateway router 发送 eBGP message，并在 advertisement 中加入自己所在的 AS，类似于 AS2 AS3 x。 Determining the Best Routes 一条 BGP advertisement 包含 AS-PATH 和 NEXT-HOP 等信息（称为 BGP attributes，加上 prefix 就称为一个 route）：\nAS-PATH 表示到达目的地需要经过的 AS，一个 AS 收到来自其他 AS 的 route 后可以在其中加上自己，然后继续发送给 neighbor NEXT-HOP 表示离开当前 AS 去往目的地需要走到的下一个 AS 的第一个 router 的 IP 地址 从一个 AS 出发到达某个 prefix 有很多种路径，在实践中，BGP 采用的是 route- selection algorithm，router 按照顺序使用以下几条规则来选择 best route：\n由管理员设置或者从其他 AS 获得的 local preference（作为一个 attribute） shortest AS-PATH（经过最少的 AS），当这条 rule 成为唯一的 rule 时采用 DV 算法，边权设置为 AS hops 的数量。 hot patato routing: 在 AS 内走最短路（通过 intra-AS protocol 以及 NEXT-HOP 得到）到达 gateway router 根据 BGP identifier 选 IP-anycast BGP 可以为前往某个 prefix 寻找 best route，如果给多个 host 设置相同的 IP 地址，即可实现 IP-anycast，例如 CDN 为客户寻找最合适的 server，这一过程是在 router 的挑选中实现的。\nIP-anycast 如果用于 TCP 可能会导致同一个 TCP connection 中的 message 发送给不同的 host，所以 CDN 一般不采用 IP-anycast，而 DNS root server 则采用（使用 UDP）。\nRouting Policy local preference 的存在为管理员决定如何选择 route 以及实现某些 policy 提供了可能。\nThe SDN Control Plane Info\n因为时间很紧 + 考试不考，所以这部分写的比较简略，而且基本全靠抄 ouuan dalao 的笔记，要有更好的理解还是去看书或者看 ouuan dalao 的笔记。\nSDN 分为 SDN controller、network management applications（例如 routing、access control、load balancing） 和 controlled devices 三个部分。\nSDN 使用 generalized forwarding，通过 network-control application 提供 network control functions，实现了 programmable network。\nSDN 将 network functionality 进行了 unbundle，使得 packet switches、SDN controller、network management applications 可以来自不同供应商。\ncommunication layer (northbound API): controlled devices 和 SDN controller 进行通信。 network-wide state-management layer: SDN controller 维护的一些信息。 interface to the network-control application layer (southbound API): 让 network-control applications 能够读写 network state 和 flow tables 等信息，通过 RESTful API 等方式进行通信。 在 OpenFlow 中，SDN controller 可以向 controlled device 发送：\nconfiguration modify/read-state send packet controlled device 可以向 SDN controller 发送：\nflow-removed port-status packet-in ICMP: The Internet Control Message Protocol ICMP 被用来进行 router 和 host 之间的通信，作为 IP payload 进行传输。\nICMP 的 message 有很多种，例如：\nping 使用的 echo request 和 echo reply destination network/host/protocol/port unreachable destination network/host unknown router advertisement/discovery TTL expired IP header bad traceroute 使用 ICMP 通过发送 TTL 递增的 UDP segment with an unlikely port number 给 host，通过 TTL expired 得知每一个 router 的信息，通过 port unreachable 得到终点的信息。\nNetwork Management and SNMP, NETCONF/YANG network management 包括 managing server（包括 network managers）、managed device、data（每个 device 有 configuration data、operational data、device statistics，而 managing server 会维护每个 device 和整个 network 的 data）、network management agent、network management protocol。\n进行 network management 有以下几种方式：\nCLI: error-prone，不能 scale to larger-sized network。 SNMP/MIB: 每个 device 有 management information base (MIB) objects，可以使用 simple network management protocol (SNMP) 来获取/设置 MIB objects 的 data，device 可以发送 trap message 向 managing server 通知状态变化。由于 SNMP/MIB 针对的是单个的 device，也难以 scale。 NETCONF/YANG: NETCONF 比 SNMP 更注重配置管理，可以一次性操控多个 device，设置 constraint 来检查配置的正确性，使用 YANG 作为 data modeling language，以 XML 格式通过 TLS 进行通信。 ","description":"The Network Layer: Control Plane","tags":["Computer Network","CNATDA"],"title":"CNATDA 第五章学习笔记","uri":"/posts/cnatda-ch5/"},{"categories":["Study Notes","CNATDA"],"content":"Introduction and Transport-Layer Services transport layer 将 application layer messages 封装成 segments，然后交给 network layer 进行传输，将 network layer 提供的 logical communication between hosts 扩展为 logical communication between processes。\n最主要的两个 transport layer protocol 是 TCP 和 UDP，其中 UDP unreliable、connectionless 的，TCP reliable、connection-oriented 的。\nUDP 仅仅提供 data delivery 和 error checking 的服务，不保证 datagram 是否送达、是否有序，是否完整、正确，也不会控制传输速度。\nTCP 则提供 reliable data transfer、flow control、保证 datagram 正确、有序送达，还会提供 congestion control。\n而 network layer protocol 最重要的 IP protocol 提供的是一个 best-effort delivery (unreliable) 服务。\nMultiplexing and Demultiplexing 在 transport layer 中，multiplexing 指 sender 的 transport layer 将不同 socket 的 message 收集并发送给 network layer 的过程，而 demultiplexing 指 receiver 的 transport layer 将 network layer 发送来的 datagrams 拆分后传递给对应的 socket 的过程。\nmultiplexing 和 demultiplexing 需要每个 socket 有 unique identifier。\nUDP socket 的 identifier 为二元组 (dest IP addr, dest port num) ，它也会存有 source port number 等其他 field，但是不作为 identifier。\nTCP socket 的 identifier 为四元组 (src IP addr, src port num, dest IP addr, dest port num)。\nConnectionless Transport: UDP UDP 仅提供 multiplexing/demultiplexing 和 error checking。一些 application 选择 UDP 主要基于以下几点原因：\n更好地控制发送什么数据、什么时候发送：TCP 有 congestion control，可以会延迟发送数据，而且会错误重传导致发送较慢。 不需要建立连接：建立连接的过程会产生 delay。 无连接状态：可以减小系统资源消耗。 较小的 header：TCP segment header 长度通常为 20 bytes，而 UDP 只有 8 bytes。 但是，在使用 UDP 传输大量数据时，会导致 packet overflow at routers，UDP 丢包严重，TCP 传输过慢。\nUDP datagram header 共有 4 个 fields，每个长度都是 2 bytes。\nlength：记录 UDP segment 的总长度。 checksum：对所有 16-bit 的数据求和后使用 1s complement 检测是否全为 1。 source port destination port UDP 的 checksum 仅仅进行 error detecting，不会进行 error correcting，当检测到错误时可以选择丢弃/通知 application。\n尽管很多 link layer protocol 也提供了 error checking，但是不能保证路上所有的 link layer 都提供了，同时 error 也不一定是 link-to-link 的过程中产生的，因此 UDP 仍然需要提供 checksum 的服务。\nPrinciples of Reliable Data Transfer Stop-And-Wait 在 stop-and-wait 中，sender 每次需要收到 receiver 发送的对应的 ACK/NAK 才会发送下一个 packet。\nchecksum：传输过程可能出错，需要进行 error detection。 acknowledgment：receiver 需要告知 sender 是否丢包、出现错误。 retransmission：丢包（超时）或者收到 NAK 时需要重传。 timeout：出现丢包现象需要使用 timeout 来进行判断。timeout 的时间太长会影响性能，所以一般设置为有可能丢包但是不能完全确定是否是丢包的值。 sequence number：sender 发送的 packet 与 receiver 发送的 ACK 都有相应的 sequence number。在传输过程中，ACK 也有可能出错，从而导致 duplicate packet，因此加上 sequence number 来识别 duplicate packet。另外，在 stop-and-wait 中，sequence number 仅由 0/1 组成，因此又被称为 alternating-bit protocol。 Pipelined Reliable Data Transfer 由于是 stop-and-wait 的机制，所以性能不高。\n定义 sender 的 utilization 的大小为 sender 实际在传输的时间与总时间的比值，在 stop-and-wait protocol 中，大小约为 $U_{\\mathrm{sender}}=\\dfrac{L/R}{RTT+L/R}$ ，实际值非常小。\n解决这个问题的办法就是让 sender 无需等待即可一次传输多个 packets，这种方法也叫 pipelining，使用这种办法也意味着：\nsequence number 数量增大。 sender 和 receiver 都需要 buffer 更多的 packets。 有两种基础的实现方法：Go-Back-N 和 selective repeat。\nGo-Back-N (GBN) window 的大小收到 packet 中 sequence number 的 field 的限制，若 sequence number field 的长度为 $k$，则 window size 为 $2^k$，sequence number 范围为 $[0,2^k-1]$。\nsender:\n使用一个 sliding window 表示当前有效的 sequence number 的范围。 如果 window 内所有 sequence number 都被使用了就不能发送新的 packet。 收到的 ACK 被称为 cumulative acknowledgement，即 sequence number 小于当前 ACK 的 number 的未被 ACK 的 packets 也会被视为 ACK’d 。 收到一个 ACK 就会将 window 滑到它对应 sequence number 后面。 所有的未被 ACK 的 packets 共用一个 timer。 retransmit 时会重发所有未被 ACK 的 packets。 receiver: 只接收顺序正确的 packet，否则会直接丢弃，而如果是顺序正确但是出现错误的 packet 则会通过发送上一个 packet 的 ACK 进行 NAK。\nGBN 相对 selective repeat 的优势在于 receiver 不需要 buffer，但是相应的，一个 packet 出错就要重发所有未被 ACK 的 packets，造成了很多浪费。\nSelective Repeat (SR) sender:\nwindow 除了第一个一定是未被 ACK 的其余都有可能是 ACK 或者未被 ACK 的。 每个 packet 的 ACK，timer，retransmission 都是独立的。 收到开头的 ACK 时 window 滑动到第一个未被 ACK 处。 receiver：\n同样维护一个 sliding window，window size 可能与 sender 不同，第一个是尚未收到的最小的 packet。 收到非 window 开头的会 buffer 下来。 收到 window 开头的会将其与 buffer 中存储的连续的一整段传给 application layer，然后滑动 window。 收到比 window 开头小的 packet 时说明之前的 ACK 传输出了问题，仍然需要发送 ACK。 如果收到 packet 存在 error，则丢弃不管 需要注意的是 sender 和 receiver 的 window size 不一定相同，但是都不能超过 sequence number 大小范围的一半。\n不管是 GBN 还是 SR，sequence number 的范围都是有限的，所以是循环使用的，如果一个 duplicate packet/ACK 的传输耗时过久导致占用了现有的 sequence number，实践中的解决办法是认定一个 packet/ACK 在传输几分钟之后就没了。\nConnection-Oriented Transport: TCP The TCP Connection TCP 被称为 connection-oriented 是因为当两个 process 之间能够传输 data 之前需要先进行 handshake。\nTCP 需要先建立 connection，这个 connection 只是 logical 的，是在两个 end system 上建立一些 state variable，没有 physical 上的连接。\nTCP connection 是 full-duplex 的，即双方建立连接之后互相可以发送信息；是 point-to-point 的，不能进行 multicasting。\nTCP connection 通过 three-way handshake 建立，在 handshake 过程中也会建立 send/receive buffer，发送/收到 message 时会先放入 send/receive buffer 然后再传递给 application/link layer。\nTCP 会根据 MTU (maximum transmission unit，最大的能传输的 link layer frame size) 计算出合适的 MSS (maximum segment size，segment 包含 data 的最大 size) 使得 data 加上 TCP header 和 IP header 后不超过 MTU。\nTCP Segment Structure TCP 的 header 长度通常是 20 bytes，但是 Options 是可变长度的，所以也不一定。\nSequence Numbers and Acknowledgment Numbers TCP 将 data 视为一个无结构但有序的 byte stream。sequence number 指的是当前 segment 的 data 的第一个 byte 在 byte stream 中的序号；acknowledgment number 指的是期待对方下一个传送来的 segment 的 sequence number。\n由于 TCP 只会 acknowledge 它重新组成的 byte stream 中的第一个 missing byte，所以也被称为 cumulative acknowledgments。\n当 TCP 收到 out-of-order segments 时，可以选择丢弃或者将其 buffer 下来并等待 missing bytes，显然后者对于网络带宽的利用更高效，也是实践中采用的办法。\n为了尽可能减小收到的上一个已经关闭的 connection 中仍然留存在 network 中的 segment 的 sequence number 与现在合法的 sequence number 搞混，TCP 会随机选择一个初始的 sequence number。\nRound-Trip Time Estimation and Timeout 一个 segment 的 sample RTT ($s$) 指的是从发送到收到对应的 ACK 的用时。\nTCP 一般在计算某个 segment 的 sample RTT 后不会再计算同时也在传输的其他 segment 的 sample RTT，而且只会计算一个就传输成功的 segment，不会计算 retransmitted segment 的 sample RTT。\n由于 network 的拥堵情况会变化，所以另外还需要计算这些 sample RTT 的 EWMA (exponential weighted moving average) 作为 estimated RTT ($e$) 来平缓 RTT 的波动：$e=(1-\\alpha)\\cdot e+\\alpha\\cdot s$ 。\n使用 dev RTT ($d$) 来衡量 RTT 的波动：$d=(1-\\beta)\\cdot d+\\beta\\cdot |s-e|$ 。\n$\\alpha$ 和 $\\beta$ 的建议取值为 0.125 和 0.25 。\ntime interval ($t$) 在 estimated RTT 的基础上根据 dev RTT 提供了一定的冗余：$t=e+4\\cdot d$ 。\nReliable Data Transfer TCP 一般只使用一个 timer，是用来给最早的未被 ACK 的 packet 计时的，并且每次 timeout 只会 retransmit 这一个 packet。\ndoubling the timeout interval：每次发生 retransmission 时，TCP 会将下一个 time interval 翻倍，而不是由 estimated RTT 和 dev RTT 计算得到。但是一旦在收到 application 传来的 data 或者收到 ACK 后重启的 timer 的 time interval 的值仍然设置为 $t=e+4\\cdot d$ 。\nfast retransmit：doubling the timeout interval 虽然能减小因顺序错误导致收到 duplicate ACK 的次数，但是增加了 end-to-end delay。由于多于 2 个 duplicate ACKs 可以表明错误原因不是顺序问题（较大 number 的 packet 先到达）而是丢包，因此 TCP 在收到 3 个 duplicate ACKs（相同 sequence number 的第四个 ACK）时会在 time out 前立即重发。\nTCP 只维护最小的未被 ACK 的 sequence number (sender) 和顺序正确的 sequence number (receiver)，这点上看类似 GBN，但是 TCP 每次只会重传一个 packet，而 receiver 也会 buffer 顺序错误的 packets。\nFlow Control sender 和 receiver 都会另外维护一个 buffer 存储 packets，sender 收到 application 的 data 会 buffer 下来不一定立即发送，receiver 收到 packet 也会 buffer 下来等待 application 读取。\n为了防止 sender 发送过快导致 receiver 的 buffer overflow，TCP 提供了 flow control 的服务。\nTCP 的 header 需要包含 rwnd (receive window) 用来表示 buffer 的剩余空间，sender 则需要保证发出的未被 ACK 的 packets 数量不超过 rwnd。\n对于 receiver：$\\mathrm{rwnd=RcvBuffer-[lastByteRcvd-LastByteRead]}$\n对于 sender：$\\mathrm{LastByteSent-LastByteAcked\\le rwnd}$\n当 $\\mathrm{rwnd}=0$ 时会导致 sender 无法发送 packet 即使 receiver 之后拥有了可用 buffer，因此需要 sender 在这之后继续发送大小为 1 byte 的 segment，而 receiver 有了可用的 buffer 后会 ACK 这个 segment。\nTCP Connection Management three-way handshake：\nclient 发送 SYN bit 为 1 的 SYN segment，并且 data 为空，rand 一个 initial sequence number (client_isn) 。 server 接收到 SYN segment 后分配 TCP buffer 和 variables 给这个 connection，然后发送 SYN bit 为 1，acknowledge number 为 client_isn + 1 ，data 为空的 SYNACK segment，并且 rand 一个 initial sequence number (server_isn) 。 client 收到 SYNACK segment 后分配 buffer 和 variables 给这个 connection，然后发送 SYN bit 为 0，acknowledge number 为 sever_isn + 1 ，data 为空的 ACK segment，并且可以添加 data。 断开连接时，双方都要互发 FIN bit 为 1 的 FIN segment，收到之后都需要发送对应的 ACK，并且提出断开连接的一方会等待一段时间后再断开连接来让对方有机会在 ACK 丢包时重传 FIN segment。\n如果尝试连接一个不接受 TCP connection 的端口，会收到 RST bit 为 1 的 RST segment。\nPrinciples of Congestion Control congestion 会导致：\nlarge queue delay router buffer overflow 导致丢包和 retransmission large delay 导致 premature timeout 从而导致 unneeded retransmission 传输过程中一个 router 出现丢包，则前面所有 router 的工作都浪费了 congestion control 主要分为两大类：\nend-to-end: network layer 不提供任何有关 congestion 的信息，仅由 retransmission 和 delay 的增加来推断出 congestion network-assisted: router 提供 congestion feedback（例如用一个 bit 表示是否 congested，或者提供更复杂的信息，如 maximum host sending rate），可以是由 router 发送一个新的 packet，也可以是 router 修改正在传输的某个 packet 的相关 field，然后由 receiver 通知 sender。 TCP Congestion Control Classic TCP Congestion Control sender 会使用一个 congestion window ($\\mathrm{cwnd}$) 来限制发送的速率，使得 $\\mathrm{LastByteSent-LastByteAcked\\le \\min{cwnd, rwnd}}$，从而发送的速率大约为 $\\mathrm{cwnd/RTT}$.\nclassic TCP congestion control 主要有以下几个原则：\n丢包意味着 congestion，因而 sender 应该要减小 $\\mathrm{cwnd}$ ACK 表明没有 congestion，因而 sender 可以增大 $\\mathrm{cwnd}$ 可以不断增大 $\\mathrm{cwnd}$ 来试探什么时候会发送 congestion TCP congestion-control algorithm 主要有 3 个部分：\nslow start: 初始状态以及 timeout 后到达的状态。从 $\\mathrm{cwnd=1,MSS}$ 开始，每收到一个 ACK 就增大 $\\mathrm{1,MSS}$，相当于每个 RTT $\\mathrm{cwnd}$ 翻倍，直到 $\\mathrm{cwnd\\ge ssthresh}$ 进入 congestion avoidance。 congestion avoidance: 每个 ACK 增大 $\\mathrm{MSS\\cdot (MSS/cwnd)}$，相当于每个 RTT 增大 $\\mathrm{1,MSS}$。 fast recovery: 收到 3 个 duplicate ACK 后会进行 fast retransmit，之后转移到 fast recovery。从 $\\mathrm{cwnd=ssthresh+3, MSS}$ 开始，每次再收到一个 duplicate ACK 就增大 $\\mathrm{1, MSS}$，收到 new ACK 则转移到 congestion avoidance。 正常情况下会在 congestion avoidance 和 fast recovery 之间反复切换，此时 cwnd 的增长是线性的，减少则是减半，称为 additive-increase, multiplicateive-decrease (AIMD)，AIMD 的 congestion control 会导致 cwnd 呈现锯齿状的变化。\n上面描述的所有内容加起来是 TCP Reno，如果用 slow start 替代 fast recovery 则是更古老的 TCP Tahoe。\nTCP Reno 的上升曲线是线性的，不能快速恢复到接近 congestion 的临界值，对带宽的利用不是很高效，TCP CUBIC 则是在此基础上进行优化后的版本。\n记 $W_{max}$ 为 TCP 检测到丢包时的 cwnd 的大小，$k$ 为 cwnd 重新增长到 $W_{max}$ 的大概时间，当当前时间距离 $k$ 较远的时候则快速增加 cwnd，接近 $k$ 的时候则缓慢增加，即便超过了 $W_{max}$ 但是没有检测到丢包时也遵循同样的规则。\n根据 TCP Reno 的线性增长的特性可以计算出大致的平均 throughput 为 $\\dfrac{0.75\\cdot W}{RTT}$。\nNetwork-Assisted Explicit Congestion Notification and Delayed-based Congestion Control Explicit Congestion Control (ECN) 是一种 network-assisted congestion control，它对 TCP 和 IP 的 header 都进行了扩展。\nECN 在 IP datagram header 中使用了两个 bit，一个给 router 来表示是否 congested（一般在实际发生前设置），另一个给 sender 设置来告诉 router 自己和 receiver 是否是 ECN-capable 的。\n当 receiver 收到 router 的 congestion 信息后，会在 ACK 中设置 ECE (explicit congestion notification echo) flag，sender 收到后会将 cwnd 减半，然后在下一个 segment 中设置 CWR (congestion window reduced) flag。\nDelayed-based Congestion Control delay-based congestion control 也能在丢包发生前就检测到 congestion。\nTCP Vegas 会维护历史最大的 throughput ($\\mathrm{cwnd/RTT}$)，如果当前的 throughput 小于这个值，则说明发生了 congestion。\nFairness 假设当前有 $K$ 个 TCP connection 共用一个 transmission rate 为 $R$ 的 bottleneck link，并且没有其他数据传输。如果每个 connection 的平均 throughput 都是 $R/K$，则称使用的 congestion control mechanism 是 fair 的。\n在各方的 RTT 相同的情况下，AIMD 是 fair 的，如下图所示。\n但是当各方 RTT 不同时，RTT 更小的往往可以获得更大的 throughput。\nUDP 是没有 congestion control 的，会导致 unfairness。另外，application layer 可能会使用多个 parallel TCP connection 也会导致 unfairness。\nEvolution of Transport-Layer Functionality 现在有许多种不同的 TCP/UDP 版本，丢弃了某些原有的功能/新增加一些功能来适应新的环境。\nQUIC 是一个基于 UDP 的 application layer protocol，具有以下 feature:\nconnection-oriented and secure。需要 handshake 来建立连接，并且所有数据加密。connection-establishment handshake 和 authentication and encryption handshake 被合并在了一起，从而比 TLS 更快。 stream。以 stream 为单位传输 application data，而多个 stream 可以放在单个 packet 中传输。 reliable, TCP-friendly congestion-controlled data transfer。其中 in-order delivery 是对每个 stream 分别保序，而一个 stream 可以放在不同的 packet 中，所以不同 stream 之间不会带来阻塞 (HOL blocking)。另外也采取了与 TCP 类似的 congestion control。 ","description":"Transport Layer","tags":["Computer Network","CNATDA"],"title":"CNATDA 第三章学习笔记","uri":"/posts/cnatda-ch3/"},{"categories":["Study Notes","CNATDA"],"content":"Introduction to the Link Layer link layer 的主要任务是将 datagram 从当前 node 传输到另一个 node，还可以提供以下服务：\nframing：将 network layer 的 datagram encapsulate 成 link layer 的 frame 然后进行传输。 link access：使用 medium access control（MAC）协议来决定传输哪一个 frame。对于 point-to-point 的传输是很简单的，但是对于 multiple access problem 来说，则需要 MAC protocol 来进行协调。 reliable delivery：使用 acknowledgments 和 retransmission ，与 transport layer 的可靠传输服务类似。reliable delivery 在出错率较高的 links（如 wireless link）中采用较广，但是在出错率较低的 links 中则会造成不必要的 overhead，采用较少。 error detection and correction：通过在 transmitting node 的 frame 中加入 error-detection bits 和在 receiving node 中进行 error check 来实现。link layer 的 error detection 主要在硬件层面上实现。 在 host 中，link layer 使用名为 network adapter（network interface controller，NIC） 的 chip 实现，属于硬件层面的实现。另外，还会有一部分由 CPU 上的软件实现。\nError-Detection and -Correction Techniques error-detection and -correction 允许接收端偶尔的差错检测，但是不是永远都会进行，也就是说会存在未检测到的 error bits。\nParity Checks 实现 bit 层面上的 error detection 最简单的方法就是添加一个 parity bit 来记录原来值为 1 的 bits 的数目。这在只有一个 bit 会出错的情况下是 work 的，但是事实上 error 总是 clustered together in “bursts”，从而单个的 parity bit 行不通。\n考虑采用 two-diminutional parity ，将要传输的 bits 分成一个二维矩阵，每一横、每一列都设置一个 parity bit，这样以来，不仅可以确定 error bit 的位置，还能进行 correction。\n这种既能 detect 也能 correct 的能力叫做 forward error correction（FEC）。\nChecksumming Methods 在 checksumming methods 中，d bits 的 data 会被分成 k bit 大小的整数序列，然后将这些整数的和作为 error-detection bits。 Internet checksum 就是这样的一种方法。在 TCP 和 UDP 中，所有 fields 包括 header 和 data 都会进行 Internet checksum ，而 IP protocol 中只有 header 会进行。\nchecksumming methods 需要相对少的 packet overhead，但是对 errors 的保护能力相对 link layer 采用 cyclic redundancy check 较弱。由于 transport layer 主要在软件上实现，需要的是 simple and fast 的差错检测能力，而 link layer 在硬件层面上实现使得能进行更复杂的 CRC 运算，所以 transport layer 采用的是 Internet checksumming 而 link layer 采用的是 CRC。\nCyclic Redundancy Check (CRC) 生成一个多项式来实现，详细的可以看 UCB CS70 Error Correcting Codes 或者看书，其实就是 CS 70 这个的 bit 版本。\nMultiple Access Links and Protocols network links 分为两种：point-to-point 和 braodcast。在 broadcast link 中，如果有多个 nodes 同时发送信息，则会产生 collision 。\n为了解决 multiple access problem，需要一个 multiple access protocol ，主要有三类 multiple access protocols：channel partitioning protocols，random access protocols 和 taking-turs protocols。\n一个合理的 multiple access protocol 需要满足以下条件：\n只有一个结点发送消息则完全使用带宽 多个结点发送则平分带宽 decentralized simple，inexpensive to implement Channel Partitioning Protocols TDM 将 time 分成 frames 然后每个 frame 又分成 slots，每一个 time slot 分配给一个 node。\nFDM 则将频率分为 frames 再细分为 slots 。\nFDM 和 TDM 都能保证每个 node 都能得到均分的传输速率，并且完全避免了 collision，但是也会导致只有一个 sender 时不能使用分配给其他 nodes 的 slots。\ncode division multiple access（CDMA）给每个 node 分配一个不同的 code，node 将 data 通过分配的 code 进行 encode 之后再发送。CDMA 在 wireless channel 中较常用。\nRandom Access Protocols 每个遭遇 collision 的结点都独立选取一个 random delay，在 delay 之后进行 retransmission。\nALOHA 假设每个 frame 大小相同，将 slot 的大小等于传输一个 frame 的时间，每个结点只会在 slot 的开始传输，并且所有结点是同步的，结点会在 slot 结束之前检测到 collision。\n在 slotted ALOHA 中，结点在检测到 collision 之后立即停止传输，并且在之后的 slots 的开头以概率 $p$ 进行传输直到成功，是 decentralized 。\n恰好一个结点进行传输的 slot 被称为 successful slot，slotted multiple access protocol 的 efficiency 被定义为 successful slot 的占比。显然，有 $n$ 个 active nodes 的时候，efficiency 为 $np(1-p)^{n-1}$ ，当 $n$ 很大时，它的最大值为 $1/e\\approx 0.37$。\n在 pure ALOHA 中，不进行 slot 的划分，是 fully decentralized 的，并且每个结点遭遇 collision 之后会以概率 $p$ 立即重传，尽管更加去中心化，但是它的 efficiency 也只有 slotted ALOHA 的一半了。\nCarrier Sense Multiple Access with Collision Detection (CSMA/CD) CSMA 基于 “Listen before speaking” 的原则进行 carrier sensing，而 CSMA/CD 则是 CSMA 加上 “If someone else begins talking at the same time, stop talking” 的原则进行 collision detection。\n由于 channel propagation delay 的存在，一个结点在检测到另一个结点发送过消息前可能已经发送过一段消息了。\n在 CSMA/CD 中，结点遇到 collision 会随机等到一段时间再进行重传，这个等待时间由 binary exponential backoff 算法进行计算：当前如果累计检测到了 $n$ 次 collision，则在 ${0,1,2,\\dots,2^n-1}$ 中随机取一个数作为 $K$ ，然后等待传输 $K\\cdot 512$ bit 的用时，当 $n$ 超过 10 的时候则取 10。如果等待之后传输成功，则 $n$ 重新变为 0。\nCSMA/CD 的 efficiency 约为 $\\dfrac{1}{1+5d_{\\mathrm{prop}}/d_{\\mathrm{trans}}}$ ，其中 $d_{\\mathrm{prop}}$ 表示 propogation delay，$d_{\\mathrm{trans}}$ 表示一个 maximum-size frame 的传输用时。\nTaking-Turns Protocols taking-turns protocol 的主要思想是让结点轮流发送消息。\npolling protocol 中存在一个 master node，它轮流 poll 每个结点让其发送不超过 maximum number 个 frame，发送完再继续 poll 下一个结点。polling protocol 是 centralized 的，master node 倒下了整个系统就会崩溃，同时也引入了 polling delay：对 inactive nodes 进行 poll 会浪费时间。\ntoken-passing protocol 中每个结点以固定顺序向下一个结点发送 token，当结点需要传输时则会先传输不超过 maximum number 个 frame 再传递 token。token-passing protocol 是 decentralized 并且高效的，但是当一个结点崩溃了同样会使得整个 channel 崩溃，需要采取 recovery procedure。\nDOCSIS: The Link-Layer Protocol for Cable Internet Access DOCSIS 用于 cable access network，将一个 residential cable modems 连接到 cable modem termination system（CMTS），同时用到了多种 multiple access protocol。\nDOCSIS 使用 FDM 分为 downstream 和 upstream 两个 channel，downstream channel 的内容由 CTMS 向 cable modem 发送，不存在 multiple access problem。upstream channel 则被分为了多个 mini-slots，这些 slots 由 CMTS 通过 downstream 动态分配，需要由 cable modem 发送 mini-slot-request-frame，这些 requests 通过一些特殊的 mini-slots 以 random access 的方式发送，通过是否收到 CMTS 回复的 mini-slots 来判定 collision 的存在，使用 binary exponential backoff。\nSwitched Local Area Networks Link-Layer Addressing and ARP host 和 router 的每个 adapter 都有一个 LAN address (physical address/MAC address) ，对于有多个 interface 的 router 来说，每个 interface 都会有一个 MAC address。\nMAC address 的长度为 6 bytes，由 IEEE 进行分配，每个 adapter 的 MAC address 都是固定不变的。\n当 adapter 需要发送 frame 给目的 adapter 时会将目的 MAC address 插入 frame 然后送往 LAN，由 switch 将其向所有的 interfaces 进行 broadcast，与目的 MAC address 匹配的就会接收，否则丢弃。\nMAC broadcast address 为 ff:ff:ff:ff:ff:ff。\nAddress Resolution Protocol ARP 是用来将 subnet 内部的 IP address 转换成 MAC address 的。\n每个 host/router 内部维护一个 ARP table，存储 IP 到 MAC 地址的映射，同时会有一个 TTL，到期则会丢弃这条记录。\n当 ARP table 中没有对应的 MAC 地址时，sender 会发送一个 ARP request，其中目的 MAC 地址为 MAC broadcast address，对应的 receiver 收到后会发送 ARP response，一般不是 broadcast。sender 收到 response 后更新 ARP table。通过这种机制，ARP table 可以自动构建，不需要手动配置。\n如果需要向 subnet 外发送信息，则是需要发送给 gateway（first-hop router），需要查询的也是 gateway 的 MAC 地址，gateway 收到 frame 后会传递给它的 network layer 将 source IP address 修改为它的 IP address。\nARP 是一个位于 network layer 和 link layer 之间的 protocol。\nEthernet Ethernet 通常使用 hub 或 switch 来连接各个 interface。hub 会将收到的每个 bit 转发给所有 interfaces，容易造成 collision。switch 根据 MAC protocol 进行转发，避免了 collision。\nEthernet 的 frame 通常由以下部分组成：\ndata field（46 to 1500 bytes）：IP datagram。如果 IP datagram 的长度小于 46 bytes，则会填充至 46 bytes，network layer 通过 IP datagram 的 length field 来去除填充。 destination field（6 bytes） source field（6 bytes） type field（2 bytes）：标识 upper layer protocol。 CRC checksum（4 bytes） preamble（8 bytes）：标识 frame 的开头并同步时钟。 Ethernet technologies 提供的是 connectionless、unreliable 的服务。\nLink-Layer Switches switch 的主要任务是将 incoming frames forward 到 outgoing links。switch 是 transparent 的，也就是说，host 和 router 并不知道它的存在，它也不需要手动配置，是 plug-and-play 的。\nswitch 的每个 interface 都有一个 output buffer，与 router 类似。\nswitch 主要有两个功能：filtering 和 forwarding。它们通过维护一个 switch table 来实现：存储 MAC 地址和对应的地址，另外还有过期时间。\n当从 interface $x$ 中收到 destination MAC address 为 $\\alpha$ 的 frame 时：\n若 $\\alpha$ 不在 switch table 中，则 broadcast。 若 $\\alpha$ 对应的 interface 为 $x$ 时，则 discard。 若 $\\alpha$ 对应的 interface 不等于 $x$ 时，则 forward。 switch 是 self-learning 的：如果在 intreface $x$ 中收到了 source MAC address 为 $x$ 的 frame 会在 table 中添加相应的记录。\n相比 hub，switch 具有以下优势：\n消除了 collision。 可以将不同 technology 的 links 连接在一起。 提供 network management 服务，如 enhanced security 等。 switch 和 router 各自具有 pros 和 cons：\nswitch 即插即用，无需手动配置；只有 2 layers，性能更好；只能练成 spanning tree，不能形成环；如果 subnet 内 host 太多会影响性能；可能遭受 broadcast storm。 router 需要手动配置；有 3 layers，性能略差；可以随便连，从而提供多个 route 供 routing protocol 使用，实现 best path；提供 firewall 防止 broadcast storm。 一般来说，几十上百个 host 使用 switch 即可，更多的需要 router 进行中转。\nVirtual Local Area Networks (VLANs) LANs 存在以下一些限制：\n缺少对 traffic 的限制，例如未被学习到的 MAC 地址发送的 ARP 仍需 traverse 整个 subnet，降低了性能。 switch 的 ports 数量不足以匹配 subnet 内 host 的数量。 要在不同的 subnet 之间移动 host 需要更改物理接线。 VLAN 可以解决这些问题。它通过软件对 switch 的 ports 进行配置，将 ports 划分为不同的 group，每个 group 都属于一个 subnet。为了将不同 subnet 相连，可以使用一个 router 将这两个 switch 连接起来，为了方便，很多 switch 都自带一个 router。\n可以使用 VLAN trunking 将分属于不同 switch 上的 port 连接起来作为一个 VLAN：每一个 switch 上有一个 trunk port，将需要 trunking 的 switch 通过 trunk port 相连，发送到对面 switch 的 VLAN 的 frame 会被 forward 到 trunk port。 trunking 时使用的是 extended Ethernet frame format 802.1Q，由发送端的 switch 将对应的 VLAN tag 加入 header 来对 VLAN 进行标识。\n除了基于 switch port 的 VLAN，还有基于 MAC address 和 network protocol 的 VLAN。\nMultiprotocol Label Switching (MPLS) MPLS 采取了一个重要的概念：定长的 label 来优化 IP router 进行 forward 的速度。它仍然使用的是 IP addressing 和 routing，但是在 link layer header 和 network layer header 之间加入了一个 MPLS header，它由 label、exp、s、TTL 组成。\nMPLS frame 仅仅能在支持 MPLS 的 router 之间进行传输，在处理 MPLS datagram 时，router 不需要将 destination IP 展开并在 forwarding table 中 look up 来进行 longest prefix match。\nMPLS 可以潜在提升 switching speed，也带来了新的 traffic management 的能力，如 VPNs。\nData Center Networking 大型互联网公司建造了许多 data centers，它们对外接入 Internet，对内存在一套 data center networks。\ndata center 主要提供 3 种服务：provide content、distributed computing、cloud computing。\ndata center 内的 hosts 称为 blades，几十个 blades 组成一个 rack，每个 rack 有一个 switch，被称为 Top of Rack (ToR) switch。\ndata center network 支持两种 traffic：外部的 clients 与内部的 hosts 之间的 traffic、内部的 hosts 之间的 traffic，为了支持第一种 traffic，设有 border routers 来连接 Internet。\n另外，为了分配外界大量的 requests，data center network 中设有 load balancer 来分配这些 requests 给不同的但是提供相同内容的 hosts 从而平衡 load，同时 load balancer 还起到了一个 NAT-like 的功能。\n树状的网络结构使得 data center 可以拥有上万个 servers，但是也存在着 limited host-to-host capacity 的问题。解决这个问题有 3 种方法：\n部署更高速率的 switch 和 router，这样开销会很大。 将需要互相通信的 host 尽量放在一个子树下，这样不容易做到且灵活性较低。 将相邻两层级的 switch 之间互相连通，增加 interconnection 的数量，这样在优化性能的同时也增加了系统的稳定性。 data center 通常使用 SDN 来对网络进行集中式管理。\n为了方便 cloud computing 和网络管理，data center 使用 virtual machine 来将软件与硬件进行 decouple。为了方便 VM 在不同 host 之间移动，可以将整个 data center network 看成是一个 single、flat、layer-2 network。要使所有的 hosts 看上去是与单个的 switch 相连，可以将 ARP 的机制改成一个类似 DNS query 的机制，并且维护一张分配给 VM 的 IP 地址到 VM 对应的 ToR switch 的映射表。\ndata center 内部的 hosts 有限，因此内部 network 的 buffer size 和 delay 也很小，并且 congestion control 会降低性能，因此一般使用针对 data center 的 TCP protocols。\nmodular data center (MDC) 是一个由至多数千个 hosts 组成的 container，当 MDC 内部的某个 component 坏掉时，MDC 可以以 degraded performance 继续工作，当很多 components 都坏掉的时候，整个 MDC 就会被丢弃。\n很多公司会定制他们的 data center 内的几乎一切内容。\nAmazon 使用 “available zones” 将 data center 在邻近但是位置不同的地方进行复制，从而提供 fault tolerance，也保证了 low latency，提高了服务的可靠性。\n","description":"The Link Layer and LANs","tags":["Computer Network","CNATDA"],"title":"CNATDA 第六章学习笔记","uri":"/posts/cnatda-ch6/"},{"categories":["Study Notes","CNATDA"],"content":"你口安计网怎么内容又多课时又少考的还早啊（恼）\n第三章讲的太快没来及看书，就先咕咕咕了。\n现在补完第三章了\nOverview of Network Layer Network layer 可以细分成两个部分：data plane 和 control plane。\ndata plane 的主要功能是 forwarding（也叫做 switching ），也就是由 router 决定将 input link 收到的数据转发到哪个 output link。\nrouter 中使用一个 forwarding table，根据 packet header 中的某些 fields 来 index forwarding table，从而得到 outgoing link interface。\ncontrol plane 的主要功能是 routing，即决定从 sending host 到 receiving host 到路径。\n计算 forwarding table 也是 control plane 的任务，它有两种实现方式：\nthe traditional approach：router 之间通过 router protocol 进行通信，然后使用 routing algorithm 计算得到 forwarding table。 the SDN approach：router 只进行 forwarding，routing 由一个 remote controller 完成——router 向 remote controller 发送信息，由 remote controller 计算得到 forwarding table 发送给 router。这个 remote controller 通常由软件实现，这种方法称为 software-defined networking。 What’s Inside a Router? router 包含以下几个部分：\ninput ports: incoming link 的 physical layer 和 link layer look up: 从 forwarding table 查找对应的 output port 将 control packets forward 到 routing processor 存在 input queue switching fabric: 连接 input ports 和 output ports output ports: outgoing link 的 physical layer 和 link layer 存在 output queue routing processor: 执行 control-plane 的功能，计算 forwarding table，进行 network management traditional: 执行 routing protocols SDN: 与 remote controller 进行通信 input ports、output ports 和 switching fabric 通常使用硬件实现，这样使得 forwarding 的速率在 ns 级从而保证通信速率。而 control plane 的功能一般只需保持在 ms 或 s 级，可以用软件实现。\nInput Port Processing and Destination-Based Forwarding forwarding table 一般由 routing processors 更新或者接收自一个 remote SDN controller。\n多个 input ports 可以合并在一个 line card 上，forwarding table 会从 routing processor 给每个 line card 复制一份，从而可以在每个局部分别计算。\ndestination-based forwarding 的 forwarding table 一般以 IP 地址前缀为 index，link interface 为 value 进行 longest prefix matching。\nlookup 需要在 ns 级别实现，而 forwarding table 一般很大，因此还需要使用特殊的算法或存储器。\ninput ports 的 processing 还需要包括 physical-layer 和 link-layer processing，对 packets 的 version number、checksum、TTL 的检查与更改，对 network management 的 couters 进行更新。\nSwitching switching 有多种形式：\nvia memory: 从 input port 复制到 memory 再复制到 output port，如果使用集中的 memory 而不是每个 line card 单独的 memory 会导致传输速率收到 memory 的速率限制，而且一次只能传输一个 packet via a bus: 将 packet 加上一个 label 然后通过 bus 传输到所有的 output port，根据 label 决定是否留下，传输速率收到 bus 的速率限制，一次只能传输一个 packet via an interconnection network: 每个 input port 对应一个 bus，每个 output port 对应一个 bus，每对 input port bus 和 output port bus 之间都有 crosspoint，通过控制 crosspoint 来控制从哪传到哪。这是 non-blocking 的，只要两个 pakcet 的 output port 不同就能同时传输。 Input Queuing 如果 switching fabric 的速率大于所有 input port 的速率之和，则一般不会发生 input queuing，但是如果它们的 output port 都相同的话还是会存在 queuing。\n以 switching via interconnection network 为例，一个 packet 即使没有和它 output port 相同的 packet 也可能因为 input queue 中在它前面的其他 packet 而被 block，即 HOL blocking。\nOutput Queueing 如果 packet 到达 output port 的速率超过了 output line 的速率则会发生 output queuing。\n当 packet 到达 output port 的时候 buffer 满了则需要考虑丢弃哪个 packet。在 buffer 满之前进行 pakcet dropping 或者 marking 称为 active queue management (AQM)。\nHow Much Buffer Is “Enough” ? 存在 $N$ 个 TCP connection flow 经过一个带宽为 $C$ 的 link 时，需要的 buffer 大小为 $\\mathrm{B=RTT\\cdot C/\\sqrt{N}}$。\n拥有更大的 buffer 虽然能减少 loss，但是也会带来更大的 queuing delay。TCP 可能会使得 buffer 一直不被清空，从而导致 queuing delay 是 constant 且 persistent 的，这被称为是 bufferfloat，可以通过采取 AQM 来减缓。\nPacket Scheduling 主要有以下几种：\nFIFO (First In First Out) priority queuing: 优先级高的先开始传输 weight fair queuing (WFQ): 给每个 class 一个权重来依次传输，保证这个 class 的传输频率是 $\\frac{w_i}{\\sum w}$ The Internet Protocol (IP) 现在使用最多的 Internet protocol 是 IPv4 ，同时 IPv6 也在逐渐取代 IPv4 。\nIPv4 Datagram Format IPv4 的 datagram 格式如下。\nversion number: 长度为 4 bit ，表示 IP 协议的版本。 header length: 由于非定长的 options field 的存在，需要用 header length 表示 header 的长度，但是一般 options 为空，所以 header length 一般为 20 byte 。 type of service (TOS) : 用来区分不同类别的 datagram 。 datagram length: header + data 的长度。 identifier、flags、fragmentation offset: 较大的 datagram 会被分成一些较小的 datagram 并分别 forward ，这些是用来识别它们的。 time-to-live: 每被一个 router 加工就会减少 1 ，成为 0 的时候就会被丢弃，用来防止死循环。 protocol: 只会在到达终点的 network layer 时使用，表明应该交给哪个 transport layer 的协议。 header checksum: 检验 bit errors ，header 部分每 2 bytes 累加，得到的结果再取反，检查是否与存储在这个 field 的值相同。若不同，则直接丢弃。 source and destination IP address: 起点与终点的 IP 地址。 options: 允许 IP header 得以拓展，但是很少被使用到。 data (payload): 包括 transport layer 的 segment ，也可以是其他类型的 data ，如 ICMP messages 。 如果 options 为空，则一个 IP header 长度是 20 bytes ，如果使用 TCP 协议，则这个 datagram 的总的 header 长度为 40 bytes 。\nIPv4 Addressing 一个 host 和他的 physical link 之间的边界就是 interface ，类似的，一个 router 和它每一个连接的 link 之间的边界也是一个 interface 。也就是说，其实相比于一个 IP 地址识别的是一个 host ，它识别的是一个 interface 的说法更准确。\nIP 地址长度为 32 bits ，用 dotted-decimal notation 表示。\nhost interfaces 和它们连接的 router 的 interface 共同组成一个 subnet ，也称为 network 。\nIP 地址按照 223.1.1.0/24 的形式分配给 subnet ，其中 24 称为 subnet mask ，是 IP 地址匹配过程中至少需要匹配的 prefix 的长度，而 223.1.1.0 的前 24 bits 就是这个 subnet 的地址。\nInternet 分配 IP 地址的策略是 Classless Interdomain Routing (CIDR) 。在 CIDR 被采用之前，最常采用的是 classful addressing ，subnet mask length 只能为 8、16、24 bits ，分别称为 class A, B, C network ，导致不同 subnet 可分配地址数量差异过大，难以按需分配。\nlongest prefix matching 使得 address aggregation 成为可能：拥有相同 prefix 的 subnet 可以合并成一个更大的 subnet 。\n255.255.255.255 是一个特殊的 IP 地址，表示 broadcast 地址。destination address 为 broadcast 地址的 datagram 会被发送给 subnet 内的所有 host ，也可能发送给 neighboring subnet 。\nObtaining Addresses Obtaining a Block of Addresses IP address block 由 ICANN 管理并分配给 ISP 和一些 organizations ，它们得到之后还可以将 IP address block 更细分然后分配给用户。\nObtaining a Host Address: DHCP router 的 IP 地址一般是手动设置的，而 host 的地址则是通过 Dynamic Host Configuration Protocol (DHCP) 获得的。\n每个 subnet 都会有至少一个 DHCP server 或者一个知道 DHCP server address 的 DHCP relay agent (一个 router ) ，由它们来给 host 提供临时的 IP 地址。\nDHCP 获取 IP 地址的步骤如下：\nDHCP server discovery: 新来的 host 通过 UDP 发送给 255.255.255.255 ，port 67 ，使用 transaction ID 作为 identifier 。 DHCP server offer(s): DHCP server 收到 discover message 后发送 offer message 给 255.255.255.255 ，port 68 ，包含 yiaddr 、transaction IP 、DHCP server IP 、Lifetime 。 DHCP request: host 收到 DHCP offer 后选择其中一个作为 IP 地址，然后以 broadcast 的方式发送 DHCP request，与 DHCP offer 具有相似的结构。 DHCP ACK: DHCP server 收到 DHCP request 后发送 DHCP ACK 。 Network Address Translation (NAT) subnet 需要一段连续的 IP 地址，如果设备数量超过了原先分配的 IP address block 的数量就难以分配新的地址，于是引入了 Network Address Translation (NAT) 的方法来解决这个问题。\n使用 NAT 时，subnet 内部使用 IP address space reserved for private network （10.0.0.0/8、172.168.0.0/16、192.168.0.0/16），用一个 router 与外界连接并进行 NAT ，这个 router 对外界表现为 a single device with a single IP address，通过 NAT translation table 在 private address + port 与 WAN-side address + port 之间进行转换（给每个 host 以及 application port 分配一个 NAT port 进行区分）。这个 router 的 public address 从 ISP 获得，同时它作为 DHCP server 为 subnet 内部提供 private address 。\nNAT 同时也带来了一些问题，比如 subnet 内的 port 一般会变，而某些时候需要特定的不变的 port ，这个问题可以通过 NAT traversal 来解决。\nIPv6 为了解决 IPv4 地址即将被耗尽的问题，人们发明了 IPv6 ，除了将地址长度从 32 bits 扩展到了 128 bits ，IPv6 还解决了 IPv4 中其他一些问题。\nIPv6 datagram 的主要格式如下：\n主要变化有：\n在 unicast 和 broadcast 的基础上引入了 anycast address，允许了向多个地址之一发送 datagram。 使用定长为 40 bytes 的 header。 引入 flow table 使得 router 可以对 flow 进行特殊处理。 删除 fragmentation 提高性能，如果 datagram 太大则直接丢弃并发送相应的 ICMP error message。 删除 header checksum 冗余功能提高了效率。 删除 options ，其中 next header 不一定是 transport layer protocol ，也可以是 option。 TOS 改为 traffic class ，TTL 改为 hop limit ，datagram length 改为 payload length（不包含 header length），protocol 改为 next header。 由于 IPv4 到 IPv6 的转换仍在进行中，为了兼容旧的设备，采用 tunneling 将 IPv6 的 datagram 作为 IPv4 的 payload 进行传输，其中两个 IPv6 router 之间的 IPv4 router 被称为 tunnel 。\nGeneralized Forwarding and SDN Generalized Forwarding 基于 “match-plus-action” 的原则，相对于 destination-based forwarding，“match” 时还可以考虑 IP header field 中 destination 以外的 fields ，也可以考虑 link-layer header、transport-layer header 等，而 “action” 除了 forward 还可以 drop、修改 header field 等。\nOpenFlow 是一个 generalized forwarding 的协议，规定了 match 时可以/不能使用哪些 field，以及可以采取哪些 action。\nMiddleboxes network 中除了 forwarding 之外用来实现一些其他功能的设备称为 middlebox，它们主要提供一下几种功能：\nNAT translation security services，如 firewall performance enhancement，如 Web cache middlebox 在一定程度上破坏了 network 层的 layered architecture ，也就是 abstraction 的概念。\n","description":"The Network Layer: Data Plane","tags":["Computer Network","CNATDA"],"title":"CNATDA 第四章学习笔记","uri":"/posts/cnatda-ch4/"},{"categories":["CS"],"content":"从 8 月初到现在，历时将近 3 个月，我才终于通关了 CS61A, Summer 2020 ，因为 8 月时过于怠惰，开学之后又有丰富多彩的课程表（不愧是你啊，HUST），导致战线拉的这么长（碎碎念）。\n在 CS61A 这门课中，收获的远远不止是 Python、Scheme、SQL 语法，它通过一个个精心设计的 lab、hw、proj，让我能切身实际的感受到编程的魅力，另外，认真完成这些任务后，我对 CS 领域中的不少理念，如 “abstraction” 等，有了更深刻的理解，这绝对是乖乖跟着 HUST 答辩课程学习所得不到的，更重要的是，CS61A 为我打开了 CS 的第一扇门，尽管它不是我看的第一个国外优质课程。\n不仅仅是 CS 本身的乐趣，教授这门课的 John DeNero 教授也是幽默风趣，能传授人生哲理的老师。比如万圣节时 DeNero 教授倾心录制的视频，带着搞怪南瓜帽子的教授着实有趣，但是更值得注意的是他的话：我们不应该为 GPA 所困扰，CS 的学习本身是一件很有趣的事情。\nComputers and science, how did they meet?\nComputers are cool, and science is neat.\nBut then, one day, they must have teamed up on the street.\nAnd created this course, in which I have a seat.\nAnd it’s hard, the projects are tough to complete,\nAnd Scheme seems more like a trick than a treat.\nAnd the tests, the tests are the very worst part.\nI study, I practise, and I’m really smart.\nAnd I know all the rules of assignment by heart.\nBut the day of the midterm, the TA says start,\nAnd all of my test taking plans fall apart,\nBecause the problems are even more abstract than art,\nSometimes I can’t even solve problem one,\nAnd why is problem named some stupid pun?\nAnd that jerk Fibonacci, he’s so overdone.\nComputers and science has teamed up and won.\nBut hold on…, courses aren’t lost, they aren’t won,\nAnd learning to program is suppose to be fun.\nSo don’t let these tests and these points get the best of you,\nGrades in your major count less than you think they do.\nI’ve never heard them come up in an interview.\nAnd the faculty I know really likes students who might not aced every test, but don’t quit\nThey focus on learning, improvement, and grit\nAnd soon they have learned about more than a few things\nAnd all their hard work made them able to do things\nAnd doing things, that’s what the world cares for.\nWhat you can do matters more than your score.\n也是因为看过了 CS61A ，这更加坚定了我一定要申请到 PhD 的想法，希望大三的时候能有机会报名 UCB 的 BGA 项目，拿一封份量足够的推荐信（做梦也想去四大😭\n好了，回归正题，说说 CS61A 究竟讲了些啥。\n首先，当然是基础的 Python 语法了，但是和国内教学 C 语言语法不同，CS61A 通过 Python 还讲授了 CS 领域重要的概念——abstraction，另外，通过他的 lab、hw ，你能对递归有一个更深刻的理解。\n其次，Python 作为著名的 OOP (Object-Oriented-Programming) 例子，当然要讲讲 OOP 究竟是个啥玩意了。我之前对面向过程、面向对象的理解纯粹来自于廖雪峰的 Java 教程中提到的「建造凳子」的例子，可以说并没有完全理解，但是被问到可以用这个例子糊弄过去（捂脸）。在看过 John DeNero 教授对 OOP 的解释并且做完了相应的编程练习之后，我还是挺有自信应该理解了 OOP 的概念的，相比于面向过程，OOP 考虑的是一个个的 object ，它属于一个 class ，可以继承这个 class 的 attributes ，它作为一个独立的个体也可以拥有属于自己的 attributes ，同时，object 的所谓的「函数」更准确的说法是 methods，它的作用并不是解决某一个问题，而是对这个 object 做某种操作的「方法」，语言的表达能力终究有限，要实际理解 OOP ，还是得看看 DeNero 教授的讲解，然后做完对应的练习，get your hands dirty 永远是学习 CS 亘古不变的真理。\n之后是 scheme——lisp 的一种方言，用来学习 functional programming 函数式编程的优秀的样例。函数式编程的思想和另外两种编程有很大的不同，最大的感受是你不得不把每一个步骤考虑清楚才能动手 coding ，不像我写 Python 和 C++ ，总是没想清楚实现细节就开始写代码。还有很重要的一点就是 recursion，在 scheme 的练习中需要大量用到 recursion，这可以说是在逼迫你加深对 recursion、abstraction 的理解与运用了。另外，tail- recursion 也是一个很神奇的东西，这玩意让我明白了当年搞 OI 时听到的“开不开无限栈？”中的无限栈到底是啥，同时思考把一个浪费一堆 frame 的 recursion 通过多设置几个带的变量变成了只有线性大小的 frame 的 tail-recursion 也很有意思。\n最后是以 SQL 作为 declarative programming language 的例子讲了 SQL 的基础语法以及 declarative programming language 的概念，这对之后数据库的学习能带来不少帮助。\n总而言之，CS61A 一定是一门优秀的 CS 入门课，无论是大一还是大二，抑或是研究生，甚至是博士生，我都相信 CS61A 是值得花时间认真刷完的一门课，毕竟，它可是能点燃对 CS 的热情的一把火啊！（暴论）\n","description":"CS61A, Summer 2020","tags":["CS61A"],"title":"CS61A 通关感想","uri":"/posts/thoughts-on-completing-cs61a/"},{"categories":["Study Notes"],"content":" Info\nThis is my study note of the Stanford CS229 (Spring 2018), based on my understanding and the course notes released on the official website.\nThe note focuses on important ideas and formulas in machine learning, ignoring overt definitions and long derivations.\nLMS algorithm We now know that the cost function is $J(\\theta)=\\frac{1}{2}\\sum_{i=1}^{m}(h_{\\theta}(x^{(i)})-y^{(i)})^2$, then let's consider the gradient descent algorithm to minimize $J(\\theta)$. $$ \\theta_j:=\\theta_j-\\alpha\\dfrac{\\partial}{\\partial \\theta_j}J(\\theta) $$ Here, $\\alpha$ is called the learning rate.\nAnd we have $\\dfrac{\\partial}{\\partial \\theta_j}J(\\theta)=(h_{\\theta}(x)-y)x_j$ , then $$ \\theta_j:=\\theta_j+\\alpha\\left(y^{(i)} - h_{\\theta}(x^{(i)})x^{(i)}_j \\right) $$ The rule is called the LMS (least mean squares) update rule and is also known as the Widow-Hoff learning rule.\nOur first algorithm using LMS rule is batch gradient descent, it's main process is as follows:\nFor every $\\theta_j$, we have to run over the entire training set. Note that gradient descent algorithm can be susceptible to local minima in general.\nConsider another algorithm called stochastic (incremental) gradient descent, it is as follows:\nIn this algorithm, the $\\theta$ is updated every time we encounter a training example.\nCompare with batch gradient descent, stochastic gradient descent has several advantages:\nWhile batch gradient descent has to scan over the whole set to update a single $\\theta_j$, stochastic gradient descent can start making progress right away. It gets $\\theta$ close to the minimum much faster. (Note that it can never “converge” to the minimum) For these reasons, we prefer stochastic gradient descent when the training set is large.\nThe normal equations The second way of minimizing $J$ is to do calculus with matrices.\nMatrix derivatives We define the derivative of $f: \\mathbb{R}^{m\\times n}\\mapsto\\mathbb{R}$ with respect to $A$ to be:\n$$ \\nabla_A f(A)=\\begin{bmatrix} \\frac{\\partial f}{\\partial A_{11}} \u0026 \\cdots \u0026 \\frac{\\partial f}{\\partial A_{1n}} \\\\ \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ \\frac{\\partial f}{\\partial A_{n1}} \u0026 \\cdots \u0026 \\frac{\\partial f}{\\partial A_{nn}} \\end{bmatrix} $$\nFor trace operator, we have:\n$$ \\mathrm{tr}ABC=\\mathrm{tr}CAB=\\mathrm{tr}BCA \\\\ \\mathrm{tr}A=\\mathrm{A^T} \\\\ \\mathrm{tr}(A+B)=\\mathrm{A}+\\mathrm{B} \\\\ \\mathrm{tr}aA=a\\mathrm{tr}A $$\nFor combinations of these two operations, we have:\n$$ \\nabla_A \\mathrm{tr}AB=B^T \\\\ \\nabla_{A^T} f(A) = (\\nabla_A f(A))^T \\\\ \\nabla_A \\mathrm{tr}ABA^TC=CAB + C^T AB^T \\\\ \\nabla_A|A| = |A|(A^{-1})^T $$\nLeast squares revisited The training set’s input can be written as the following matrix:\n$$ X = \\begin{bmatrix} - (x^{(1)})^T - \\\\ - (x^{(2)})^T - \\\\ \\vdots \\\\ - (x^{(m)})^T - \\end{bmatrix} $$\nAlso, let $\\vec{y}$ be\n$$ \\vec{y}=\\begin{bmatrix} y^{(1)} \\\\ y^{(2)} \\\\ \\vdots \\\\ y^{(m)} \\end{bmatrix} $$\nNow, since $h_{\\theta}(x^{(i)}) = (x^{(i)})^T\\theta$, we can verify that:\n$$ J(\\theta) = \\frac{1}{2}(X\\theta-\\vec{y})^T(X\\theta-\\vec{y}) $$\nTo minimize $J$, we can derive that:\n$$ \\partial_{\\theta}J(\\theta)=X^TX\\theta - X^T\\vec{y} $$\nThen we obtain the normal equations:\n$$ X^TX\\theta = X^T\\vec{y} $$\nThus, the value of $\\theta$ that minimizes $J$ is:\n$$ \\theta = (X^TX)^{-1}X^T\\vec{y} $$\nProbabilistic interpretation To discover whether $J$ is a reasonable choice, let us assume that the target variables and the inputs are related via the equation\n$$ y^{(i)} = \\theta^T x^{(i)} + \\epsilon^{(i)} $$\nLet us further assume that the $\\epsilon^{(i)}$ are distributed IID (independently and identically distributed) according to a Gaussian distribution. We can write this as following:\n$$ p(y^{(i)}|x^{(i)};\\theta)=\\dfrac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\dfrac{(y^{(i)} - \\theta^Tx^{(i)})^2}{2\\sigma^2}\\right) $$\nTo view this as a function of $\\theta$, we instead call it the likelihood function:\n$$ \\begin{align} L(\\theta) \u0026= L(\\theta;X,\\vec{y})=p(\\vec{y}|X;\\theta) \\\\ \u0026= \\prod_{i=1}^m p(y^{(i)}|x^{(i)};\\theta) \\end{align} $$\nThe principal of maximum likelihood says we should choose $\\theta$ to maximize $L(\\theta)$.\nTo make it simpler, we instead maximize the log likelihood $\\ell(\\theta)$:\n$$ \\begin{align} \\ell(\\theta) \u0026= \\log L(\\theta) \\\\ \u0026= m\\log\\frac{1}{\\sqrt{2\\pi}\\sigma}-\\frac{1}{\\sigma^2}\\cdot\\frac{1}{2}\\sum_{i=1}^{m}(y^{(i)} - \\theta^T x^{(i)})^2 \\end{align} $$\nHence, maximizing $\\ell$ is the same as minimizing $\\frac{1}{2}\\sum_{i=1}^m(y^{(i)}-\\theta^Tx^{(i)})^2=J(\\theta)$.\nNote that our final choice of $\\theta$ did not depend on $\\sigma^2$.\nLocally weighted linear regression In contrast to the original linear regression algorithm, the locally weighted regression gives every $\\epsilon^{(i)}$ a weight $w^{(i)}$, thus we can “ignore” some bad training examples.\nA fair standard choice for the weights is:\n$$ w^{(i)}=\\exp\\left(-\\dfrac{(x^{(i)} - x)^2}{2\\tau^2}\\right) $$\nAs a non-parametric algorithm, to make predictions using locally weighted linear regressions, we need to keep the entire training set around for $h$ to grow linearly with the size of the training set.\n","description":"Part I Linear Regression","tags":["Machine Learning"],"title":"CS229 Linear Regression","uri":"/posts/cs229-linear-regression/"},{"categories":["Study Notes","CNATDA"],"content":" Note\n「Computer Networking: A Top Down Approach」(8th Edition)\n因为老师讲的太快没办法细读书上的内容，也很难有时间认真思考写一下一篇有深度的 （CNATDA 好像介绍的深度也不是很大） 学习笔记，所以这篇笔记很大程度上 抄袭 借鉴了 ouuan dalao 的笔记。\nPrinciples of Network Applications 现代主要使用的 application architecture 有两种：client-server 和 peer-to-peer (P2P) .\nprocess 可以认为是一个在 end system 上运行的 program ，不同 end system 上的 process 通过在网络上交换 messages (application layer packets) 进行通信。\nprocess 与 transport layer 之间的 API 是 socket 。\nhost 使用 IP address 识别，process (socket) 之间通过 IP + port number 识别。\ntransport layer 中最主要的两个 protocol 是 TCP 和 UDP 。TCP 提供 connection-oriented service (通过 handshaking 建立 connection) 、reliable data transfer (data sent without error and in order) 、congestion-control (控制 sending rate 来减少 network layer 的拥塞以减少丢包重传) ，而 UDP 则是 connectionless (no handshaking) 、unreliable (不保证 message 送到和是否有序) ，并且 sending rate 是很随意的，也可以说 UDP 提供的是「best effort」service 。\napplication layer 在选择 transport layer protocol 的时候需要根据自身是否 loss-tolerant 、time-sensitive 来考虑。\napplication-layer protocol 决定了 process 之间交换的 messages 的 type, syntax, semantics, rules 。需要注意的是，application-layer protocols 只是 network application 中的一个部分。\nThe Web and HTTP HTTP (Hyper Text Transfer Protocol) 是 Web 的 application-layer protocol 。\nHTTP 不维护 client 的信息，是一个 stateless protocol 。\nHTTP/1.0 、HTTP/1.1 、HTTP/2 使用的都是 TCP ，而 HTTP/3 使用的是 UDP 。\n由于 TCP 是 connection-oriented ，所以需要考虑每一对 req/res 需要建立在不同还是相同的 connection 上，从而分为了 non-persistent connection 和 persistent connection 两种。\nnon-persistent: 每一次 req/res 都会建立一个新的 TCP connection ，结束之后都会关闭 connection 。需要的时间是 RTT * 2 (handshaking + req/res) + 文件传输用时。 persistent: 同一对 client-server 之间的所有 req/res 共用一个 TCP connection ，并且 client 在收到 response 之前可以一次性发送多个 request (pipelining) ，省下了多次建立 TCP connection 的时间。 HTTP/1.0 使用的是 non-persistent connection ，HTTP/1.1 和 HTTP/2 使用的是 persistent connection 。\nHTTP message 是 ASCII text 。\nHTTP request:\n1 2 3 4 5 GET /somedir/page.html HTTP/1.1 Host: www.someschool.edu Connection: close User-agent: Mozilla/5.0 Accept-language: fr HTTP response:\n1 2 3 4 5 6 7 8 HTTP/1.1 200 OK Connection: close Date: Tue, 18 Aug 2015 15:44:04 GMT Server: Apache/2.2.3 (CentOS) Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT Content-Length: 6821 Content-Type: text/html (data data data data data ...) server 可以通过 cookies 来识别用户，通过在 response 的 header lines 中加入 Set-cookie 来发送用户的 cookies，之后 client 每次发送 request 则在 header lines 中加入 cookie: 1678 。\nISP 可以设置 Web Cache ，用户先向 Web Cache 发送 request ，如果 cache hit 则直接发送 response ，否则就由 web cache 先向 origin server 发送 request 然后再向用户发送 response 。Web Cache 的存在可以减少延迟，降低带宽压力。\nclient 通过在 header 中加入 If-Modified-Since:\u003cdate\u003e 进行 conditional GET ，如果 server 检查对应的文件在 \u003cdate\u003e 之前没有更改过，就发送 body 为空的 304 Not Modified 。\nHTTP/2 使用了 request and response multiplexing、prioritization、server push 来提高 server 端发送的灵活性。\nmultiplexing: 使用 persistent connection 虽然减小了 RTT 的次数，但是带来了 Head of Line (HOL) blocking (较小的文件需要花费大量时间等待较大文件传输完成才能传输) 。HTTP/1.1 尽管使用 persistent connection ，但是还是建立了多个 TCP connection 来避免 HOL ，而 HTTP/2 则是将文件分成较小的 frames ，交替发送不同文件的 frame (interleaving) 从而减少了小文件的等待时间。 prioritization: client 发送多次 request 时，可以为不同的 response 设置优先级，server 通过优先级调整 response 的发送顺序，另外，client 还可以设置 response 之间的依赖关系。 push: server 可以对一个 request 发送多个 response ，将当前页面引用的但是 unrequested 的其他资源也 push 过去。 HTTP/3 使用基于 UDP 的 QUIC protocol 替代了 TCP 。\nElectronic Mail in the Internet mail system 主要由 user agent、mail servers 和 SMTP 组成。\n当 Alice 发送 email 给 Bob 时，会将写好的邮件通过她的 user agent 传递给她的 mail server ，再由 mail server 发送给 Bob 的 mail server ，Bob 通过他的 user agent 从 mail server 中取出邮件进行阅读。\n发送端的 mail server 会维护一个 message queue ，如果要发送的 mail server 在当时不可用，则会隔一段时间重新发送，多次失败后则会退回邮件。\n发送端的 mail server 即为 SMTP client ，接收端的 mail server 则是 SMTP server 。\nSMTP 是一个上古协议，因此整个 message 都只能是 7bit-ASCII 格式，同时，它使用的也是 TCP 协议，默认端口是 25 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 S: 220 smtp.example.com ESMTP Postfix C: HELO relay.example.org S: 250 Hello relay.example.org, I am glad to meet you C: MAIL FROM:\u003cbob@example.org\u003e S: 250 Ok C: RCPT TO:\u003calice@example.com\u003e S: 250 Ok C: RCPT TO:\u003ctheboss@example.com\u003e S: 250 Ok C: DATA S: 354 End data with \u003cCR\u003e\u003cLF\u003e.\u003cCR\u003e\u003cLF\u003e C: From: \"Bob Example\" \u003cbob@example.org\u003e C: To: \"Alice Example\" \u003calice@example.com\u003e C: Cc: theboss@example.com C: Date: Tue, 15 Jan 2008 16:02:43 -0500 C: Subject: Test message C: C: Hello Alice. C: This is a test message with 5 header fields and 4 lines in the message body. C: Your friend, C: Bob C: . S: 250 Ok: queued as 12345 C: QUIT S: 221 Bye SMTP 在建立完 TCP connection (handshaking) 之后会先自我介绍一遍 (HELO) 再传输数据，他们之间的连接使用的是同一个 TCP connection 。\nemail 的传递是 user agent -\u003e mail server -\u003e mail server -\u003e user agent ，多一个 mail server 作为中间媒介是因为 user agent 经常不在线，一个 mail server 的存在可以提高在线率并实现失败重发。\nuser agent 发送到 mail server 的过程可以使用 SMTP/HTTP ，mail server 到 mail server 使用 SMTP ，而从 mail server 拉取邮件到 user agent 使用的是 HTTP/IMAP ，不能使用 SMTP 是因为 SMTP 是一个 push protocol 。\nDNS——The Internet’s Directory Service host 可以由 hostname 和 IP 识别，其中 hostname 对人类更友好，而 IP 则对 routers 更友好。\nDNS (Domain Name System) 的主要任务就是将 hostname 翻译成 IP 。\nServices Provided by DNS DNS 是由不同层级的 DNS servers 共同构成的一个 distributed database ，也是一个让 hosts 可以请求这个 distributed database 的 application-layer protocol 。\nDNS 使用 UDP 协议，默认端口为 53 .\nDNS 在提供 hostname 到 IP 的翻译之外，还提供了以下功能：\nhost aliasing: 一个 host 在拥有 canonical hostname 之外还能拥有多个 alias 。 mail server aliasing: 同一个 hostname 在作为 Web server 和 mail server 时可以分别指向不同的 host 。 load distribution: 同一个 hostname 可以指向多个 host ，返回查询结果的时候 rotate addresses 的顺序。 Overview of How DNS Works 单点式的 DNS 会面临以下问题：\na single point of failure traffic volume distant centralized database maintainance 因此，DNS 必须是分布式、多层级的。\nDNS 一般分为以下几层：\nroot DNS server: 分布在全球的 13 个 root servers 一共有超过 1000 个 copy ，用来查询 TLD server。 top-level domain (TLD) servers: 每个 TLD 都有自己的 TLD server ，用来查询 authoritative DNS servers。 authoritative DNS servers: 每个 subdomain 都有自己的 authoritative DNS server ，用来查询 hostname 到 IP 的映射。 除此之外，TLD servers 和 authoritative DNS servers 之间还可能有 intermediate DNS server (IXP) 。\n另外，ISP 一般都会有一个 local DNS server (default name server) ，作为 proxy 代替 host 向 DNS server 进行查询。\n在向 DNS server 查询时，分为 iterative query (分别向不同的 DNS server 查询) 和 recursive query (由当前查询的 DNS server 替你向其他 DNS server 查询) ，实际中，requesting host 到 local DNS server 的查询是 recursive 的，而 local DNS server 从 root DNS server 开始向下查询是 iterative 的。\n为了减少查询的数量，DNS 采用了 caching 的办法。每个查询的发起者都会将查询结果保存一段时间，直到 cache miss 才会发起查询。\nDNS Records and Messages DNS distributed database 的存储单元是 RR (resource record) 。\nRR 是一个四元组 (Name, Value, Type, TTL) ，TTL 表示 cache 多久过期，Name 和 Value 的含义由 Type 决定。常见的 Type 有以下几种：\nA: name = hostname, value = IP address, 代表一个 hostname 到 IP 地址的映射。 NS: name = domain, value = name server 的 hostname ，代表可以在这个 name server 进行这个 domain 的下一步查询。 CNAME: name = alias hostname, value = canonical hostname ，用来使用 host aliasing 。 MX: name = alias hostname, value = canonical hostname ，用来使用 mail server aliasing 。 hostname 对应的 authoritative DNS server 会包含对应的 A record ，而其他的 authoritative DNS servers 则会包含它的 NS record 。\n下面的例子来自 ouuan’s blog 。\ntype name value NS . a.root-servers.net. A a.root-servers.net. 198.41.0.4 NS moe. ns1.dns.nic.moe. A ns1.dns.nic.moe. 156.154.144.114 NS ouuan.moe. amos.ns.cloudflare.com. A amos.ns.cloudflare.com. 172.64.35.120 A ouuan.moe. 172.67.181.123 DNS 最早只能通过更改配置文件等方式静态更新，现在可以使用 DDNS 通过 DNS message 进行动态更新。\nDNS message 格式如下：\nidentification 表示这是 query 还是 reply ，由 client 设置。\nflags 包括：\nquery/reply: 表示这条 message 是 query 还是 reply 。 authoritative or not: 表示返回的结果是否是最终结果。 recursion desired: client 是否希望 server 进行 recursive query 。 recursion available: 表示 server 是否可以进行 recursive query 。 Peer-to-Peer File Distribution P2P 架构的优势在于它是 self-scalable 的。\n最流行的 P2P file distribution protocol 是 BitTorrent ，它以 chunk 为基本下载单位。在一个 peer 刚加入 torrent 时只能从其他 peer 下载 chunk，获取到一些 trunk 后就会上传给其他 peer 。\n每个 torrent 都会有一个 tracker ，peer 的加入和离开都会通知 tracker ，并且会在过程中定期告知 tracker 自己仍在活动，tracker 会给每个 peer 其他 peer 的 IP 地址与端口。\nVideo Streaming and Content Distribution Networks 上课的时候老师没讲，虽然我后来还是把这部分内容看完了，但是时间原因，学习笔记就先咕了，后面有空的时候再写。\nCDN 还是挺重要的为什么不讲？\n","description":"Principles of Network Applications","tags":["Computer Network","CNATDA"],"title":"CNATDA 第二章学习笔记","uri":"/posts/cnatda-ch2/"},{"categories":["CS"],"content":"Overview 在 Lab 0 中，我们使用 Linux 内置的 TCP 协议实现了一个简易的抓取网站信息的 socket ，即 webget 。之后，我们为 Internet 中的通信实现了一个可靠的 byte stream ，尽管 Internet 本身仅仅提供 「best-effort」 服务。\nGetting Started 首先检查是否已经备份好了 Lab 0 的代码，因为在合并 Lab 1 的文件时可能会发生冲突导致丢失。 然后 git fetch 获取最新的 lab 文件。 接着使用 git merge origin/check1-startercode 下载 Lab 1 的代码文件。 确保你的环境已经正确搭建好：cmake -S . -B build 编译源代码：cmake --build build 开始 Lab 1 的挑战！ Putting substrings in sequence 在这个 Lab 和下一个 Lab 中，我们将实现 TCP 的 receiver 模块。对于 TCP 的 sender 模块，它将应用的 byte stream 拆分成一个个较短的 segments（长度不大于 1460 bytes 的子串），然后传递给 Network 层。但是 Network 层可能将这些 segments 丢弃、重复传送、打乱顺序，因此在 receiver 模块中，我们需要实现一个 Reassembler ，将这些 segments 重新组装成最初的 byte stream 。\nWhat should the Reassembler store internally? Reassembler 需要解决 3 种问题：\n立即将要 push 的下一个 bytes 传送给 Writer 。 将在 available capability 以内但是暂时还没轮到它传送的 bytes 存储在 buffer 中。 超过 available capability 的 bytes 直接丢弃。 在实现 Reassembler 时的一个重要原则就是要限制内存的使用量。\nFAQs 详见 lab_faq\nDevelopment 最大的一个难点就是如何去除重复的子串，其余部分主要还是注意要求和细节如何模拟。\n首先，这些 substrings 既是有序的又会出现重复，很容易想到使用 set 来存储，但是 set 的插入是 $\\mathcal{O}(n\\log{n})$ 的，在 reassembler_win 这个样例中会超时。\n于是我们考虑使用 map 来存储，每次存入一个 substring 时都遍历一遍 map 将重复的部分去除，然后再把删减后的 string 插入 map 中即可。\n这里要注意一个细节，在遍历 map 的过程中，有一种容易忽略的情况就是当前遍历得到的 string 是要插入的 string 的 substring ，这时候需要将两头非重复部分的 substring 分别插入 map 。\nOutcome ByteStream throughput: 0.61 Gbit/s\nReassembler throughput: 5.43 Gbit/s\n不算快也不算慢吧……\nSource Code reassembler.hh：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Reassembler { private: std::map \u003c uint64_t, std::string \u003e buffer_ {}; uint64_t first_index_in_buffer { 0 }; uint64_t buffer_size_ { 0 }; bool has_last_substring { 0 }; uint64_t first_unassembled_index { 0 }; void insert_into_buffer( uint64_t first_index, std::string data, bool is_last_substring ); void insert_from_buffer( Writer\u0026 ouput ); }; reassembler.cc：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 #include \"reassembler.hh\" using namespace std; void Reassembler::insert( uint64_t first_index, string data, bool is_last_substring, Writer\u0026 output ) { // Your code here. (void)first_index; (void)data; (void)is_last_substring; (void)output; if (data.empty()) { if (is_last_substring) output.close(); return; } if (output.available_capacity() == 0) return; uint64_t last_index = first_index + data.size(); uint64_t first_unacceptable_index = first_unassembled_index + output.available_capacity(); if (first_index \u003e= first_unacceptable_index || last_index \u003c= first_unassembled_index) return; if (last_index \u003e first_unacceptable_index) { data = data.substr(0, first_unacceptable_index - first_index); is_last_substring = false; } if (first_index \u003c first_unassembled_index) { data = data.substr(first_unassembled_index - first_index); first_index = first_unassembled_index; } else if (first_index \u003e first_unassembled_index) { insert_into_buffer(first_index, data, is_last_substring); return; } first_unassembled_index += data.size(); output.push(move(data)); if (is_last_substring) { output.close(); return; } if (!buffer_.empty() \u0026\u0026 buffer_.begin()-\u003efirst \u003c= first_unassembled_index) insert_from_buffer(output); } void Reassembler::insert_into_buffer( uint64_t first_index, string data, bool is_last_substring ) { uint64_t l = first_index, r = first_index + data.size(); for (auto it = buffer_.begin(); it != buffer_.end() \u0026\u0026 l \u003c r; ) { if (it-\u003efirst \u003c= l) { l = max(l, it-\u003efirst + it-\u003esecond.size()); ++it; continue; } if (l == first_index \u0026\u0026 r \u003c= it-\u003efirst) { buffer_[l] = move(data); buffer_size_ += data.size(); if (is_last_substring) has_last_substring = 1; return; } uint64_t rr = min(r, it-\u003efirst); buffer_[l] = data.substr(l - first_index, rr - l); buffer_size_ += rr - l, l = rr; } if (l \u003c r) { buffer_size_ += r - l; buffer_[l] = data.substr(l - first_index); } if (is_last_substring) has_last_substring = 1; } void Reassembler::insert_from_buffer( Writer\u0026 output ) { for (auto it = buffer_.begin(); it != buffer_.end(); ) { if (it-\u003efirst \u003e first_unassembled_index) break; uint64_t l = it-\u003efirst, r = l + it-\u003esecond.size(); if (r \u003c= first_unassembled_index) { buffer_size_ -= it-\u003esecond.size(); } else { string data = move(it-\u003esecond); buffer_size_ -= data.size(); data = data.substr(first_unassembled_index - it-\u003efirst); first_unassembled_index += data.size(); output.push(move(data)); } it = buffer_.erase(it); } if (buffer_.empty() \u0026\u0026 has_last_substring) output.close(); } uint64_t Reassembler::bytes_pending() const { // Your code here. return buffer_size_; } Referrence CS144 2023 Lab Checkpoint 1: stitching substrings into a byte stream cs144网络课程0 热身 ","description":"stitching substrings into a byte stream","tags":["CS144","Computer Network"],"title":"CS144 Lab 1","uri":"/posts/cs144-lab1/"},{"categories":["ACG"],"content":" 「 私たちの\u003c音楽(叫び)\u003e、傷だらけでみすぼらしい。 」\n我们的 \u003c音乐(呐喊)\u003e ，伤痕累累而充满狼狈。\n「 迷ってもいい、迷いながらも前に進む。」\n迷茫也无所谓，迷茫也要前进。\n与「孤独摇滚」中轻松废萌的乐队少女日常不同，「BanG Dream! It's My GO!!!!!」则是以少女间的重重矛盾来推进剧情的。\n五位性格不同的「迷子」于迷途中相遇，她们之间激发出的化学反应经历了一波三折而最后又峰回路转，为什么说「My GO」是近年来最优秀的「少女乐队」番？我想，这正是因为它打破了「少女乐队番都是剧情平淡的废萌番」的桎梏罢。\n尽管全番是由一个又一个更大的矛盾组成的，但是，「My GO」描绘的一定还是一个充满着浪漫主义色彩的理想世界。\n「 一生傷つかないなんて ありえない 」\n一辈子不受伤，是不可能的\n少女们迷茫着对 「Crychic」 的牵挂，因为害怕而驻足不前，成为了「迷茫的孩子」，但是到了最后，她们找到了答案：不要永远执着于「迷」。\n出口究竟在哪什么的根本就无所谓吧，要是一直不敢前进才是真正的执迷不悟了啊，所以，比起一起在原地停留，不如大家一起成为「迷子」，带着迷惑与不解，拾起中二与热血，一起迷路好了，毕竟，「迷茫也无所谓，迷茫也要前进」。\n","description":"","tags":["Anime"],"title":"「BanG Dream! It’s MyGO!!!!!」: 迷茫也要前进","uri":"/posts/bang-dream-its-mygo/"},{"categories":["Algorithm"],"content":"最大公约数 GCD ，即 Greatest Common Divisor .\n一组整数的最大公约数就是指这组整数的最大的公共约数 .\n怎么全是废话\n那么要如何求解一组整数的 gcd 捏？\n我们先考虑两个数 $a,b$ 的情况 .\n令 $a=bq+r(q,r\\in\\mathbb{N})$ ，则 $a \\bmod b=r\\in[0,b)$ ，假设 $d=\\gcd(a,b)$ ，有 $d\\mid a,~d\\mid b$ ，因此 $d\\mid r$，于是我们发现 $\\gcd(b,r)=d=\\gcd(a,b)$ .\n综上，$\\gcd (a,b)=\\gcd(b,a\\bmod b)$ ，于是我们可以利用这个性质不断递归求解直到 $b=0$ ，这时候的 a 就是 gcd 了.\n1 2 3 int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } 当整数的数量大于 2 时，我们求解前两个数的 gcd 与后一个数的 gcd ，便得到前 3 个数的 gcd ，依次进行下去，最后得到的便是这 n 个数的 gcd .\n对了，这个算法就是欧几里得算法 .\n最小公倍数 LCM ，即 Least Common Multiple .\n一组整数的公倍数，是指同时是这组数中每一个数的倍数的数 . 0 是任意一组整数的公倍数 .\n一组整数的最小公倍数，是指所有正的公倍数里面，最小的一个数 .\n语言贫瘠，直接蒯 oi-wiki 上的了\n同样也是先考虑两个数 $a,b$ 的情况 .\n将 $a,b$ 写成素数的乘积的形式 .\n$$a=p_1^{k_{a_1}}p_2^{k_{a_2}}\\cdots p_n^{k_{a_{n}}}$$\n$$b=p_1^{k_{b_1}}p_2^{k_{b_2}}\\cdots p_n^{k_{b_{n}}}$$\n根据定义可知 ，\n$$\\operatorname{lcm}(a,b)=p_1^{\\min(k_{a_1},k_{b_1})}p_2^{\\min(k_{a_2},k_{b_2})}\\cdots p_n^{\\min(k_{a_n},k_{b_{n}})}$$\n$$\\gcd(a,b)=p_1^{\\max(k_{a_1},k_{b_1})}p_2^{\\max(k_{a_2},k_{b_2})}\\cdots p_n^{\\max(k_{a_n},k_{b_{n}})}$$\n而 $\\max(a,b)+\\min(a, b)=a+b$ ，因此 $\\gcd(a,b)\\times\\operatorname{lcm}(a,b)=a\\times b$ .\n所以 $\\operatorname{lcm}(a,b)=\\dfrac{a\\times b}{\\gcd(a,b)}$ .\n对于多于 2 的整数数目的情况，处理方法和 gcd 是一样的 .\n扩展欧几里得算法 扩展欧几里得算法（Extended Euclidean algorithm, EXGCD）常用来求解 $ax+by=\\gcd(a,b)$ 的一组可行解的情况 .\n我们设 $ax_1+by_1=\\gcd(a,b)$ ，$bx_2+(a\\bmod b)y_2=\\gcd(b,a\\bmod b)$ .\n下面我们来看看 $x_1,y_1$ 和 $x_2,y_2$ 之间的关系 .\n将 $a\\bmod b=a-\\lfloor\\frac{a}{b}\\rfloor\\times b$ 和 $\\gcd(a,b)=\\gcd(b,a\\bmod b)$ 带入第二个方程，得到\n$$bx_2+ay_2-\\lfloor\\frac{a}{b}\\rfloor\\times b\\times y_2=\\gcd(a,b)$$\n整理得到\n$$ay_2+b(x_2-\\lfloor\\frac{a}{b}\\rfloor y_2)=\\gcd(a, b)$$\n与第一个方程比对可以发现 $x_1=y_2,y_1=x_2-\\lfloor\\frac{a}{b}\\rfloor y_2$ .\n因此我们可以不断递归求解 $\\gcd(a,b)$ 直到 $b=0$ ，显然此时的 $x_n=1$ ，然后考虑 $x_{n-1},y_{n-1}$ 的情况，此时的 $b=\\gcd(a,b)$ ，而 $a\\not= 0$ ，所以 $x_{n-1}=y_n=0$ ，综上，我们得到边界情况 $x_n=1,y_n=0$ 同时求得了 $\\gcd(a,b)$ .\n最后我们在不断回溯时修改 $x,y$ 的值即可得到 $ax+by=\\gcd(a, b)$ 的一组可行解 .\n1 2 3 4 5 6 7 8 9 10 int exgcd(int a, int b, int \u0026x, int \u0026y) { if (!b) { x = 1, y = 0; return a; } int ret = exgcd(b, a % b, x, y); int tmp = x; x = y, y = tmp - a / b * y; return ret; } ","description":"旧文补档捏","tags":["Number Theory","Math","gcd","lcm"],"title":"gcd \u0026\u0026 lcm 复习笔记","uri":"/posts/gcdlcm/"},{"categories":["Study Notes","Assembly"],"content":"內中断 中断类型码为 1 byte 的数据，可以表示 256 种中断信息的来源，但是实际上装载好的远少于 256 种。\n在 8086CPU 中，中断向量表存放在 0000:0000~0000:03E8 单元中，一个表项占 2 word ，偏移地址 word 存在低地址，段地址 word 存在高地址中。\n中断过程如下：\n取得中断类型码 N pushf TF = 0, IF = 0 push CS push IP IP = (N * 4), CS = (N * 4 + 2) 在编写中断处理程序时，需在结尾使用 iret 指令返回，作用与 ret 相似。\nCPU 在执行完一条指令之后，如果检测到 TF = 1 ，就会产生类型码为 1 的单步中断，转去执行 1 号中断处理程序，从而为单步跟踪程序的执行提供了可能。\n但是为了避免出现 1 号中断程序的套娃现象，需要在每次进入中断程序之前需要将 TF 置为 0 。\n特殊情况：在执行完 ss 寄存器传送数据的指令后，即便发生中断，CPU 也不会响应。 -\u003e 我们应该将设置 ss 和 sp 的指令连续存放。\nLab 12 编写 0 号中断的处理程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 assume cs:code code segment start: mov ax, cs mov ds, ax mov si, offset do0 mov ax, 0 mov es, ax mov di, 200h mov cx, offset do0end - offset do0 cld rep movsb mov ax, 0 mov es, ax mov word ptr es:[0], 200h mov word ptr es:[2], 0 mov ax, 4200h int 21h do0: jmp short do0start db \"divide error!\" do0start: mov ax, cs mov ds, ax mov si, 202h mov ax, 0b800h mov es, ax mov di, 12*160+36*2 mov cx, 13 s: mov al, [si] mov es:[di], al inc si add di, 2 loop s mov ax, 4200h int 21h do0end: nop code ends end start Lab 13 显示用 0 结束的字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 assume cs:code data segment db \"welcome to masm!\", 0 data ends stack segment dw 8 dup (0) stack ends code segment start: mov ax, stack mov ss, ax mov sp, 16 mov ax, cs mov ds, ax mov si, offset showstr mov ax, 0 mov es, ax mov di, 200h mov cx, offset showstrend - offset showstr cld rep movsb mov ax, 0 mov es, ax mov word ptr es:[7ch*4], 200h mov word ptr es:[7ch*4+2], 0 mov dh, 10 mov dl, 10 mov cl, 2 mov ax, data mov ds, ax mov si, 0 int 7ch mov ax, 4c00h int 21h showstr: push ax push bx push cx push ds push es push di push si mov ax, 0b800h mov es, ax mov ah, 0 mov al, 160 mul dh mov dh, 0 add ax, dx mov di, ax mov al, cl mov cx, 0 s: mov cl, ds:[si] jcxz se mov es:[di], cl mov es:[di+1], al inc si add di, 2 loop s se: pop si pop di pop es pop ds pop cx pop bx pop ax iret showstrend: nop code ends end start 完成 loop 指令的功能 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 assume cs:code stack segment dw 8 dup (0) stack ends code segment start: mov ax, stack mov ss, ax mov sp, 16 call load call setIVT mov ax, 0b800h mov es, ax mov di, 160*12 mov bx, offset s - offset se mov cx, 80 s: mov byte ptr es:[di], '!' add di, 2 int 7ch se: nop mov ax, 4c00h int 21h setIVT: push ax push es mov ax, 0 mov es, ax mov word ptr es:[7ch*4], 200h mov word ptr es:[7ch*4+2], 0 pop es pop ax ret load: push ax push cx push ds push es push di push si mov ax, 0 mov es, ax mov di, 200h mov ax, cs mov ds, ax mov si, offset myloop mov cx, offset myloopend - offset myloop cld rep movsb pop si pop di pop es pop ds pop cx pop ax ret myloop: push bp mov bp, sp dec cx jcxz myloopret add [bp+2], bx myloopret: pop bp iret myloopend: nop code ends end start 显示四句英文诗 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 assume cs:code code segment s1: db 'Good,better,best,', '$' s2: db 'Never let it rest,', '$' s3: db 'Till good is better,', '$' s4: db 'And better,best.', '$' s: dw offset s1, offset s2, offset s3, offset s4 row:db 2, 4, 6, 8 start: mov ax, cs mov ds, ax mov bx, offset s mov si, offset row mov cx, 4 ok: mov bh, 0 mov dh, ds:[si] mov dl, 0 mov ah, 2 int 10h mov dx, ds:[bx] mov ah, 9 int 21h inc si add bx, 2 loop ok mov ax, 4200h int 21h code ends end start 端口 CPU 通过主线相连的芯片除了各种存储器之外，还有以下 3 种芯片：\n各种接口卡的芯片 主板上的接口芯片，用来访问外设 其他芯片，存储系统相关信息或进行相关输入输出 in 和 out 指令 CPU 使用地址线和控制线向端口发送指令，从而与芯片进行交互，间接访问芯片的存储单元。\n在 in 和 out 指令中，只能使用 ax 或 al 来存放端口读/写的数据，其中访问 8 位端口时用 al ，访问 16 位端口时用 ax 。\nshl 和 shr 指令 它们都是逻辑位移指令，都会将最后移出的一位写入 CF 中，如果移动位数大于 1 ，则需要将移动位数放在 cl 中。\nLab 14 访问 CMOS RAM\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 assume cs:code stack segment db 128 dup (0) stack ends code segment start: mov ax, stack mov ss, ax mov sp, 128 mov bx, 0b800h mov es, bx mov bx, 160*12+28*2 call show_ymd mov ah, ' ' call print_char call show_hms mov ax, 4c00h int 21h show_ymd: push ax push cx mov al, 9 call show_single mov ah, '/' call print_char mov al, 8 call show_single mov ah, '/' call print_char mov al, 7 call show_single pop cx pop ax ret show_hms: push ax push cx mov al, 4 call show_single mov ah, ':' call print_char mov al, 2 call show_single mov ah, ':' call print_char mov al, 0 call show_single pop cx pop ax ret ; al 存端口号 show_single: call get_char call print_char mov ah, al call print_char ret ; ah 存要打印的字符 ; es:[bx] 要打印的屏幕位置 print_char: mov byte ptr es:[bx], ah add bx, 2 ret ; al 存放单元 ; ah 存十位数 ASCII 码 ; al 存个位数 ASCII 码 get_char: push cx out 70h, al in al, 71h mov ah, al mov cl, 4 shr ah, cl and al, 00001111b add ah, 30h add al, 30h pop cx ret code ends end start 外中断 外中断信息来自 CPU 外部，外中断源一共有两种：\n可屏蔽中断 如果 IF = 0 ，则会禁止进入可屏蔽中断。 进入内中断时会将 IF 置为 0 。 如果在內中断过程中需要处理可屏蔽中断，则需要用指令将 IF 置为 1 。 sti : IF = 1 cli : IF = 0 不可屏蔽中断 中断类型码固定为 2 中断过程与內中断一致，除了最后是 (IP) = (8), (CS) = (0AH) Lab 15 安装新的 int9 中断例程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 assume cs:code stack segment db 128 dup (0) stack ends code segment start: mov ax, stack mov ss, ax mov sp, 128 push cs pop ds mov si, offset int9 mov ax, 0 mov es, ax mov di, 204h mov cx, offset int9end - offset int9 cld rep movsb push es:[9*4] pop es:[200h] push es:[9*4+2] pop es:[202h] cli mov word ptr es:[9*4], 204h mov word ptr es:[9*4+2], 0 sti mov ax, 4c00h int 21h int9: push ax push bx push cx push es in al, 60h pushf call dword ptr cs:[200h] cmp al, 1eh jne int9ret pushf in al, 60h pushf call dword ptr cs:[200h] cmp al, 1eh+80h jne int9ret mov ax, 0b800h mov es, ax mov bx, 0 mov cx, 2000 s: mov byte ptr es:[bx], 'A' add bx, 2 loop s int9ret: pop es pop cx pop bx pop ax iret int9end: nop code ends end start ","description":"Chapter.12 ~ Chapter.15","tags":["Assembly"],"title":"王爽「汇编语言」学习笔记（七）","uri":"/posts/asm7/"},{"categories":["Study Notes","CS:APP"],"content":"本章主要内容为整数、浮点数的存储与逻辑运算。\nInformation Storage 1 byte = 8 bits ，为 memory 的最小存储单元的大小。\nword size 是主要的 pointer data 的大小，也是 virtual address space 的最大 size 。\nC 语言中，应该使用 signed char 来得到一个 1 byte 的有符号值。\nByte Ordering 对于一个十六进制数 0x01234567 ，在计算机中有两种表示方法：Big endian 和 Little endian 。\nBig endian 相对来说更符合习惯，在存储单元中，低位 address 存储高位 byte ，即 01 23 45 67 这样依次存储。\nLittle endian 则是高位 address 存储高位 byte ，这样看来又显得比较符合习惯了，即 67 45 23 01 依次存储。\n因为我们将寄存器或存储单元中的 bytes 表达出来习惯将 address 小的写在前面，所以 Little endian 会让人感觉很奇怪，但是实际访问某个存储单元时，我们更多的是类似于栈一样从高位地址开始向低位地址依次访问，这样一来，Little endian 依次访问到的 bytes 实际上是从小到大的了。\n计算机使用哪种表示方式，既与 CPU 有关又与 OS 有关。\nstring 的表示与 byte ordering 无关。\nShift Operations in C 左移都是往低位补 0 ，右移则分为 logical 和 arithmetic ，logical 是高位补 0 ，arithmetic 是根据最高位决定补 0 还是 1 。\n对于 signed data ，一般使用 arithmetic 。\n对于 unsigned data ，必须使用 logical 。\nInteger Representations unsigned integer 的表示就是一般的二进制形式。\nsigned integer 则采用补码 (two's-complement encoding)，最高位为符号位，若 word size 为 $\\omega$ ，那么最高位表示为 $-2^{\\omega-1}\\cdot x_{\\omega-1}$ ，其余位的表示与 unsigned 相同。\nConvertions between Signed and Unsigned word size 相同时，bit 位的表示不变，仅仅改变二进制到十进制的转换方式。\n当判断表达式的类型是 signed 还是 unsigned 的时，一般出现了 unsigned 就是 unsigned ，并且会将 signed 隐式转换为 unsigned ，这种情况下很容易发生意想不到的错误，所以一般尽量不使用 unsigned integer 。\nExpanding the Bit Representation 对于 unsigned integer ，直接在高位补 0 。\n对于 signed integer ，则在高位补原来的最高位的 bit ，类似于 arithmetic right shift 。\n如果既要增加长度，又要类型转换，则会先增加长度再进行类型转换。\nTruncating Numbers 对于 unsigned integer ，直接把多余的高位去掉，假设只保留低 k 位 bits ，则相当于 $\\bmod{\\ 2^k}$ 。\n对于 signed integer ，先转换为 unsigned 再做 unsigned truncation ，之后再转换回 signed ，其实也相当于对 $2^k$ 取模。\nInteger Arithmetic Addition and Negation unsigned integer 的加法，直接丢弃溢出的那一位，相当于模 $2^{\\omega}$ 。\n判断 overflow ：看 s = x + y 是否有 s \u003c x 或 s \u003c y 。\nunsigned integer 的取反：\n$$ -x\\mapsto\\begin{cases} x, \u0026x=0 \\\\ 2^{\\omega}-x, \u0026x\u003e0 \\end{cases} $$\nsigned integer 的加法，过程同 unsigned ，overflow 有 positive overflow 和 negative overflow ，仍然相当于模 $2^{\\omega}$ 。\n判断 overflow ：设 s = x + y ，发生 positive overflow 当且仅当 x \u003e 0 \u0026\u0026 y \u003e 0 \u0026\u0026 s \u003c= 0 ，发生 negative overflow 当且仅当 x \u003c 0 \u0026\u0026 y \u003c 0 \u0026\u0026 s \u003e= 0 。\nsigned integer 的取反：当成 unsigned 来取反即可，有\n$$ -x\\mapsto\\begin{cases} TMin_{\\omega}, \u0026x=TMin_{\\omega} \\\\ -x, \u0026x\u003eTMin_{\\omega} \\end{cases} $$\nMultiplication 都是丢高位，相当于模 $2^{\\omega}$ 。\n如果某个乘数是常数，则会优化为移位运算、加法运算和减法运算的结合。\n优化的性能与这些指令的相对速度、机器本身有关。大部分编译器只会在只有少量位移、加法、减法的情况下采取这种优化。\nDividing by Powers of 2 都会优化为右移运算。\n其中 unsigned integer 是直接 logistcal right shift ，相当于向下取整了。\nsigned integer 则是 arithmetic right shift ，效果也是向下取整，如果希望向上取整（对于负数就是向零取整了），则需要先加上 bias 在右移，其中 bias 定义为 $2^k-1$ ，k 是要右移的位数。\nSummary unsigned integer 和 signed integer 在处理这些简单的运算的溢出时相当于于模 $2^{\\omega}$ ，补码的表示方式使得二者在 bit 表示层面进行运算的形式一致。\nFloating Point 浮点数的表示一直是个难题。\nIEEE floating point IEEE floating point 将一个浮点数表示为 $V=(-1)^{s}\\times M\\times 2^{E}$ 的形式。\nsign bit ，为符号位 $s$ $n$-bit fraction field ，为 $M$ ，下文记 fraction field 为 $f=f_{n-1}\\cdots f_1 f_0$ $k$-bit exponent field ，为 $E$ ，下文记 exponent field 为 unsigned number $e=e_{k-1}\\cdots e_1e_0$ 根据 $E$ 的不同，浮点数被分为三类：\nNormalized values: exponent field 不全为 0 也不全为 1 $M=1.f_{n-1}\\cdots f_1 f_0$ $E=e-Bias$ ，其中 $Bias=2^{k-1}-1$ Denormalized values: exponent field 全为 0 $M=0.f_{n-1}\\cdots f_1 f_0$ $E=1-Bias$ Special values: exponent field 全为 1 当 fraction field 全为 0 时： s = 0 ，$+\\infty$ s = 1 ，$-\\infty$ 当 fraction field 不全为 0 时，表示 NaN 其中，不同位数的浮点数的不同 field 有不同的长度：\n64 位 ( double ) : k = 11, n = 52 32 位 ( float ) : k = 8, n = 23 如果简单地使用二进制表示 $E$ 和 $M$ 会出现一些问题：\n$E$ 需要是负数才能表示接近 0 的数，占用了 $e$ 的一个位而导致能表示的最大数缩小一半 若 $M=0.f_{n-1}\\cdots f_1 f_0$ ，则不同的 $E$ 可能会得到同一个值，不方便进行浮点数之间的比较 而 IEEE 采用的表示方法，\n加入了 $Bias$ 解决了第一个问题 特殊情况下让 $M$ 的 leading bit 变为 1 使得两个浮点数本身的大小与其二进制编码看作 unsigned 后的大小一致 Example Numbers exponent field 和 fraction field 全为 0 ，表示 $\\pm0.0$ 。\nexponent field 全为 0 而 fraction field 最低位为 1 其他位为 0 ，是能表示的最接近 0 的数，为 $2^{2-2^k-n}$ 。\nexponent field 最高位为 0 其他位全为 1 ，fraction field 全为 0 ，表示 $\\pm1.0$ 。\nexponent field 最低位为 0 其他位全为 1 ，fraction field 全为 1 ，是能表示的最大的数。\nRounding round-to-even ：「四舍六入五成双」的二进制形式 rounf-toward-zero round-down round-up Floating-Point Operations 除了一部分特殊值，浮点数的运算定义为先进行精确的运算之后再进行舍入。\n浮点数的加法、乘法会发生溢出、舍入，因此不符合结合律、分配律，但是满足交换律。\n","description":"Representing and Manipulating Information","tags":["CS:APP","OS"],"title":"CS:APP 第二章学习笔记","uri":"/posts/csapp2/"},{"categories":["CS"],"content":"Set up GNU/Linux on your computer 照着 check0 上说的做就好了。\n一开始用的是 Mac 装 UTM ，使用官方镜像，再设共享文件夹，好不容易搞定这一步之后 cmake 啥的各种报错，遂放弃。\n只好掏出我的暗影精灵 8 ，安装 Virtual Box ，使用官方镜像，设置共享文件夹，注意这里共享文件夹每次开机之后要输入 sudo mount -t vboxsf CS144 \u003cYourSharedFolderPath\u003e 才能将你取名 CS144 的文件夹挂载到 \u003cYourSharedFolderPath\u003e ，好好好，这下环境终于没问题了。\nNetworking by hand 照着做，除了华科的 Email 每次都给我关闭 connection 同时不让你用 smtp 发送邮件。\nListening and connecting 还是照着做。\nWriting a network program using an OS stream socket Let's get started——fetching and building the starter code 第一步使用官方镜像就不会有问题。\nModern C++: mostly safe but still fast and low-level C++ 不会捏，只会基础 C with STL 呜呜\nReading the Minnow support code 看看头文件里定义了哪些函数，各自有什么功能和 API 即可。\nWriting webget 网上查查 socket 编程大概是个什么流程，再根据 check0 文档和头文件的内容写就好了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void get_URL( const string\u0026 host, const string\u0026 path ) { TCPSocket socket {}; socket.connect( Address(host, \"http\") ); string message = \"GET \" + path + \" HTTP/1.1\\r\\n\"; message += \"Host: \" + host + \"\\r\\n\"; message += \"Connection: close\\r\\n\\r\\n\"; socket.write(message); string rec_message; while (!socket.eof()) { socket.read(rec_message); cout \u003c\u003c rec_message; } socket.close(); cerr \u003c\u003c \"Function called: get_URL(\" \u003c\u003c host \u003c\u003c \", \" \u003c\u003c path \u003c\u003c \")\\n\"; cerr \u003c\u003c \"Warning: get_URL() has not been implemented yet.\\n\"; } An in-memory reliable byte stream 这一步一开始看到差点没把我愁坏了……一度考虑是否需要先去补补 C++ 的语言基础，直到我看到了 CS144 Lab0 笔记：环境配置和热身 ，感觉好像还好？\n于是先写了个两个 deque ，一个是 string 另一个是 string_view ，结果倒在了 Test 8 ，也不知道到底错哪了，而且确实不会 string_view ，于是去掉了 string_view ，之后貌似 Test 4 又寄了？\n看了一下，好像是爆栈了还是 string 存不下了来着（忘了 qwq），只好又去掉了 deque 使用纯 string ，终于才过掉了。\nbyte_stream.hh :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class ByteStream { protected: uint64_t capacity_; // Please add any additional state to the ByteStream here, and not to the Writer and Reader interfaces. std::string buffer {}; uint64_t buffered_bytes = 0; uint64_t pushed_bytes = 0; uint64_t poped_bytes = 0; bool _is_closed = 0; bool _has_error = 0; public: explicit ByteStream( uint64_t capacity ); // Helper functions (provided) to access the ByteStream's Reader and Writer interfaces Reader\u0026 reader(); const Reader\u0026 reader() const; Writer\u0026 writer(); const Writer\u0026 writer() const; }; byte_stream.cc :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 void Writer::push( string data ) { // Your code here. (void)data; uint64_t data_length = data.length(); if (is_closed() || data.empty()) return; if (available_capacity() \u003c data_length) { data_length = available_capacity(); } buffered_bytes += data_length; pushed_bytes += data_length; buffer += data.substr(0, data_length); } void Writer::close() { // Your code here. _is_closed = 1; } void Writer::set_error() { // Your code here. _has_error = 1; } bool Writer::is_closed() const { // Your code here. return _is_closed; } uint64_t Writer::available_capacity() const { // Your code here. return capacity_ - buffered_bytes; } uint64_t Writer::bytes_pushed() const { // Your code here. return pushed_bytes; } string_view Reader::peek() const { // Your code here. return buffer; } bool Reader::is_finished() const { // Your code here. return _is_closed \u0026\u0026 buffered_bytes == 0; } bool Reader::has_error() const { // Your code here. return _has_error; } void Reader::pop( uint64_t len ) { // Your code here. (void)len; if (len == 0) return; len = min(len, buffer.length()); buffer.erase(0, len); buffered_bytes -= len; poped_bytes += len; } uint64_t Reader::bytes_buffered() const { // Your code here. return buffered_bytes; } uint64_t Reader::bytes_popped() const { // Your code here. return poped_bytes; } References CS144 writeup - 计算机网络 Lab0 CS144 2023 完全指南 CS144 Lab0 笔记：环境配置和热身 ","description":"C++ 不会捏😭","tags":["CS144","Computer Network"],"title":"CS144 Lab 0","uri":"/posts/cs144-0/"},{"categories":["Study Notes","Assembly"],"content":"call 和 ret 指令 ret 和 retf ret 实现近转移 pop IP retf 实现远转移 pop IP pop CS call 指令 不能实现短转移 转移的目的地址在指令中的 call 指令 call far ptr 实现段间转移 push CS push IP 转移地址在内存中的 call 指令 call word ptr 内存单元地址 push IP jmp word ptr 内存单元地址 call dword ptr 内存单元地址 push CS push IP mul 指令 乘数 都是 8 位 AL 8 位寄存器或内存字节单元 都是 16 位 AX 16 位寄存器或内存字单元 结果 8 位：AX 16 位：高位 DX ，低位 AX Lab 10 显示字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 assume cs:code data segment db 'Welcome to masm!', 0 data ends code segment start: mov dh, 8 mov dl, 3 mov cl, 2 mov ax, data mov ds, ax mov si, 0 call show_str mov ax, 4c00h int 21h show_str: ; 使用 es:[bp] 载入显存 mov ax, 0b800h mov es, ax mov al, 160 mul dh mov dh, 0 add ax, dx add ax, dx mov bp, ax copy: ; 将字符串复制入显存 mov al, cl mov ch, 0 mov cl, ds:[si] jcxz finish mov es:[bp], cl mov cl, al mov es:[bp+1], cl add bp, 2 inc si jmp short copy finish: ; 结束 ret code ends end start 解决除法溢出的问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 assume cs:code stack segment dw 6 dup (0) stack ends code segment start: mov ax, stack mov ss, ax mov sp, 12 mov ax, 4240H mov dx, 00FH mov cx, 0AH call divdw mov ax, 4c00h int 21h divdw: mov bx, ax mov ax, dx mov dx, 0 div cx push ax mov ax, bx div cx mov cx, dx pop dx ret code ends end start 数值显示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 assume cs:code data segment db 'Welcome to masm!', 0 data ends code segment start: mov dh, 8 mov dl, 3 mov cl, 2 mov ax, data mov ds, ax mov si, 0 call show_str mov ax, 4c00h int 21h show_str: ; 使用 es:[bp] 载入显存 mov ax, 0b800h mov es, ax mov al, 160 mul dh mov dh, 0 add ax, dx add ax, dx mov bp, ax copy: ; 将字符串复制入显存 mov al, cl mov ch, 0 mov cl, ds:[si] jcxz finish mov es:[bp], cl mov cl, al mov es:[bp+1], cl add bp, 2 inc si jmp short copy finish: ; 结束 ret code ends end start 标志寄存器 标志寄存器有 16 位，其中存储的信息被称为程序状态字 (PSW)\n影响标志寄存器的大都是运算指令，不影响的大都是传送指令\ninc 和 loop 指令不影响 CF 位\nZF：零标志位 PF：奇偶标志位 SF：符号标志位，即记录结果最高有效位是否为 1 CF：进位标志位，针对无符号数运算，记录结果的最高有效位向更高位的进位或借位情况 OF：溢出标志位，针对有符号数运算 cmp 指令 对于无符号数运算 cmp ax, bx :\nZF = 1，则 (ax) = (bx) ZF = 0，则 (ax) != (bx) CF = 1，则 (ax) \u003c (bx) CF = 0，则 (ax) \u003e= (bx) CF = 0 且 ZF = 0，则 (ax) \u003e (bx) CF = 1 或 ZF = 1，则 (ax) \u003c= (bx) 对于有符号数运算 cmp ah, bh :\nSF = 1 且 OF = 0，则 (ah) \u003c (bh) SF = 1 且 OF = 1，则 (ah) \u003e (bh) SF = 0 且 OF = 0，则 (ah) \u003c (bh) SF = 0 且 OF = 1，则 (ah) \u003e= (bh) 检测比较结果的条件转移指令 它们所检测的标志位都是 cmp 指令进行无符号数比较时的\nDF 标志和串传送指令 DF：方向标志位，在串处理指令中，控制每次操作后 si, di 的增减 DF = 0, 递增 DF = 1, 递减 cld：令 DF = 0 std：令 DF = 1 movsb 相当于 (es:[di]) = (ds:[si]) 之后根据 DF 改变 si, di movsw movsb 的字版本 si 和 di 改变量为 2 rep 根据 cx 的值重复执行后面的串传送指令 pushf 和 popf pushf：将标示寄存器的值压栈 popf：从栈中弹出数据送入标志寄存器 Lab 11 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 assume cs:codesg datasg segment db \"Beginner's All-purpose Symbolic Instruction Code.\", 0 datasg ends codesg segment begin: mov ax, datasg mov ds, ax mov si, 0 call letterc mov ax, 4c00h int 21h letterc: mov cx, 0 mov cl, ds:[si] jcxz finish cmp cl, 97 jb next cmp cl, 122 ja next and cl, 11011111B mov ds:[si], cl next: inc si jmp short letterc finish: ret codesg ends end begin ","description":"Chapter.10 ~ Chapter.11","tags":["Assembly"],"title":"王爽「汇编语言」学习笔记（六）","uri":"/posts/asm6/"},{"categories":["ACG"],"content":" 「必须背负起某些事物，保护某些事物……非得要有这种冠冕堂皇的理由，我们才能飞向天际吗？」\n「这个世界为找不到归宿的他所准备的东西，尽是陌生不搭调的衣服与面具。即使如此还是得站在舞台上表演吗？还是得藉此找到喜悦与意义吗？」\n「如果人生拥有意义与价值，那么就不能让憧憬只以憧憬收场。」\n「卡尔，你啊，首先得基于自己的意志完成一些事情。必须藉此亲自确认自己究竟是什么样的人——完成这些过程之后，你才能首度面对自己过去的行为，才能由自己决定要怎么制裁自己，赦免自己。」\n「说不定直到今天这一天为止，自己从来没有基于真正的意义飞上天空。 那就挑战吧。这次的我，一定要飞向真正的天空。 这次不是为了憎恨与恐怖，要为了荣耀与喜悦而飞翔。」\n每次在读前中期部分时都会觉得平淡无奇甚至让人感觉有些无聊，但是第一卷后面卡尔对于自己纯粹的飞翔理想、对于天空向往、对天空霸主——帝凰龙的敬畏与挑战，与现实中不得不踏上战场成为一具无情的杀人机器的抵触、无奈与妥协，还有第二卷后期卡尔为了自私的心愿「再次与雷鸟号驰骋天空」而情愿装上武器与敌军殊死抵抗，最后帝凰龙在卡尔决心冲向敌舰走上所谓更好的末路时现身，邀请卡尔一同「直指北方的尽头」，而卡尔自然不会放过这个好机会，驾驶着雷鸟号，超越了音速，消失在了地球的北极，这些部分在读的时候总是令我感触颇深，但一旦想要记录些什么想法时，却又无从下手，写这种感情色彩浓厚的文章总是我的软肋。\n但是对于曾经感动过我的瞬间，总还是要记录点什么的。\n放几句有点中二的摘录，想到了什么能写再写吧。\n「我们人类应该以此为契机，重新思考彼此在相同的天空之下，共享相同大地生活的真正意义」\n「这份心情就已经是答案，用不着进一步思考，无论是多么遥远黑暗的地方，只要你想去，那就去吧。」\n「必将无尽远征，无远弗届」\n","description":"虚渊玄对于爱与希望的向往","tags":["Light Novel"],"title":"「钢铁之翼」: 天空、战争与巨龙","uri":"/posts/%E9%92%A2%E9%93%81%E4%B9%8B%E7%BF%BC/"},{"categories":["Study Notes","Assembly"],"content":"数据处理的两个基本问题 bx、si、di、bp 只有这 4 个寄存器可以在 [...] 中进行内存单元的寻址 它们只能单个出现或者以 bx 和 si、bx 和 di、bp 和 si、bp 和 di 的组合出现 bp 的段地址默认在 ss 中 机器指令处理的数据所在位置 指令在执行前，所要处理的数据可以在：CPU 内部、内存、端口 汇编语言中数据位置的表达 立即数（idata）：执行前在 CPU 指令缓冲器中 SA 和 EA：指令要处理的数据在内存中 寻址方式 记一下名字即可\n指令要处理的数据有多长？ push 指令只进行字操作\n寻址方式的综合应用 用 bx 定位整个结构体，用 idata 定位结构体中的某一个数据项，用 si 定位数组项中的每个元素\ndiv 指令 除数：8 位和 16 位两种 被除数：位数是除数的两倍，存放在 ax 、dx 寄存器 dx 存放高 16 位，ax 存放低 16 位 结果 除数为 8 位：al 存商，ah 存余数 除数为 16 位：ax 存商，dx 存余数 伪指令 dd dd：dword (double word)\ndup 使用格式：db 重复次数 dup (重复的字节型数据)\nLab 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 assume cs:code data segment db '1975','1976','1977','1978','1979','1980','1981','1982','1983' db '1984','1985','1986','1987','1988','1989','1990','1991','1992' db '1993','1994','1995' ;以上是表示21年的21个字符串 dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514 dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000 ;以上是表示21年公司总收入的21个dword型数据 dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226 dw 11542,14430,15257,17800 ;以上是表示21年公司雇员人数的21个word型数据 data ends table segment db 21 dup('year summ ne ?? ') table ends code segment start:\tmov ax, table mov ds, ax mov ax, data mov es, ax mov bx, 0 mov di, 0 mov cx, 21 s0:\tmov si, 0 push di mov ax, di add di, ax mov ax, es:[di+0] mov [bx].0[si], ax add si, 2 add di, 2 mov ax, es:[di+0] mov [bx].0[si], ax pop di ; year mov si, 0 push di mov ax, di add di, ax mov ax, es:[di+84] mov [bx].5[si], ax add si, 2 add di, 2 mov ax, es:[di+84] mov [bx].5[si], ax pop di ; summ mov si, 0 mov ax, es:[di+168] mov [bx].10[si], ax ; ne add bx, 16 add di, 2 loop s0 mov ax, 4c00h int 21h code ends end start 转移指令的原理 依据位移进行转移的 jmp 指令 段内短转移：jmp short 标号 IP 修改范围：-128 ~ 127 (IP) = (IP) + 8 位位移 对应机器码中不包含转移的目的地址，包含的是下一条指令到标号地址到位移差 位移用补码表示 段内近转移：jmp near ptr 标号 IP 修改范围：-32768 ~ 32767 (IP) = (IP) + 16 位位移 转移到目的地址在指令中的 jmp 指令 段间转移：jmp far ptr 标号 转移地址在 16 位寄存器中的 jmp 指令 jmp 16位寄存器 转移地址在内存中的 jmp 指令 jmp word ptr 内存单元地址（段内转移） jmp dword ptr 内存单元地址（段间转移） jcxz 指令 jcxz 标号 若 cx = 0，(IP) = (IP) + 8 位位移 loop 指令 所有循环指令都是短指令\nLab 8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 assume cs:codesg codesg segment mov ax, 4c00h int 21h start: mov ax, 0 s: nop nop mov di, offset s mov si, offset s2 mov ax, cs:[si] mov cs:[di], ax s1: mov ax, 0 int 21h mov ax, 0 s2: jmp short s1 nop codesg ends end start 运行前：不能正确返回\n使用 debug 加载程序，一步步执行指令发现\n1 2 3 4 mov di, offset s mov si, offset s2 mov ax, cs:[si] mov cs:[di], ax 将 s 处的指令修改为了 s2 处的指令，即\n1 2 s: nop nop 变成了 jmp short s1 ，但是由于机器码记录的是位移差，因此执行 jmp short s 之后再次执行 s 处的 jmp short s1 会跳转到奇怪的指令处，从而不能正确返回\nLab 9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 assume cs:code ; 绿色 00000010B ; 绿底红色 00100100B ; 白底蓝色 01110001B ; starts from B87A0H code segment mov ax, 0B87AH mov ds, ax mov bx, 0 mov ah, 'w' mov al, 00000010B mov word ptr [bx], ax add bx, 2 mov ah, 'e' mov al, 00000010B mov word ptr [bx], ax add bx, 2 mov ah, 'l' mov al, 00000010B mov word ptr [bx], ax add bx, 2 mov ah, 'c' mov al, 00000010B mov word ptr [bx], ax add bx, 2 mov ah, 'o' mov al, 00000010B mov word ptr [bx], ax add bx, 2 mov ah, 'm' mov al, 00000010B mov word ptr [bx], ax add bx, 2 mov ah, 'e' mov al, 00000010B mov word ptr [bx], ax add bx, 2 mov ah, ' ' mov al, 00000010B mov word ptr [bx], ax add bx, 2 mov ah, 't' mov al, 00000010B mov word ptr [bx], ax add bx, 2 mov ah, 'o' mov al, 00000010B mov word ptr [bx], ax add bx, 2 mov ah, ' ' mov al, 00000010B mov word ptr [bx], ax add bx, 2 mov ah, 'm' mov al, 00000010B mov word ptr [bx], ax add bx, 2 mov ah, 'a' mov al, 00000010B mov word ptr [bx], ax add bx, 2 mov ah, 's' mov al, 00000010B mov word ptr [bx], ax add bx, 2 mov ah, 'm' mov al, 00000010B mov word ptr [bx], ax add bx, 2 mov ah, '!' mov al, 00000010B mov word ptr [bx], ax mov ax, 4c00h int 21h code ends end ","description":"Chapter.8 ~ Chapter.9","tags":["Assembly"],"title":"王爽「汇编语言」学习笔记（五）","uri":"/posts/asm5/"},{"categories":["Study Notes","CS:APP"],"content":"去年的时候看了一下 CS:APP 中文版的第一章 \u0026 第二章开了个头，当时啃的还是有点辛苦的，毕竟计算机基础知识还是太匮乏了（\n昨天看了一下英文原版的 CS:APP ，我超，观感还不错嘛 XD\n也许是我现在计算机基础已经扩充了很多，也许是中文版对各种专有名词的翻译让人感觉不明所以（我觉得这一点必然有（x\n总之阅读体验比去年要好了太多，为了 push 自己这次好好读读这本「计算机领域的神书」，所以开了个 CS:APP 学习笔记系列 (^o^)/\n第一章大约就是讲了讲一个 hello 程序从你在编辑器中敲下 hello.c 文件到最后它被计算机执行完毕的过程中究竟发生了些什么，对各种专有名词做了一个概括性的介绍，就不专门写一个笔记了（其实就是懒\n","description":"这次一定认真读 XD","tags":["CS:APP","OS"],"title":"CS:APP 学习笔记 序","uri":"/posts/csapp%E5%BA%8F/"},{"categories":["Study Notes","Assembly"],"content":"可执行文件 可执行文件 = 描述信息 + 程序\n程序：源程序中的汇编指令和定义的数据\n描述信息：主要是 masm.exe、link.exe 对源程序中相关伪指令进行处理所得到的信息\nend start 指明程序入口，被转化为一个入口地址，存储在可执行文件的描述信息中\n段容量 一个段段容量不能大于 64KB ，这是受 8086CPU 的限制\nLab 5: 编写、调试具有多个段的程序 任务一 0123H, 0456H, 0789H, 0abch, 0defh, 0fedh, 0cbah, 0987H cs = 076C, ss = 076B, ds = 076A data: X - 2, stack: X - 1 任务二 0123H, 0456H cs = 076C, ss = 076B, ds = 076A data: X - 2, stack: X - 1 16 的倍数个字节且大于等于 N 任务三 0123H, 0456H cs = 076A, ss = 076E, ds = 0766D data: X + 3, stack: X + 4 任务四 第 3 题，因为没有入口地址的话 IP 默认为 0 ，前两题从 0 到后面一段的内容都是数据内容而不是正确的指令内容，无法被正常执行\n任务五 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 assume cs:code a segment db 1, 2, 3, 4, 5, 6, 7, 8 a ends b segment db 1, 2, 3, 4, 5, 6, 7, 8 b ends c segment db 0, 0, 0, 0, 0, 0, 0, 0 c ends code segment start:\tmov ax, a mov ds, ax mov bx, 0 mov cx, 8 s:\tmov al, ds:[bx] add al, ds:[bx+16] mov ds:[bx+32], al inc bx loop s mov ax, 4c00h int 21h code ends end start 任务六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 assume cs:code a segment dw 1, 2, 3, 4, 5, 6, 7, 8 a ends b segment dw 0, 0, 0, 0, 0, 0, 0, 0 b ends code segment start:\tmov ax, a mov ss, ax mov sp, 32 mov bx, 0 mov cx, 8 s:\tpush ss:[bx] add bx, 2 loop s mov ax, 4c00h int 21h code ends end start Lab 6: 实践课程中的程序 任务一 略\n任务二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 assume cs:codesg, ss:stacksg, ds:datasg stacksg segment dw 0, 0, 0, 0, 0, 0, 0, 0 stacksg ends datasg segment db '1. display ' db '2. brows ' db '3. replace ' db '4. modify ' datasg ends codesg segment start:\tmov ax, stacksg mov ss, ax mov sp, 16 mov ax, datasg mov ds, ax mov bx, 0 mov cx, 4 s0:\tpush cx mov si, 0 mov cx, 4 s:\tmov al, [bx+si+3] and al, 11011111b mov [bx+si+3], al inc si loop s pop cx add bx, 16 loop s0 mov ax, 4c00H int 21H codesg ends end start ","description":"Chapter.6 ~ Chapter.7","tags":["Assembly"],"title":"王爽「汇编语言」学习笔记（四）","uri":"/posts/asm4/"},{"categories":["Study Notes","Assembly"],"content":"伪指令 end ：标记整个程序的结束\nassume : 将有特定用途的段和相关的段寄存器关联起来\n编译、连接 masm filename; : 简易编译指令，生成 .obj 文件\nlink filename; : 简易连接指令，生成 .exe 可执行文件\nexe 文件中程序的加载过程 Lab 4: [bx] 和 loop 的使用 任务一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 assume cs:code code segment mov ax, 0H mov ds, ax mov bx, 200H mov cx, 64 s: mov ds:[bx], al inc bx inc ax loop s mov ax, 4c00H int 21H code ends end 任务二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 assume cs:code code segment mov ax, 0H mov ds, ax mov bx, 200H mov cx, 64 s: mov ds:[bx], bl inc bx loop s mov ax, 4c00H int 21H code ends end 任务三 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 assume cs:code code segment mov ax, cs mov ds, ax mov ax, 0020h mov es, ax mov bx, 0 mov cx, 10h s: mov al, [bx] mov es:[bx], al inc bx loop s mov ax, 4c00h int 21h code ends end ","description":"Chapter.4 ~ Chapter.5","tags":["Assembly"],"title":"王爽「汇编语言」学习笔记（三）","uri":"/posts/asm3/"},{"categories":["Algorithm"],"content":"KMP 算法主要用来解决给出一个文本串和一个模式串，要求模式串在文本串中出现的位置、次数等的问题，它的核心就是前缀函数。\n前缀函数 给定字符串 $s$ ，若 $s$ 的子串 $s[0\\sim i]$ 中存在某个真前缀与真后缀相等，记这个真前缀的长度为 $k$ ，定义前缀函数 $\\pi[i]$ 为子串 $s[0\\sim i]$ 的最大的这样的 $k$ 。\n朴素算法 一种暴力求前缀函数的方法就是枚举 $s[0\\sim i]$ 的真前缀，判断与对应相等长度的真后缀是否相等，复杂度为 $\\mathcal{O}(n^3)$ 。\n高效算法 假设当前求解 $\\pi[i]$ ，可以发现，$\\pi[i]$ 至多比 $\\pi[i-1]$ 大 $1$ ，因此我们只需枚举长度小于等于 $\\pi[i-1]+1$ 的真前缀，并且按照长度从大到小枚举，看起来复杂度还是 $\\mathcal{O}(n^3)$ 的，实际上已经降低到了 $\\mathcal{O}(n^2)$ 。\n进一步可以发现，如果 $s[i]\\not= s[\\pi[i-1]]$ ，那么下一个满足 $s[0\\sim k-1]$ 与 $s[i-k\\sim i-1]$ 相等的最大的 $k$ ，即仅比 $\\pi[i-1]$ 小的满足 $s[0\\sim i-1]$ 的真前缀与真后缀相等的值，它就等于 $\\pi[\\pi[i-1]-1]$ ，令 $j=\\pi[i-1]$ ，如果它大于 $\\pi[j-1]$ ，那么 $\\pi[i-1]$ 就不满足它的最大值的性质，如果它小于 $\\pi[j-1]$ ，这就不满足 $\\pi[j-1]$ 的定义。因此，我们下一次判断 $s[\\pi[j-1]]$ 是否与 $s[i]$ 相等，如果不相等，那就重复上述操作，令 $j=\\pi[j-1]$ 再继续判断直到 $j=0$ 或者匹配成功，时间复杂度 $\\mathcal{O}(n)$ 。\n复杂度证明 先证第一个优化的。如果一次就匹配成功的话，那么计算 $\\pi[i]$ 的复杂度就是 $\\mathcal{O}(1)$ ，如果失配了，那么最后得到的 $\\pi[i]\\le \\pi[i-1]$ ，我们枚举过的 $s[i]$ 的真前缀在之后都不会再被枚举到，也就是说，以 $s[\\pi[i]-1]\\sim s[\\pi[i-1]]$ 结尾的真前缀之后都不会再被枚举了，因此 $s$ 的任意一个真前缀最多被枚举一次，每次枚举比较的复杂度是 $\\mathcal{O}(n)$ ，所以总复杂度是 $\\mathcal{O}(n^2)$ 。\n再证加上第二个优化的。与前面的证明相同，如果一次匹配成功，则直接停止匹配，否则不断令 $j=\\pi[j-1]$ ，这样的 $j$ 是递减的，而且小于 $\\pi[i-1]$ ，所以每一个 $\\pi[i]$ 只会被枚举一次，而每一次的判断都是 $\\mathcal{O}(1)$ 的，所以总复杂度为 $\\mathcal{O}(n)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 vector \u003cint\u003e pre_func(string s) { int n = s.length(); vector \u003cint\u003e pi(n); for (int i = 1; i \u003c n; ++i) { int j = pi[i - 1]; while (j \u0026\u0026 s[i] != s[j]) j = pi[j - 1]; if (s[i] == s[j]) j++; pi[i] = j; } return pi; } 应用 前缀函数在字符串题中有很多种应用，这里要讲的的就是其中的 KMP 算法，其他的应用还包括求解字符串的周期、统计每个前缀的出现次数、一个字符串中本质不同子串的数目、字符串压缩、构建自动机等，这些应用的前缀函数的做法并不是很好想，他们也基本可以用字符串哈希解决，但是相应的，哈希的复杂度没有前缀函数的优秀。\nKMP 算法 给定文本串 $t$ 和模式串 $s$ ，要求 $s$ 在 $t$ 中出现的所有位置，我们可以构造一个新的字符串 $cur=s+’#’+t$ ，其中 $#$ 可以替换为任何在 $s,t$ 中没有出现过的字符，然后我们求出新串的前缀函数，从 $t$ 出现的第一个位置开始枚举，如果当前 $\\pi[i]=s.length$ ，就说明这里出现了一次 $t$ .\n代码 1 2 3 4 5 6 7 8 vector \u003cint\u003e KMP(string text, string pattern) { int n1 = text.length(), n2 = pattern.length(); string cur = pattern + '#' + text; vector \u003cint\u003e pi = pre_func(cur), ret; for (int i = n2 + 1; i \u003c n1 + n2 + 1; ++i) if (pi[i] == n2) ret.push_back(i + 1 - n2 * 2); return ret; } 例题 P3375 KMP字符串匹配 Luogu\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u003cbits/stdc++.h\u003e using namespace std; string s1, s2; vector \u003cint\u003e pre_func(string s) { int n = s.length(); vector \u003cint\u003e pi(n); for (int i = 1; i \u003c n; ++i) { int j = pi[i - 1]; while (j \u0026\u0026 s[i] != s[j]) j = pi[j - 1]; if (s[i] == s[j]) j++; pi[i] = j; } return pi; } vector \u003cint\u003e KMP(string text, string pattern) { int n1 = text.length(), n2 = pattern.length(); string cur = pattern + '#' + text; vector \u003cint\u003e pi = pre_func(cur), ret; for (int i = n2 + 1; i \u003c n1 + n2 + 1; ++i) if (pi[i] == n2) ret.push_back(i + 1 - n2 * 2); return ret; } int main() { ios :: sync_with_stdio(false); cin.tie(nullptr); cin \u003e\u003e s1 \u003e\u003e s2; vector \u003cint\u003e ans = KMP(s1, s2); for (int i = 0; i \u003c ans.size(); ++i) cout \u003c\u003c ans[i] \u003c\u003c \"\\n\"; ans.clear(); ans = pre_func(s2); for (int i = 0; i \u003c ans.size(); ++i) cout \u003c\u003c ans[i] \u003c\u003c \" \"; return 0; } P4391 Radio Transmission Luogu\n考虑将给出的字符串 $s$ 补全成为由 $s_2$ 自身连接成为的字符串 $s_1$ ，假设当前已经求出 $s_1$ 的前缀函数 $\\pi[i]$ ，不妨设 $s_1$ 的长度为 $n$ ，可以发现 $s_1[0\\sim\\pi[n-1]-1]$ 一定也是由 $s_2$ 连接组成的字符串，而剩下的 $s_1[\\pi[n-1]\\sim n-1]$ 只有两种情况，一种是它就等于 $s_2$ ，另一种可能是它的长度小于 $s_2$ ，由于 $s_1$ 一定是由 $s_2$ 组成的，所以这一种情况是不可能的，从而剩下的这部分就是 $s_2$ .\n接下来考虑 $s$ 开头和结尾需要补全的部分。因为 $s$ 是 $s_1$ 的子串，所以这部分一定是 $s_2$ 的子串，我们不妨将开头这一部分字符与其后它所缺失的部分结合形成一个新的 $s_2’$ ，相当于将 $s_2$ 从中间截断然后交换两头的顺序，这样一来 $s$ 就只有结尾部分不完整了。然后我们进一步可以发现，要求的只是 $s_2$ 的长度，直接求出 $\\pi[n-1]$ 再将 $n-\\pi[n-1]$ 作为答案是正确的，这种情况下仔细想想可以发现剩下的 $s[\\pi[n-1]\\sim n-1]$ 其实也只是 $s_2’$ 从中间截断 然后交换两头的顺序的变体而已。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u003cbits/stdc++.h\u003e using namespace std; vector \u003cint\u003e pre_func(string s) { int n = s.length(); vector \u003cint\u003e pi(n); for (int i = 1; i \u003c n; ++i) { int j = pi[i - 1]; while (j \u0026\u0026 s[j] != s[i]) j = pi[j - 1]; if (s[j] == s[i]) j++; pi[i] = j; } return pi; } int main() { int n; string s; cin \u003e\u003e n \u003e\u003e s; vector \u003cint\u003e nxt = pre_func(s); cout \u003c\u003c n - nxt[n - 1]; return 0; } P3435 OKR-Periods of Words Luogu\n相当于求最小的前缀和后缀相等的前缀长度 $len$ ，然后对应的周期长度就是 $i+1-len$ （字符串第一位为 0 ），只需考虑 $len$ 该怎么求。\n假设当前已经求出 $a[0\\sim i-1]$ 的答案，其中以 $a[j]$ 为结尾的前缀的答案为 $ans[j]$ ，那么如果 $a[i]\\not=a[0]$ 的话，必然有 $ans[i]\u003eans[i-1]$ ，容易想到一种暴力：先比较 $s[ans[i-1]]$ 和 $s[i]$ ，相等就令 $ans[i]=ans[i-1]+1$ ，否则就暴力跳 $next[i]$ ，找最小的非0 的那个作为 $ans[i]$ 。但是可以发现，和 $ans[i]\u003eans[i-1]$ 类似的，将每次跳的 $next$ 值记为 $j$ ，那么一定有 $j\u003ci$ ，于是 $ans[i]\\ge ans[j]$ ，所以我们只需要跳一次 $next$ ，然后将它的答案作为 $ans[i]$ 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u003cbits/stdc++.h\u003e using i64 = long long; const int N = 1e6 + 5; int n; i64 sum; std :: string a; std :: vector \u003cint\u003e next(N), ans(N); std :: vector \u003cint\u003e pre_func(std :: string s) { std :: vector \u003cint\u003e pi(n); for (int i = 1; i \u003c n; ++i) { int j = pi[i - 1]; while (j \u0026\u0026 s[j] != s[i]) j = pi[j - 1]; if (s[j] == s[i]) j++; pi[i] = j; } return pi; } void Calc(std :: string s) { for (int i = 1; i \u003c n; ++i) { int j = next[i] - 1; if (j \u003c 0) continue; ans[i] = ans[j]; if (!ans[i]) ans[i] = next[i]; sum += i + 1 - ans[i]; } } int main() { std :: ios :: sync_with_stdio(false); std :: cin.tie(nullptr); std :: cin \u003e\u003e n \u003e\u003e a; next = pre_func(a); Calc(a); std :: cout \u003c\u003c sum; return 0; } P4828 Censoring S Luogu 可以在 KMP 求 next[] 的时候用一个栈来储存，一旦发现当前位置出现了字符串 $t$ 就从栈中弹出，然后记得每次 next[] 初始化要令 j = next[stk[top]] 就好了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u003cbits/stdc++.h\u003e const int N = 1e6 + 5; int top; int stk[N \u003c\u003c 1]; void Solve(std :: string s, int n) { int m = s.length(); std :: vector \u003cint\u003e next(m); for (int i = 1; i \u003c n; ++i) { int j = next[i - 1]; while (j \u0026\u0026 s[i] != s[j]) j = next[j - 1]; if (s[i] == s[j]) j++; next[i] = j; } for (int i = n + 1; i \u003c m; ++i) { int j = next[stk[top]]; stk[++top] = i; while (j \u0026\u0026 s[i] != s[j]) j = next[j - 1]; if (s[i] == s[j]) j++; next[i] = j; if (next[i] == n) top -= n; } for (int i = 1; i \u003c= top; ++i) std :: cout \u003c\u003c s[stk[i]]; } int main() { std :: ios :: sync_with_stdio(false); std :: cin.tie(nullptr); std :: string s, t, str; std :: cin \u003e\u003e s \u003e\u003e t; str = t + '#' + s; int n = t.length(); Solve(str, n); return 0; } ","description":"旧文搬运","tags":["String","KMP"],"title":"KMP算法学习笔记","uri":"/posts/kmp/"},{"categories":["折腾"],"content":"在学汇编的时候遇到一个问题——王爽的「汇编语言」的 Lab 是在 Windows 环境下的 x86 汇编，而我只有一台 M2 的 Mac ，这显然不行啊（悲）\n于是开始查找 Mac 下学习 x86 汇编的方法，其实还挺简单的。\n主要用到两个工具：\nDOSBox masm 其中 DOSBox 用来模拟 x86 的环境，masm 是一个汇编的工具包。\n下载好之后，将 masm 解压到一个方便管理、路径简单的地方，我就直接放到了 username/masm5 路径下，下载的 DOSBox 是一个 dmg 文件，打开后将里面的 DOSBox 直接拖到 Application 文件夹下即可完成安装。\n然后打开 DOSBox 软件，可以输入 dir 命令查看一些基本信息，接着使用 mount 命令挂载 masm 工具，比如我的命令就是 mount c ~/masm5 ，当它显示挂载成功之后就可以输入 debug 进行汇编了。\n忽略我输入的错误命令 ls\n","description":"旧文搬运","tags":["Mac","Assembly"],"title":"Mac下如何学习x86汇编","uri":"/posts/learn-8086-asm-using-mac/"},{"categories":["Algorithm"],"content":"虽然快速幂的思想比较简单, 而且之前也复习过一遍了, 但是刚才写代码的时候还是重新推了一遍才想起来怎么写, 所以这里写(水)一篇 blog 来增强理解.\n简介 快速幂是用来快速求解 $a^b(\\bmod , p)$ 的一种算法.\n分析 当 b 不是很大的时候, 显然我们可以暴力求解 $a^b(\\bmod , p)$, 这时复杂度是 $\\mathcal{O}(b)$ , 可是当 b 的数量级很大的时候怎么办呢?\n这个时候就需要用到快速幂算法了.\n当 b 为偶数时, $a^b=a^{\\frac{b}{2}}\\cdot a^{\\frac{b}{2}}$ , 当 b 为奇数时, $a^b=a^{\\frac{b}{2}}\\cdot a^{\\frac{b}{2}}\\cdot a$.\n我们要是知道 $a^{\\frac{b}{2}}$ 就可以很快求出 $a^b$ 了, 这时很容易想到递归求解 $a^\\frac{b}{2}$ , 毕竟这种情况下递归计算 $a^b$ 的复杂度是 $\\mathcal{O}(\\log{b})$ 的.\n递归的实现方法很简单, 这里不再赘述.\n我们考虑非递归式的写法.\n在递归式写法中, 每递归一次, a 的次数就会翻一倍, 一共递归了 $\\lfloor\\log{b}\\rfloor$ 次, 因此我们在循环过程中每次 a *= a 和 b \u003e\u003e= 1 即可, 但是如果 b 为奇数时需要再乘以原始的 a, 而此时 a 的值已经变了怎么办?\n我们从一些简单的例子入手.\n考虑 $b=5$ 和 $b=7$ 的情况.\n$$ a^5=a^2\\cdot a^2\\cdot a=(a\\cdot a)(a\\cdot a)a $$\n$$ a^7=a^3\\cdot a^3\\cdot a=(a^2\\cdot a)(a^2\\cdot a)a $$\n在 $b=5$ 的情况下, 我们需要在第一次循环时乘以 a , 此时 a 的值没有变, 之后我们再令 a 自乘.\n在 $b=7$ 的情况下, 第一次循环时的情况与 $b=5$ 的相同, 没有影响, 第二次循环时, 对于先前分出来的 2 个 $a^3$ 我们都要乘一次 a , 也就是需要乘两次 a , 相当于乘以 $a^2$ , 正好是此时 a 变化一次后的值.\n同理, 我们可以看出, 当 b 更大, 需要乘 a 的次数更多的时候, 假设当前是第 k 次循环, 那么我们已经将 $a^b$ 拆成了 $2^k$ 个 $a^{b»k}$ (当然还要算上奇数情况下多乘的 a )的形式, 当进入第 k + 1 次循环时, 若 b 为奇数, 这 $2^k$ 个 $a^{b»k}$ 都要乘一个 a , 相当于乘上了一个 $a^{2^k}$ , 而可以发现这正好是当前 a 经过 k 次自乘后的值, 因此我们只需每次判断 b 的奇偶性, 若为奇数, 就 ret *= a 即可.\n代码 1 2 3 4 5 6 7 8 9 10 11 12 typedef long long ll; ll binpow(ll a, ll b, ll p) { a %= p; ll ret = 1; while (b \u003e 0) { if (b \u0026 1) ret = ret * a % p; a = a * a % p; b \u003e\u003e= 1; } return ret; } ","description":"旧文搬运","tags":["快速幂","Math"],"title":"快速幂复习笔记","uri":"/posts/quickpow/"},{"categories":["Study Notes","Assembly"],"content":"通用寄存器 8086CPU 的所有寄存器都是 16 位的，可以存放 2 字节的数据。\n8086CPU 一共有 14 个寄存器，分别是：AX，BX，CX，DX，SI，DI，SP，BP，IP，CS，SS，DS，ES，PSW，其中 AX，BX，CX，DX 通常用来存放一般性的数据，称为通用寄存器。\n为了兼容上一代的 8 位寄存器，8086 的这四个通用寄存器都可以拆分成两个独立的寄存器来使用，如 AH、AL 。\n字在寄存器中的存储 8086CPU 可以一次性处理一下两种尺寸的数据：\n字节：8 位，可以存放在 8 位寄存器中 字：16 位，可以存放在 16 位寄存器中，高位字节和地位字节分别存放在该 16 位寄存器的高 8 位寄存器与低 8 位寄存器中 几条汇编指令 汇编指令 控制 CPU 完成的操作 高级语言的语法描述 mov ax,18 将 18 送入寄存器 AX AX = 18 mov ah,78 将 78 送入寄存器 AH AH = 78 add ax,8 将寄存器 AX 中的数值加 8 AX = AX + 8 mov ax,bx 将寄存器 BX 中的数据送入寄存器 AX AX = BX add ax,bx 将 AX 和 BX 中的数值相加并存入 AX AX = AX + B 指令中的数值也可以用 16 进制数表示，只需在后面加上 H 表示即可。\n在进行数据传送和运算时，注意指令的两个操作对象的位数应当是一致的。\n物理地址 所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，即物理地址。\nCPU 向地址总线发出物理地址之前，必须先在内部形成这个物理地址。\n不同的 CPU 可以有不同的形成物理地址的方式。\n16 位结构的 CPU 16 位结构描述了一个 CPU 具有下面几方面的结构特性：\n运算器一次最多可以处理 16 位的数据 寄存器的最大宽度为 16 位 寄存器和运算器之间的通路为 16 位 8086CPU 给出物理地址的方法 8086CPU 的地址总线为 20 位，可以达到 1MB 的寻址能力，但是又是 16 位结构，表现出的寻址能力只有 64KB ，因此 8086CPU 采用一种用两个 16 位地址合成的方法形成一个 20 位的物理地址：物理地址 = 段地址 X 16 + 偏移地址\n段地址 在编程时可以根据需要，将若干地址连续的内存单元看作一个段，一个段的起始地址一定是 16 的倍数，长度最大为 64KB 。\n段寄存器 段地址在 8086CPU 的段寄存器中存放，8086CPU 有 4 个寄存器：CS、DS、SS、ES 。\nCS 和 IP CS 为代码段寄存器，IP 为指令指针寄存器。\n8086 机中，任意时刻，CPU 将 CS:IP 指向的内容当做指令执行，它的工作过程可以简要描述如下：\n从 CS:IP 指向的内存单元读取指令，读取的指令进入指令缓冲器 IP = IP + 所读取的指令的长度，从而指向下一条指令 执行指令。然后转到步骤 1 重复过程 在 8086PC 刚启动时，CS 和 IP 设置为 CS = FFFFH, IP = 0000H ，所以 FFFF0H 是 8086PC 开机后执行的第一条指令。\nCPU 将 CS:IP 指向的内存单元中的内容看作指令。\n修改 CS、IP 的指令 8086CPU 大部分寄存器的值都可以用 mov 指令来改变，mov 指令被称为传送指令。\nmov 指令不能用于设置 CS、IP 的值。\n能够改变 CS、IP 的内容的指令被统称为转移指令，其中最简单的一个为 jmp 。\n若想同时修改 CS、IP ，可以用 jmp 段地址:偏移地址\n若想仅修改 IP ，可以用 jmp 某一合法的寄存器\n代码段 我们可以将长度为 N 的一组代码存在一组地址连续、起始地址为 16 的倍数的内存单元中，我们认为这段内存是用来存放代码的，从而定义了一个代码段。\nCPU 只认被 CS:IP 指向的内存单元中的内容为指令，所以要让 CPU 执行代码段中的指令，必须要将 CS:IP 指向所定义的代码段中的第一条指令的首地址。\n实验任务 任务一 第一步先把 CS:IP 指向 1000:0000 ，之后将指令输入到以 1000:0000 为起点的地址中。\n先使用 E 命令写入，但是写满一行后发现不能继续输入了，同时用 D 命令查看，发现只成功写入了输入的一部分指令，之后改用 A 命令写入，注意指令的 16 进制数值不需要在末尾加 H 。\n然后就是不断使用 T 命令执行了，在这个过程中可以发现寄存器中数值溢出时是直接舍去溢出部分的数，而未溢出部分的数不变，同时低 8 位寄存器溢出也是直接抛弃溢出部分的数，而不是存入高 8 位寄存器中。\n任务二 使用 A 命令写入之后将 CS:IP 指向 2000:0 。\n这 3 条指令的含义就是首先将 AX 赋值为 1 ，然后不断乘以 2 ，要计算 $2^8$ 的话，只需一直执行 T 命令直到 AX 变为 0100 即可。\n任务三 使用 D 命令查看 FFF00H ~ FFFFFH 的内容，发现 FFFF5H ~ FFFFCH 对应的 ASCII 码为 01/01/92 ，推测此为生产日期，表示该主板在 1992 年 1 月 1 日生产。\n尝试使用 E 命令改变它 ，结果改变失败，毕竟是写在 ROM 上的嘛\n忽略我个 sb 一开始用的 D 命令修改的地方\n任务四 直接照搬书上的命令，然后发现更改失败 XD ，这大概又是一个 ROM 吧（\n","description":"旧文搬运","tags":["Assembly"],"title":"王爽「汇编语言」学习笔记（二）","uri":"/posts/asm2/"},{"categories":["Algorithm"],"content":"第一章——基础 沙海拾贝 因为是与运算，只有当这 m 个数的第 k 位上都是 1 的时候才能使得最后的数的第 k 位为 1 。\n为了让最后的开心程度最大，我们优先将高位取 1 ，也就是从高位开始枚举，选出数量大于 m 同时在第 k 位上为 1 的所有数，然后再以同样的方法从这些数中选取第 k−1 位为 1 的数，依次选取下去直到可选取的数的数量等于 m 。\nTag :位运算\n麦田 很容易想到用前缀和然后暴力枚举左上角和右下角，但是复杂度过大，这时候需要使用到状态压缩，将二维变为一维，于是原问题就变成了一道经典双指针问题。\nTag : 前缀和、状态压缩、双指针\n时间管理大师 一开始想用贪心，但是发现越想越复杂了。\n如果观察答案的话可以发现答案是单调的，所以可以使用二分答案的方法，已知最后能支撑的时间的话具体充电方案就很好想了，然后判断是否有可能即可。\nTag : 二分答案\n组队 正确解法是贪心 + 优先队列。\n首先肯定要将 a 数组排序，要使人数最少的队伍人数最多，我们优先将当前的数 $a[i]$ 放到以 $a[i]-1$ 结尾的队伍中人数最少的一个队伍即可。思路很简单，这题的难点在于怎么实现。\n如果用一个 queue 来储存当前已经有了的队伍，然后再暴力查找符合要求的人数最少的队伍，时间复杂度 $\\mathcal{O}(n^2)$ ，肯定会 T ，于是我们考虑用优先队列来存储每条队伍的人数，查找时只需输出队头即可，这时候又如何存储每条队伍最后一个元素呢？可以开 n 条优先队列，q[i] 表示以 a[i] 结尾的所有队伍的人数，同时我们还需要对 a[i] 进行离散化，这样一来，分别为每一个人分队是 $\\mathcal{O}(n)$ 的，priority_queue 的操作是 $\\mathcal{O}(n\\log{n})$ 的，所以 总复杂度是 $\\mathcal{O}(n\\log{n})$ 。\nTag : 贪心、优先队列\n第二章——数据结构基础 网上冲浪 直接用栈来模拟。\nTag : 栈\n情人节 首先，如果 flash 和他的两个女朋友在同一条链上，显然选择位于中间的那座城市作为目标城市最优；如果他们分别在不同的子树上，也就是他们两两之间的 LCA 相等，那么就选择这个 LCA 作为目标城市；如果他们中有两个在同一子树上，另一个在不同的子树上，那么选择那两个家伙的 LCA 作为目标城市最优。\n然后要注意 fa 数组开大一点，考试时因为这个调了个把小时都没发现。\nTag : LCA\n权力宝典 因为 l 和 r 的范围很大，所以首先要对数组进行离散化，然后根据题意处理询问，找到是否有 $\\max{(a[l+1, r-1])\u003ca[r]\\le a[l]}$ 即可，对于区间最大值，我们可以用 ST 表来 $\\mathcal{O}(\\log{n})$ 解决。\nTag : 离散化、ST 表\n大富翁 一看到这个矩形就应该想到将二维压缩成一维，然后考虑在区间上找到一段尽量长而且满足金额和小于 $S$ 的子区间，假设当前考虑的子区间为 $[l, r]$ ，固定左端点 $l$ ，如果 $[l, r+1]$ 是满足条件的，那么 $r$ 一定不会是答案区间，可以看出右端点 $r$ 满足决策单调性，因此可以用单调栈。\nTag : 状态压缩、单调栈\n第三章——图论基础 打卡新餐厅 一遍 dfs 即可，途中如果到某一点的 $cost$ 已经大于 $m$ 就直接 return 。\nTag : DFS\n上课 分为两种情况：使用传送门和不使用传送门。\n不使用传送门，直接跑一遍最短路算出 $s$ 到 $t$ 的最短路 $dis_1$ 。\n使用传送门，就跑两遍最短路，一遍以 $s$ 为起点，求出到 $S$ 的最短路，这个我们可以直接在上一步中的 $dis_1[S]$ 加上路上的边数；另一遍以 $t$ 为起点，求出到 $T$ 的最短路，然后两个最短路加起来得到的 $dis_2$ 就是使用传送门的最短路。\n最后比较两个谁小就输出谁。\nTag : 最短路\n复习 一眼看上去是个裸的 Topo + 贪心，Topo 的时候用个小根堆维护就好了。\n然而我假了\n这个顺序要求：在满足所有学习限制的前提下，知识点 1 尽量优先复习；在满足所有学习限制且知识点 1 尽量优先复习的前提下，知识点 2 尽量优先复习，…以此类推。\n这个要求并不是指答案的字典序最小\n我们考虑一组数据\n4 2 2 4 3 1 如果按照原先的策略我们得到的答案是 2 3 1 4 ，然而按照要求实际上的答案应该是 3 1 2 4 。\n从这个例子中可以看出有时候我们要选择一个当时看上去并不优的解来得到最终的最优解，也就是说这道题并不满足每一步都是选最优的策略，这时候从正面上来考虑一种普适性的策略似乎会很麻烦的样子。\n那我们不妨从反面思考。既然要求字典序小的知识点尽量往前排，那么对于优先级低、字典序又很大的知识点我们一定会把它放最后，不如这样，我们按照优先级从低到高考虑，每次把字典序大的放后面，这样其实就是把字典序小的尽量往前放了，然后继续做下去就是将这些字典序小的按照优先级排序了，此时他们需要满足的限制只有优先级，不能再把它往前放了，换句话说，我们每次把字典序大的放后面，不断的做下去直到不能做为止，这样字典序大的除非是优先级高于某个字典序小的否则不可能被放在字典序小的前面。\n具体到操作上来说，这种做法是满足贪心的条件的，我们可以建一个反图，然后 Topo 的同时用一个大根堆维护，最后逆序输出答案。\n一点启示：\n**当正面思考感到繁琐、困难时，不妨试着从反面思考。**类比数学证明题中通过证明逆否命题的正确性来证明正命题。 建反图 Topo 然后逆序输出答案是在很多存在先后层级顺序、需要满足一些限制的图论中的常见技巧。 Tag : 拓扑排序、贪心\n竞技 正解似乎是直接暴搜然后加剪枝？不过考虑到两个同学之间可能的结果是 3 种加上 $N$ 的范围只有 10 ，那么暴搜是很自然的思路了。\n常用的剪枝技巧：可行性剪枝（排除不可能的状态）、记忆化剪枝（除去重复冗余的状态）\nTag : 搜索、剪枝\n第四章——数学基础 PvZ 容易发现盒子里每一个球的编号 $c$ 一定满足 $ax+by=c$ 的形式，考虑裴蜀定理，必然有 $\\gcd(a,b)\\mid c$ ，因此统计 $1\\sim n$ 中有多少个数是 $\\gcd(a,b)$ 的倍数即可，答案是 $\\lfloor\\frac{n}{\\gcd{(a,b)}}\\rfloor$ ，如果这个数是奇数，那么小 P 必赢，否则必输。\nTag : 裴蜀定理、gcd\n吃萝卜 如果一个序列中存在两个数满足他们的乘积是完全平方数，那么这两个数分解后的每一个质数的次数一定都是偶数，于是我们只需筛出 $1e7$ 以内的所有质数，然后对每一个数记录下它对于每个质数的次数的奇偶性，再在当前序列中寻找是否有奇偶性与它完全相同的数即可，这种方案的复杂度是 $\\mathcal{O}(n^2)$ ，还是不够优秀。\n显然需要优化的部分是查找部分，既然有用的信息只是每个质数的次数的奇偶性，我们不妨将奇数次的指数直接记为 $1$ ，偶数次的指数记为 $0$ ，然后序列中的每一个数都会变成 $p_1^{0/1}p_2^{0/1}\\cdots p_n^{0/1}$ ，如果存在一个数每个质数的奇偶性与它完全相同的话，那么他们变形后的数是完全相等的，于是我们只需开一个 $vis$ 数组或者用一个 $map$ 来记录即可。\nTag : 贪心、惟一分解定理、质数筛法\n升旗仪式 很容易想到要统计满足 $i\\times j=x$ 的 $(i,j)$ 的数量，然后一个前缀和加二分查找即可，注意到 $k\\le \\max(n,m)$ ，因此只需要考虑 $[1,\\max(n,m)]$ 的 $x$ ，之后的数一定不可能出现。\n不妨设 $n\\le m$ ，要统计 $i\\times j=x$ 的 $(i,j)$ 相当于求 $x$ 的约数个数，也就是 $\\sum_{d\\mid{x},d\\le n}1$ ，加上统计前缀和的式子就是 $\\sum_{i=1}^m\\sum_{d\\mid{i},d\\le n}1$ ，之后就是考虑一个 $d$ 可能对多少个 $i$ 产生贡献，答案显然是 $\\lfloor \\frac{m}{d}\\rfloor$ ，变换求和顺序之后式子就变成了 $\\sum_{d=1}^n \\lfloor \\frac{m}{d}\\rfloor$ ，然后整除分块即可，复杂度 $\\mathcal{O}(\\sqrt{m})$ 。\nTag : 数论分块、求和\n巴斯和他的学生 等式两边的运算都是列独立的，令 $B_{\\star,i}$ 表示 $B$ 的第 $i$ 列，则有 $\\forall i\\in[1,n],A\\times B_{\\star,i}=C\\odot B_{\\star,i}$ ，即 $\\forall i\\in[1,n],\\sum_{k=1}^n A_{j,k}B_{k,i}=B_{j,i}\\odot C_{j,i}$ 。\n省略第二维的 $i$ ，有 $\\forall i\\in[1,n],\\sum_{k=1}^n A_{j,k}B_{k}=B_{j}\\odot C_{j}$\n如果 $C_j=0$ 则不管，如果 $C_j=1$ 则相当于把左侧 $A_{j,j}B_j$ 变为 $(A_{j,j}-1)B_j$ ，也就是 $$ \\forall j\\in[1,n],\\sum_{k=1}^n (A_{j,k}-[k=j\\land C_j])B_k=0 $$ 将 $B_k$ 看做第 $k$ 个向量选不选，相当于从 $n$ 个向量中选若干个，使得他们的异或值为 0 向量，可以在 $\\mathcal{O}(\\frac{n^3}{\\omega})$ 的时间内求出基数 $d_i$ ，答案即为 $\\prod_{i=1}^n 2^{n-d_i}$ 。\nTag : 线性代数、矩阵\n第五章——动态规划基础 多元函数 可以发现直接暴力递推进行计算会重复计算很多状态，同时数据范围很小，可以使用记忆化搜索。\nTag: 记忆化搜索\n压岁钱 这道题需要根据数据范围来选择不同的算法，前 $60%$ 的数据直接暴搜，后 $40%$ 的数据 DP ，不过 $100%$ 的数据应该可以用 meet in the middle 解决。\nTag : 搜索、动态规划\n油田 分组背包。将第 $i$ 块油田的士兵从小到大排序后得到 $a_{i,1\\sim s}$ ，那么在这块油田部署的士兵数量一定是 $2a_{i,x}+1$ ，能战胜的士兵数是前缀和 $a_{i,1\\sim x}$ ，相当于第 $i$ 组物品一共有 $s$ 个，选取前 $j$ 个的重量是 $2a_{i,j}+1$ ，价值是前缀和 $a_{i,1\\sim j}$ ，然后背包就好了，复杂度 $\\mathcal{O}(nms)$ 。\nTag : 分组背包\n菠萝蜜 价值越高的菠萝蜜一定会优先卖，所以可以将 $p_i$ 从大到小排序，然后发现卖出的菠萝蜜的总价值和菠萝蜜盒的总花费是独立的，而只考虑菠萝蜜盒的选择的话就是一个 0/1 背包问题，我们令 $f[i][j]$ 表示当前考虑到第 $i$ 个菠萝蜜盒，一共可以放入 $j$ 个菠萝蜜的最小花费，那么 $f[i][j]=\\min{(f[i-1][j],f[i-1][j-c[i]]+e[i])}$ ，其中第一维可以滚掉，于是我们最后直接枚举放入菠萝蜜的个数，对 $p[1\\sim i]-f[i]$ 取 $\\min$ 即可，其中 $p[1\\sim i]$ 为前缀和。\nTag : 0/1 背包、贪心\n第六章——数据结构提高 说谎 很裸的并查集。但是要注意 $a,b$ 范围很大，需要先进行离散化，然后可能出现先说 $a,b$ 不在一起，后面又在一起的情况，所以还要先处理所有在一起的情况，之后再判断不在一起的说法。\nTag : 并查集\n选衣服 这道题主要用到了两个套路：\n用线段树对一串 01 序列进行排序，每次排序的复杂度是 $\\log{n}$ 假设有序列 $a_{1\\sim n}$ ，打乱它的原有次序（不一定是按数值排序），希望找到新序列的第 $k$ 位是原序列的第多少位，我们可以利用二分，将原序列第 $1\\sim mid-1$ 个数变为 $0$ ，其余的数置为 $1$ ，那么以相同的方式打乱次序后，若第 $k$ 位为 $1$ ，说明答案 $\\ge \\ mid$ ，否则 $\u003c mid$ 。 看到这道题，对于每一个排序操作直接 $sort$ 肯定会超时，如果要减小复杂度的话，必然要从排序的操作入手，我们希望每次排序的复杂度能够做到 $\\log{n}$ 的级别，而如果序列是 01 序列的话便可用套路 1 降到 $\\mathcal{O}(\\log{n})$ ，再看问题，正好可以用套路 2 把序列变为 01 序列，从而我们每次对原序列二分转化为 01 序列之后套一个线段树对 $m$ 次操作排序，然后看排序后的第 $q$ 位是 1 还是 0 即可。\n所以这道题应该是一个套路题（\nTag : 套路、线段树\n山脉 考试的时候想复杂了，写了一个 $\\mathcal{O}(n\\sqrt{n})$ 并且常数很大的分块暴力，然而忘了 set 的接口最后只能交一个纯暴力解法上去了。\n其实这题挺好想的，对于每次的询问，找到小于等于 $b_i$ 的山的数量 $x$ ，如果它们都不在这 $n$ 座山的两端的话，那么答案显然就是 $x+1$ ，而统计这样的 $x$ 就是树状数组的强项了，同时也可以很轻易的解决单次修改的问题。而对于在 $n$ 座山的两端的情况，显然可以直接对两端分别判断一下，也可以在插入树状数组的时候加入 $0$ 和 $n+1$ 两个节点。\nTag : 树状数组\n魔法芒果 首先考虑暴力求解。每次暴力求出所有合法的边，然后判断两点是否联通，同时判断联通块内的最大值是否合法。\n然后考虑用分块离线处理询问。先以边为第一关键字排序分块，再在块内以询问为第一关键字排序，当前块前面的点为第二关键字排序，保证前面的点都是符合当前询问点对于第一关键字的条件的。同时第二关键字都是单调的，所以按照块的顺序处理一下，再对每个询问暴力处理当前块的贡献，由于每次处理涉及撤销操作，因此需要用到并查集。\nTag : 分块、离线处理、并查集\n第七章——图论提高 挑芒果 可以发现奇数和奇数、偶数和偶数的点是不可能出现在同一集合里的，因此可以得知这是一个二分图。\n然后考虑求二分图的最大独立集，把所有满足 $\\gcd{(i,j)}\\cdot \\gcd{(i+1,j+1)}=1$ 的点之间连一条边再求解即可。\nTag : 二分图、最大独立集\n完全图 考虑 Kruskal 算法的步骤，每次加入最小的合法的一条边，记为 $edge(u,v)$ ，然后合并两个集合，设 $u,v$ 所在的集合的大小为 $size[u],size[v]$ ，那么在题述的完全图中，任意一条俩节点分属于这两个集合的边的长度都要大于 $val(u,v)$ ，如果是边权和最小的完全图的话，那么长度就要等于 $val(u,v)+1$ ，于是这两个集合之间的边权和即为 $(val(u,v)+1)\\cdot(size[u]\\cdot size[v]-1)+val(u,v)$ 。\n最后的做法显然就是跑一遍 Kruskal ，每次将答案加上上述边权和即可。\nTag : 最小生成树、Kruskal\n探险 考试时只想到如果能找出所有的路径组成一张完全图，那么最后的答案就是在这张图的最小生成树上求 LCA ，同时由于 $n$ 很大，建图的时候只需要留下可能会用到的边，但是前面怎样求出这些路径不会。正确的方法是双向宽搜，可以在一定程度上减小复杂度。\nTag : 双向宽搜、LCA、最小生成树\n第八章——数学提高 挑战者游戏 当 $k=1$ 时，显然 $n$ 为奇数的话是先手必胜。\n当 $k\u003e1$ 时，如果当前是两堆数量相同的石头，那么无论先手怎么取，后手都可以在另一堆石头里用相同的方式取，从而先手是必输的。因此，FA 只需在一开始就将其分成两堆数量相同的石头让自己成为后手就是必赢的，若 $n$ 为奇数就从中间取 1 个，否则就取 2 个，所以 FA 是必赢的。\nTag : 博弈论\n数的研究 当 $vi(x)=x$ ，也就是 $x$ 的分解式中不含有指数大于 1 的质因子时，结论显然不成立。\n当 $x$ 的分解式中含有指数大于 1 的质因子时，我们尝试找到使得结论成立的 $y,z$ ，观察结论式，不等式两端的数都是 $vi(x)$ 的倍数，右端 $x$ 除以 $vi(x)$ 后只剩下指数大于 1 的质因子的乘积了，而左边除以 $vi(x)$ 后剩下的因子还与 $y,z$ 有关，为了减少未知数的数量，我们希望它只与 $z$ 有关并且显然不会再包含 $vi(x)$ 的质因子了，于是想到令 $y=p_1p_2\\cdots p_n$ ，那么 $z=p_{1}p_{2}\\cdots p_{n}(p_{i_1}^{a_{i_1}-1}p_{i_2}^{a_{i_2}-1}\\cdots p_{i_k}^{a_{i_k}-1}-1)$ （其中 $a_{i_1},a_{i_2},\\dots,a_{i_k}\u003e1$ ），此时 $$ \\begin{aligned} \\frac{vi(xyz)}{vi(x)}\u0026=vi(p_{i_1}^{a_{i_1}-1}p_{i_2}^{a_{i_2}-1}\\cdots p_{i_k}^{a_{i_k}-1}-1)\\\\ \u0026\\le p_{i_1}^{a_{i_1}-1}p_{i_2}^{a_{i_2}-1}\\cdots p_{i_k}^{a_{i_k}-1}-1\\\\ \u0026\u003c p_{i_1}^{a_{i_1}-1}p_{i_2}^{a_{i_2}-1}\\cdots p_{i_k}^{a_{i_k}-1}\\\\ \u0026= \\frac{x}{vi(x)} \\end{aligned} $$ 也就是说我们找到了合法的 $y,z$ ，从而当 $x$ 的分解式中含有指数大于 1 的质因子时结论是一定成立的。\n于是我们需要将 $x$ 质因数分解即可，考虑到 $x\\le 10^{18}$ ，需要使用 Pollard Rho 算法。\nTag : 数论、惟一分解定理、Pollard Rho\n喷泉 题意即从 $[L,R]$ 中选取 $\\le n$ 个数的方案数。\n不妨令 $m=R-L+1$ ，即从 $m$ 个数里选取 $\\le n$ 个数。直接考虑会很复杂，由于任意一种方案选取的数总能排序后形成一个单调不降序列，因此按照大小顺序来考虑枚举会更好。\n假设是选取 $k$ 个数，先从最简单的情况——单调递增序列开始考虑，此时方案数显然是 $\\binom{m}{k}$ ，如果是单调不降序列，假设 $m$ 个数分别选取 $x_1,x_2,\\dots,x_m$ 个，有 $x_1+x_2+\\cdots+x_m=k$ ，并且 $x_i\\ge 0$ ，那么就是经典隔板法的应用了，方案数为 $\\binom{k-1}{m+k-1}$ ，从而最后的答案为 $\\sum_{i=1}^n\\binom{m}{i}+\\binom{m+i-1}{i-1}$ 。\n尝试将式子化简，根据 $\\binom{n}{m}=\\binom{n-1}{m}+\\binom{n-1}{m-1}$ ，先加上 $\\binom{m}{0}$ 再减去 1 ，不断递推约项可以得到 $\\binom{n+m}{n}-1$ ，由于模数不大，可以采用 Lucas 定理求解。\nTag : 计数原理、Lucas 定理、排列组合\ngcd and prime 考虑莫比乌斯反演。\n只有当 $\\gcd(i,j)=p(p为素数)$ 时才对答案有贡献，因此原式转化为 $\\sum_{i=1}^n\\sum_{j=1}^m[\\gcd(i,j)=p]$ ，等价于 $\\sum_{p\\in primes}\\sum_{i=1}^n\\sum_{j=1}^m[\\gcd(i,j)=p]$ 。\n转化为可以等价代换的形式，$\\sum_{p\\in primes}\\sum_{i=1}^{\\lfloor\\frac{n}{p}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{p}\\rfloor}[\\gcd(i,j)=1]$ ，\n然后开始莫比乌斯反演，$\\sum_{p\\in primes}\\sum_{i=1}^{\\lfloor\\frac{n}{p}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{p}\\rfloor}\\sum_{d\\mid\\gcd(i,j)}\\mu(d)$ ，\n改变求和顺序，$\\sum_{p\\in primes}\\sum_{d=1}^{\\min{(\\lfloor\\frac{n}{p}\\rfloor,\\lfloor\\frac{m}{p}\\rfloor)}}\\mu(d)\\lfloor\\frac{n}{dp}\\rfloor\\lfloor\\frac{m}{dp}\\rfloor$ ，\n令 $T=dp$ ，改为枚举 $T$ ，可以发现 $T$ 能取遍 $[1,\\min(n, m)]$ ，而 $d\\mid T$ 已知，于是有 $\\sum_{T=1}^{\\min(n,m)}\\sum_{p\\mid T,p\\in primes}\\mu(\\frac{T}{p})\\lfloor\\frac{n}{T}\\rfloor\\lfloor\\frac{m}{T}\\rfloor$ ，\n最后用埃氏筛预处理每个 $T$ 的贡献并且整除分块，再对 $T$ 进行前缀和处理即可。\nTag : 莫比乌斯反演、gcd、数论分块、素性筛\n第九章——动态规划提高 大禹治水 直接求解每个节点遭受洪水的概率比较复杂，但是反过来求解它不爆发洪水的概率则比较简单，等于每条道路不被洪水冲垮同时该节点不爆发洪水的概率的积。\n由于这个图是一棵树，考虑换根 DP 。不妨设 1 号节点为根，令 $f_i$ 为在 $i$ 的子树中 $i$ 未遭受洪水的概率，则状态转移方程为 $f[u]=\\prod_{v\\in son[u]}f[v]+(1-f[v])(1-p)$ ，设 $g_i$ 为 $i$ 未遭受洪水的概率，令 $s=\\dfrac{g[u]}{f[v]+(1-f[v])(1-p)}$ ，于是又有状态转移方程 $g[v]=fv$ 。\nTag : 概率论、换根 DP\n漂亮妹妹 考虑数位 DP 。设 $f[i][j][k][l][m]$ 表示第 $i$ 位数，是否存在至少 3 个相邻的相同数字为 $j$ ，上一个数为 $k$ ，相邻的相同数字出现次数为 $l$ ，是否出现 4 和 8 为 $m$ 的方案数，然后仿照 dfs 进行数位 DP 。\nTag : 数位 DP\n猫咖 很显然是状压 DP ，设 $f[i][j]$ 为考虑前 $i$ 行，其中第 $i$ 行的状态为 $j$ 的方案数然后进行状态转移即可。\nTag : 状压 DP\n","description":"旧文搬运","tags":["ACM"],"title":"ACM算法实践总结","uri":"/posts/summary-of-acm-algo/"},{"categories":["ACG"],"content":"因为看到《葬送的芙莉莲》中有一些台词挺触动人心的（也许只是我中二病犯了www），在 Bangumi 上恰好看到《葬送的芙莉莲》优秀台词个人收集，因此突发奇想，也来记录一下这些台词，顺便看完后也能在这里写点感言。\nChap.19 突袭\n这种事情，总是要有人去做的吧？\nChap.20 师父的招式\n「无论被打倒多少次，你都要不停地站起来反击。\n​\t战士的胜利就是在战场上站到最后。」\nChap.22 服从天秤\n「听好了，芙丽莲。不要想着名留青史。\n​\t要活得不起眼。\n​\t在你杀死魔王之日，就是你名留青史之时。」\nChap.25 剑之乡\n「假勇者也没什么不好的吧。我会将魔王打倒，让这个世界再次恢复和平。\n​\t这样一来，不管是什么假勇者，还是真勇者，都无所谓了。」\n「辛美尔做到了。\n​\t就算没有那把剑，辛美尔也依然拯救了这个世界。\n​\t他是真正的勇者。」\n「所谓的英雄，无论如何都会被后世擅自美化。\n​\t最终，在这不断的美化过程中，就连最初的原型都会逐渐消逝。」\nChap.26 送给战士的礼物\n「努力过的人皆为战士。」\nChap.27 平凡村落里的牧师\n「在我心底，一定是恐惧着和魔王战斗的吧。\n​\t我早已无法弥补流逝的岁月所产生的空白。」\n「那又怎么了，芙丽莲。\n​\t我在和你谈的是现在。」\n","description":"旧文搬运","tags":["Anime"],"title":"「葬送のフリーレン」优秀台词个人收集","uri":"/posts/%E8%91%AC%E9%80%81%E3%81%AE%E3%83%95%E3%83%AA%E3%83%BC%E3%83%AC%E3%83%B3/"},{"categories":["Algorithm"],"content":"双向搜索主要分为「双向同时搜索」和 「meet in the middle」 两种算法。\n双向同时搜索 双向同时搜索算法主要用于解决一些给出了起点和终点，单次搜索的代价不大，同时题目中对答案的路径具有一定限制而导致每次都暴力搜索来寻找一条合法路径的代价过高的问题。\n顾名思义，双向同时搜索就是从起点和终点同时出发，各自搜索到达每个位置的合法路径，然后根据限制统合二者的状态来得到答案。\n「Luogu P5195」Knights of Ni S 贝茜遇到了一件很麻烦的事：她无意中闯入了森林里的一座城堡，如果她想回家，就必须穿过这片由骑士们守护着的森林。为了能安全地离开，贝茜不得不按照骑士们的要求，在森林寻找一种特殊的灌木并带一棵给他们。\n当然，贝茜想早点离开这可怕的森林，于是她必须尽快完成骑士们给的任务，贝茜随身带着这片森林的地图，地图上的森林被放入了直角坐标系，并按 $x,y $ 轴上的单位长度划分成了 $ W \\times H\\ ( 1 \\leq W,H \\leq 1000 )$ 块，贝茜在地图上查出了她自己以及骑士们所在的位置，当然地图上也标注了她所需要的灌木生长的区域。某些区域是不能通过的（比如说沼泽地，悬崖，以及食人兔的聚居地）。在没有找到灌木之前，贝茜不能通过骑士们所在的那个区域，为了确保她自己不会迷路，贝茜只向正北、正东、正南、正西四个方向移动（注意，她不会走对角线）。她要走整整一天，才能从某块区域走到与它相邻的那块区域。\n贝茜希望你能帮她计算一下，她最少需要多少天才可脱离这可怕的地方？输入数据保证贝茜一定能完成骑士的任务。\nLuogu\n分析 已知起点（贝茜的位置）和终点（骑士们的位置），从某点搜索到其他所有点并且途中不经过某些区域的距离的时间是 $\\mathcal{O}(WH)$ 的，代价较小，同时题目要求从起点到终点的路径上一定要经过灌木，如果搜索找到起点到灌木的路径，然后再枚举从每个灌木走到终点的路径的时间是 $\\mathcal{O}(W^2H^2)$ 的，显然代价太大，因此这是一道双向同时搜索板子题。\n我们从起点和终点分别出发，搜索到达每一个位置的最短合法路径，然后再枚举每一个灌木的位置，答案就是对他们分别到当前灌木的最短路之和取 $\\min$ 。\n时间复杂度：$\\mathcal{O}(WH)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u003cbits/stdc++.h\u003e using namespace std; int gi() { int x = 0, f = 1; char c = getchar(); for ( ; !isdigit(c); c = getchar()) if (c == '-') f = -1; for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return x * f; } const int N = 1005; struct hlw { int x, y; } st, ed, wd[N * N]; int n, m, tot, ans; int g[N][N], dis[2][N][N]; int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0}; bool vis[2][N][N]; void bfs(int op) { queue \u003chlw\u003e q; if (op) { q.push(ed), vis[op][ed.x][ed.y] = 1; dis[op][ed.x][ed.y] = 0; } else { q.push(st), vis[op][st.x][st.y] = 1; dis[op][st.x][st.y] = 0; } while (!q.empty()) { hlw u = q.front(); q.pop(); for (int i = 0; i \u003c 4; ++i) { hlw v = (hlw){u.x + dx[i], u.y + dy[i]}; if (v.x \u003c= 0 || v.y \u003c= 0 || v.x \u003e n || v.y \u003e m) continue; if (g[v.x][v.y] == 1 || vis[op][v.x][v.y]) continue; if (dis[op][v.x][v.y] \u003e dis[op][u.x][u.y] + 1) { dis[op][v.x][v.y] = dis[op][u.x][u.y] + 1; if (!vis[op][v.x][v.y]) q.push(v), vis[op][v.x][v.y] = 1; } } } } int main() { m = gi(), n = gi(); for (int i = 1; i \u003c= n; ++i) for (int j = 1; j \u003c= m; ++j) { g[i][j] = gi(); if (g[i][j] == 2) st.x = i, st.y = j; else if (g[i][j] == 3) ed.x = i, ed.y = j; else if (g[i][j] == 4) wd[++tot].x = i, wd[tot].y = j; } memset(dis, 0x3f3f3f3f, sizeof(dis)); bfs(0), bfs(1); ans = N * N; for (int i = 1; i \u003c= tot; ++i) ans = min(ans, dis[0][wd[i].x][wd[i].y] + dis[1][wd[i].x][wd[i].y]); printf(\"%d\", ans); return 0; } meet in the middle 如果题中的数据量很小，但是又没小到可以直接暴搜的时候，可以使用 meet in the middle 算法。\nmeet in the middle 其实也是直接暴搜，但是它只暴力枚举 $\\frac{n}{2}$ 的数据可能产生的状态，首先枚举前一半的数据，记录到达每种状态的代价，然后再搜索后一半的数据，找到一种状态时要注意统合前一半的状态看能否产生答案。\n假如原来直接暴搜的时间复杂度是 $\\mathcal{O}(2^n)$ ，那么使用 meet in the middle 之后的时间复杂度便是 $\\mathcal{O}(2^{\\frac{n}{2}})$ 的。\n「Luogu P2962」Lights G 给出一张 $n$ 个点 $m$ 条边的无向图，每个点的初始状态都为 $0$。\n你可以操作任意一个点，操作结束后该点以及所有与该点相邻的点的状态都会改变，由 $0$ 变成 $1$ 或由 $1$ 变成 $0$。\n你需要求出最少的操作次数，使得在所有操作完成之后所有 $n$ 个点的状态都是 $1$。\nLuogu\n分析 容易验证对于一个开关，我们最多按下一次，因此每个开关可能的状态只有两种：打开 or 不打开，直接暴力枚举每个开关的状态然后判断是否满足条件的代价是很明显的指数级别的，从这一点上看就应该想到是否能用 meet in the middle 解决。\n再看数据范围 $n\\le 35$ 很小，但是直接枚举每个点的状态的代价最大也还是 $2^{35}$ 的承受不起，但是如果把它折半之后就是 $2^{17.5}$ 的，这完全在承受范围之内，所以我们应该用 meet in the middle 暴搜。\n时间复杂度：$\\mathcal{O}(n\\cdot 2^{\\frac{n}{2}})$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; int n, m, ans; ll a[40]; map \u003cll, int\u003e f;//枚举每个开关是否打开之后得到所有开关对应的状态与对应打开开关的数量的映射 int main() { int u, v; cin \u003e\u003e n \u003e\u003e m; for (int i = 0; i \u003c n; ++i) a[i] |= (1ll \u003c\u003c i); for (int i = 1; i \u003c= m; ++i) { cin \u003e\u003e u \u003e\u003e v; u--, v--; a[u] |= (1ll \u003c\u003c v), a[v] |= (1ll \u003c\u003c u); } for (ll i = 0; i \u003c (1ll \u003c\u003c (n / 2)); ++i) {//前 n/2 个开关是否打开 ll tmp = 0;//当前所有开关的状态 int cnt = 0;//打开的开关数，其实就是 i 中 1 的个数 for (int j = 0; j \u003c n / 2; ++j) if ((i \u003e\u003e j) \u0026 1) tmp ^= a[j], cnt++; if (f.count(tmp)) f[tmp] = min(f[tmp], cnt); else f[tmp] = cnt; } ans = n; for (ll i = 0; i \u003c (1ll \u003c\u003c (n - n / 2)); ++i) { ll tmp = 0; int cnt = 0; for (int j = 0; j \u003c n - n / 2; ++j) if ((i \u003e\u003e j) \u0026 1) tmp ^= a[j + n / 2], cnt++; if (f.count(tmp ^ ((1ll \u003c\u003c n) - 1))) ans = min(f[tmp ^ ((1ll \u003c\u003c n) - 1)] + cnt, ans); } printf(\"%d\", ans); return 0; } 「Luogu P3067」Balanced Cow Subsets G 我们定义一个奶牛集合 $S$ 是平衡的，当且仅当满足以下两个条件：\n$S$ 非空。 $S$ 可以被划分成两个集合 $A,B$，满足 $A$ 里的奶牛产奶量之和等于 $B$ 里的奶牛产奶量之和。划分的含义是，$A\\cup B=S$ 且 $A\\cap B=\\varnothing$。 现在给定大小为 $n$ 的奶牛集合 $S$，询问它有多少个子集是平衡的。请注意，奶牛之间是互不相同的，但是它们的产奶量可能出现相同。\nLuogu\n分析 每个元素有三种可能：不在子集中、在子集中被分到集合 $A$ 、在子集中被分到集合 $B$ 。\n直接暴搜的时间复杂度同样也是指数级且不可接受的，而折半搜索之后则是可以接受的，因此我们使用 meet in the middle 算法。\n当我们搜索到元素 $k$ 时，若它不在子集中，则当前总代价不变；若将它分到集合 $A$ ，则将当前总代价加上 $a[k]$ ；若将它分到集合 $B$ ，则减去 $a[k]$ 。同时我们还需要用一个二进制数 status 记录每个元素是否被选取，并用 map 建立 cost 与 status 的映射，由于同一个 cost 可能由多个（最多 1023 个） status 产生而且折半之后 status 的值最大为 1023 ，所以 map 的第二维我们使用一个 bitset 来将第 status 位标为 1 表示 cost 可以由它产生。\n这道题的关键在于去重。在搜索第 $\\frac{n}{2}\\sim n$ 个元素时，如果前 $\\frac{n}{2}$ 个元素可以达到总代价为 cost 的结果，那么他们中的每一种状态都可以和当前状态组合成一个子集。但是同样的 status 因为每个元素被分到的集合不同所以也会产生不同的 cost ，而这不同的 cost 下可能对应了前 $\\frac{n}{2}$ 个元素产生的同一状态，他们统合之后的子集显然在前面已经被统计过了，这就产生了重复。\n解决方案就是建一个再建 1023 个名为 vis 的 bitset ，如果当前状态 status 与前 $\\frac{n}{2}$ 个元素产生的某种状态 statusLast 组合过，就将 vis[status] 的第 statusLast 位标为 1 ，在统计答案之前进行去重。\n一点吐槽：\n我做的时候仿照前一题直接用 3 进制枚举每个元素的状态，然后统计答案，但是我 sb 没注意看题，最后统计的是不同平衡子集下分成 $A,B$ 两个集合的总方案数，而且一些细节上没考虑到，比如后 $\\frac{n}{2}$ 个元素分成的 $A,B$ 集合可以分别整合进前 $\\frac{n}{2}$ 个元素分成的 $A,B$ 集合内，这样会产生新的 $A,B$ 集合，当然，产生的子集是一样的。\n这下该庆幸当时因为不想调代码去看了题解发现看半天看不明白觉得题解有问题然后再看一遍问题才发现我把问题搞错了（\n一些要注意的地方：\n将分到不同集合的情况对当前代价的影响分别记为 $+a[k]$ 和 $-a[k]$ 的方式显然要比我的分别用 sum1 和 sum2 来记录 $A,B$ 集合的代价要方便统合得多 在 dfs 前将元素 sort 一遍可以快很多 这里在数据量较小的情况下可以直接将记录状态的二进制数作为记录另一种状态的二进制数的某一位来存储数据，高效方便 最后去重的方式很妙：tmp \u0026= ~vis[status] 代码 100pts 正解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 10; int n, ans; int a[25]; bitset \u003c1 \u003c\u003c N\u003e vis[1 \u003c\u003c N]; map \u003cint, bitset \u003c1 \u003c\u003c N\u003e \u003e f; void dfs1(int k, int cost, int status) { if (k == n / 2) { f[cost].set(status); return; } dfs1(k + 1, cost, status); dfs1(k + 1, cost + a[k], status | (1 \u003c\u003c k)); dfs1(k + 1, cost - a[k], status | (1 \u003c\u003c k)); } void dfs2(int k, int cost, int status) { if (k == n) { if (f.count(cost)) { bitset \u003c 1 \u003c\u003c N \u003e tmp(f[cost]); tmp \u0026= ~vis[status]; ans += tmp.count(); vis[status] |= tmp; } return; } dfs2(k + 1, cost, status); dfs2(k + 1, cost + a[k], status | (1 \u003c\u003c (k - n / 2))); dfs2(k + 1, cost - a[k], status | (1 \u003c\u003c (k - n / 2))); } int main() { scanf(\"%d\", \u0026n); for (int i = 0; i \u003c n; ++i) scanf(\"%d\", \u0026a[i]); sort(a, a + n); dfs1(0, 0, 0); dfs2(n / 2, 0, 0); printf(\"%d\", ans - 1);//记得 -1 去掉子集为空集的情况 return 0; } 我的搞错了题目 + 细节没处理好却还混到了 19pts 的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; int n; ll ans; int a[25], sta[25]; map \u003cint, int\u003e f; map \u003cll, bool\u003e vis; int main() { ll ans1 = 0, ans2 = 0, ans3 = 0, ans4 = 0; scanf(\"%d\", \u0026n); for (int i = 0; i \u003c n; ++i) scanf(\"%d\", \u0026a[i]); for (ll i = 0; i \u003c pow(3, n / 2); ++i) { ll tmp = i, now = 0; int sum1 = 0, sum2 = 0; for (int k = 0; k \u003c n / 2; ++k) { sta[k] = tmp % 3, tmp /= 3; //printf(\"sta[%d]=%d\\n\", k, sta[k]); if (sta[k]) now |= (1 \u003c\u003c k); if (sta[k] == 1) sum1 += a[k]; else if (sta[k] == 2) sum2 += a[k]; } //printf(\"now:%lld sum1:%d sum2:%d\\n\", now, sum1, sum2); //if (vis[now]) puts(\"visited\"); //else puts(\"unvisited\"); if (sum1 == sum2 \u0026\u0026 sum1) ans1++; if (!vis[now]) f[sum1 + sum2]++, vis[now] = 1; } ans1 /= 2; for (ll i = 0; i \u003c pow(3, n - n / 2); ++i) { ll tmp = i, now = 0; int sum1 = 0, sum2 = 0; for (int k = n / 2; k \u003c n; ++k) { sta[k] = tmp % 3, tmp /= 3; if (sta[k]) now |= (1 \u003c\u003c k); if (sta[k] == 1) sum1 += a[k]; else if (sta[k] == 2) sum2 += a[k]; } if (sum1 == sum2 \u0026\u0026 sum1) ans2++; if ((sum1 + sum2 != 0) \u0026\u0026 !vis[now]) ans3 += f[sum1 + sum2], vis[now] = 1; if (sum1 + sum2 != 0) { if (f.count(sum1 - sum2)) ans4 += f[sum1 - sum2]; if (f.count(sum2 - sum1)) ans4 += f[sum2 - sum1]; } } ans2 /= 2, ans4 /= 2; ans = ans1 + ans2 + ans3 + ans4; //printf(\"ans1:%lld ans2:%lld ans3:%lld ans4:%lld\\n\", ans1, ans2, ans3, ans4); printf(\"%lld\", ans); return 0; } ","description":"旧文搬运","tags":["Search","双向同时搜索","meet in the middle"],"title":"双向搜索总结","uri":"/posts/search-on-both-sides/"},{"categories":["Study Notes","Assembly"],"content":"简单认识汇编语言 机器语言：机器指令的集合。\n由于硬件设计和内部结构不同，每一种微处理器都有自己的机器语言。\n汇编语言的主体是汇编指令，汇编指令与机器指令的差别在于指令的表示方法。\n因为计算机只能读懂机器指令，所以需要使用编译器将汇编指令转换成机器指令的。\n汇编语言的组成：\n汇编指令（有对应的机器码） 伪指令（没有对应的机器码，由编译器执行，计算机不执行） 其他符号（没有对应的机器码，由编译器识别） 硬件知识基础 存储器 存储器即内存，存放 CPU 可以直接使用的信息，包括指令和数据。\n指令和数据\n二者在内存或磁盘上没有区别，都是二进制信息，但是在 CPU 进行工作时会将一部分信息看做指令，一部分看做数据。\n存储单元\n存储器被划分为若干个存储单元，每个存储单元从 0 开始编号，单个存储单元可以存储 1 Byte 的信息。\nCPU 对存储器的读写\nCPU 进行对数据的读写需要与存储器芯片进行 3 种信息的交互：\n存储单元的地址（地址信息） 器件的选择，读/写的命令（控制信息） 读/写的数据（数据信息） 总线 CPU 通过总线向存储器芯片传输信息，总线在逻辑上分为 3 类：地址总线、控制总线、数据总线。\n地址总线\n地址总线的宽度决定了 CPU 的寻址能力。\n一个 CPU 具有 N 根地址总线，就说它的地址总线宽度为 N ，这样的 CPU 可以对 $2^N$ 个内存单元进行寻址。\n数据总线\n数据总线的宽度决定了 CPU 与其他器件进行数据传送时的一次数据传送量。\n控制总线\n有多少根控制总线，就意味着 CPU 提供了对外部器件的多少种控制。\n控制总线的宽度决定了 CPU 对外部器件的控制能力。\n内存地址空间（概述） 主板：主板上有核心器件和一些主要器件，如 CPU 、存储器、外围芯片组、扩展插槽等，他们之间通过总线相连。\n接口卡：计算机上直接控制外部设备进行工作的是位于扩展插槽上的接口卡。CPU 直接控制接口卡，通过接口卡实现对外部设备的间接控制。\n各类存储器芯片\n存储器芯片从读写属性上分为两类：\nRAM：可读可写，必须带电存储，关机后存储内容丢失 ROM：只可读取不可写入，关机后内容不丢失 这些存储器从功能和连接上又可分为 3 类：\n随机存储器 存放供 CPU 使用的绝大部分程序和数据，主随机存储器一般由主板上的 RAM 和插在扩展插槽上的 RAM 组成 装有 BIOS 的 ROM 接口卡上的 RAM 如显卡上的显存 内存地址空间\nCPU 在控制上述存储器时，都将他们当做内存来对待，把他们看做一个由若干存储单元组成的逻辑存储器，即内存地址空间。\n内存地址空间大小受 CPU 地址总线宽度的限制，不同的计算机系统的内存地址空间的分配情况不同。\n","description":"旧文搬运","tags":["Assembly"],"title":"王爽「汇编语言」学习笔记（一）","uri":"/posts/asm1/"},{"categories":["Algorithm"],"content":"数论，是一门研究整数的纯数学的分支，而整数的基本元素是素数(也称质数)，所以数论的本质是对素数性质的研究。\n素数 一些基本概念就不写了.\n注意两点:\n0、1、负整数既不是素数也不是合数. $\\pi(n)$ 表示不大于 $n$ 的素数个数, 有如下近似关系 $\\pi(n)\\sim\\dfrac{n}{\\ln{n}}$ . 素数判定 如何判定正整数 $n$ 是否是素数?\n很容易想到用每一个小于 $n$ 且大于 $1$ 的数来判断它是否是 $n$ 的约数, 若都不是, 则 $n$ 为素数, 否则为合数.\n这个暴力算法是 $\\mathcal{O}(n)$ 的, 但是我们考虑到, 若数 $p$ 为 $n$ 的约数, 则 $\\frac{n}{p}$ 也是 $n$ 的约数, 所以我们只需用 $2\\sim \\sqrt{n}$ 的数来判定即可, 于是优化一下我们得到一个 $\\mathcal{O}(\\sqrt{n})$ 的算法.\n1 2 3 4 5 6 7 bool isPrime(int n) { if (n == 1) return false; if (n == 2) return true; for (int i = 2; i * i \u003c= n; ++i) if (n % i == 0) return false; return true; } 整数惟一分解定理 若整数 $n\\ge2$ , 那么 $n$ 一定可以惟一地表示为若干素数的乘积, 形如\n$$n=p_1^{r_1}p_2^{r_2}\\cdots p_k^{r_k}(p_i为素数, r_i\\ge0)$$\n1 2 3 4 5 6 7 8 9 10 vector \u003cint\u003e factor(int n) { vector \u003cint\u003e ret; for (int i = 2; i * i \u003c= n; ++i) while (n % i == 0) { ret.push_back(i); n /= i; } if (n \u003e 1) ret.push_back(n); return ret; } 素数筛法 主要是埃氏筛法和欧拉筛法.\nEratosthenes 筛法 Eratosthenes 筛法可以快速列举出给定范围内的所有素数.\n一个合数一定可以写成 $p\\cdot x$ 的形式, 其中 $p$ 为素数, $x$ 为整数, 因此对每一个 $p$ , 我们从小到大枚举 $x$ , 筛掉相应的 $p\\cdot x$ 即可.\n一点小改进: 当 $x\u003cp$ 时, $p\\cdot x$ 一定被 $x$ 的素因子筛过一遍, 所以我们枚举 $x$ 时从 $x=p$ 开始枚举.\n时间复杂度: $\\mathcal{O}(\\frac{n}{2}+\\frac{n}{3}+\\frac{n}{5}+\\cdots)=\\mathcal{O}(n\\log{\\log{n}})$\n1 2 3 4 5 6 7 8 9 10 11 bool isprime[N]; void Eratos(int n) { memset(isprime, 1, sizeof isprime); isprime[0] = isprime[1] = 0; for (int i = 2; i * i \u003c= n; ++i) if (isprime[i]) { for (int j = i * i; j \u003c= n; j += i) isprime[j] = 0; } } 例题 「POJ 2689」Prime Distance\n由于这里 $L,R$ 的范围很大, 暴力筛完之后枚举求解肯定会 T , 但是 $R-L\\le 10^6$ 的范围却是在我们的承受范围之内的.\n于是我们考虑用 $1\\sim n$ 这一小范围的素数筛掉 $L\\sim R$ 之间的合数.\n假设数 $k\\in[L, R]$ , 其中 $k$ 的最小质因数为 $p$ , 满足 $p\u003en$ , 则 $k=p\\cdot x$ , 若 $x\u003cp$ , 则 $k$ 一定存在小于 $p$ 的质因数, 矛盾, 故而 $x\\ge p$ , 也就是说, 会被漏筛的数 $k$ 满足 $k\\ge p^2$ , 为了保证算法的正确性, 我们要让这样的数落在 $[L, R]$ 外, 也就是让 $p^2\u003eR$ , 于是我们令 $n=\\sqrt{R}$ 即可.\n筛法优化质因数分解 利用埃氏筛法可以快速实现素因数分解, 只要在筛的时候记录下每个数的最小素因数即可.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 bool isprime[N]; int minfac[N]; void Eratos(int n) { memset(isprime, 1, sizeof isprime); isprime[0] = isprime[1] = 0; for (int i = 1; i \u003c= n; ++i) minfac[i] = i; for (int i = 2; i * i \u003c= n; ++i) if (isprime[i]) { for (int j = i * i; j \u003c= n; j += i) { isprime[j] = 0; if (minfac[j] == j) minfac[j] = i; } } } vector \u003cint\u003e factor(int n) { vector \u003cint\u003e ret; while (n \u003e 1) { ret.push_back(minfac[n]); n /= minfac[n]; } return ret; } Euler 筛法 在埃氏筛中, 30 这个数被 $p=2,3,5$ 分别筛了三次, 造成了重复, 如果我们能让每个数只被它最小的素因数筛, 就能做到 $\\mathcal{O}(n)$ 的时间复杂度.\n在 Euler 筛法中, 我们从 $2\\sim n$ 枚举每一个数 $i$ , 若 $i$ 是素数, 则加入素数表中, 然后我们再从小到大枚举前面的素数 $prime[j]$ , 筛掉 $i\\cdot prime[j]$ , 当 $prime[j]$ 是 $i$ 的一个素因数时, 那么后面再继续枚举到的素数一定不是所筛的数的最小素因数, 毕竟后面的素数一定大于当前的 $prime[j]$ , 所以这时可以终止筛选.\n时间复杂度: $\\mathcal{O}(n)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 int prime[N]; bool isprime[N]; void Euler(int n) { memset(isprime, 1, sizeof isprime); isprime[0] = isprime[1] = 0; for (int i = 2; i \u003c= n; ++i) { if (isprime[i]) prime[++prime[0]] = i; for (int j = 1; j \u003c= prime[0] \u0026\u0026 prime[j] * i \u003c= n; ++j) { isprime[i * prime[j]] = 0; if (i % prime[j] == 0) break; } } } 约数 整数惟一分解定理的推论 $$N=p_1^{r_1}p_2^{r_2}\\cdots p_k^{r_k}$$\n$N$ 的正约数的个数为 $(r_1+1)(r_2+1)\\cdots(r_k+1)=\\prod_{i=1}^k(r_i+1)$ $N$ 的约数个数上界为 $\\sqrt{N}$ $N$ 的所有正约数的和为 $(1+p_1+p_1^2+\\cdots+p_1^{r_1})\\cdots(1+p_k+\\cdots+p_k^{r_k})=\\prod_{i=1}^k(\\sum_{j=0}^{r_i}p_i^j)$ 时间复杂度: $\\mathcal{O}(\\sqrt{N})$ 例题 「Luoggu P1463」反素数\n这道题只需要知道 $1\\sim 2\\cdot 10^9$ 内前 12 个素数的积就已经超出 $N$ 的范围, 所以打个表然后直接爆搜即可.\n(亏我想了半天要怎么转化, 完全没考虑只有 12 个素数会被用到)\n最大公约数 左转 gcd \u0026 lcm 复习笔记\n高精度 $\\gcd{(a, b)}$ 更相减损术适用于大整数下求 $\\gcd(a, b)$\n$a\u003cb$ 时, $\\gcd(a, b)=\\gcd(b, a)$ $a=b$ 时, $\\gcd(a, b)=a$ $a, b$ 同为偶数时, $\\gcd(a, b)=2\\gcd(\\frac{a}{2}, \\frac{b}{2})$ $a$ 为偶数, $b$ 为奇数时, $\\gcd(a, b)=\\gcd(\\frac{a}{2}, b)$ $a$ 为奇数, $b$ 为偶数时, $\\gcd(a, b)=\\gcd(a, \\frac{b}{2})$ $a, b$ 同为奇数时, $\\gcd(a, b)=\\gcd(b, a-b)$ 容斥原理 原理很简单, 记住一个公式即可\n$$|\\cap A_i|=\\sum_{1\\le i\\le m}|A_i|-\\sum_{1\\le i\u003c j\\le m}|A_i\\cap A_j|+\\sum_{1\\le i\u003cj\u003ck\\le m}|A_i\\cap A_j\\cap A_k|-\\cdots+(-1)^{m+1}\\sum|A_1\\cap A_2\\cap\\cdots\\cap A_m|$$\n错排问题 利用容斥原理求解\n令集合 $S$ 表示 $1,2, \\cdots, n$ 的全排列, 则 $|S|=n!$\n设子集 $S_i$ 表示 $i$ 排在第 $i$ 位的排列, 则 $|S_i|=(n-1)!$\n同理, 设 $S_{i_1}\\cap S_{i_2}\\cap\\cdots\\cap S_{i_k}$ 表示 $i_1, i_2, \\cdots, i_k$ 这 $k$ 个数排在相应位置的排列数, 则 $|S_{i_1}\\cap S_{i_2}\\cap\\cdots\\cap S_{i_k}|=(n-k)!$\n每个元素都不排在自己位置的排列数为 $D_n=|\\overline{S_1}\\cap\\overline{S_2}\\cap\\cdots\\cap\\overline{S_n}|=|S|-|S_1\\cup S_2\\cup\\cdots\\cup S_n|$\n由容斥原理可得\n$$D_n=n!(1-\\frac{1}{1!}+\\frac{1}{2!}-\\frac{1}{3!}+\\cdots\\pm\\frac{1}{n!})$$\n递推公式\n推导过程并不难想, 懒得写了, 直接上公式\n$$D_n=(n-1)(D_{n-1}+D_{n-2})$$\n欧拉函数 若 $\\gcd{(a, b)}=1$ , 则称 $a, b$ 互质(互素), 记作 $a\\bot b$ 欧拉函数 $\\varphi(n)$ 定义为 $[1, n]$ 中与 $n$ 互质的数的个数. 若 $n$ 为素数, 则 $\\varphi(n)=n-1$ 容斥原理求欧拉函数 根据整数惟一分解定理, 将 $N$ 分解为\n$$N=p_1^{r_1}p_2^{r_2}\\cdots p_k^{r_k}$$\n设 $[1, n]$ 中 $p_i$ 的倍数的集合为 $A_i$ , 则 $|A_i|=\\lfloor \\frac{N}{p_i}\\rfloor$\n对于 $p_i\\not=p_j$ , 有 $|A_i\\cap A_j|=\\lfloor\\frac{N}{p_ip_j}\\rfloor$\n根据容斥原理,\n$$\\begin{aligned}\\varphi(N)\u0026=|A|-|\\overline{A_1}\\cup\\overline{A_2}\\cup\\cdots\\cup\\overline{A_k}| \\\\ \u0026=N-(\\frac{N}{p_1}+\\frac{N}{p_2}+\\cdots+\\frac{N}{p_k})+(\\frac{N}{p_1p_2}+\\cdots+\\frac{N}{p_1p_k})-\\cdots\\pm\\frac{N}{p_1p_2\\cdots p_k} \\\\ \u0026=N(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\cdots(1-\\frac{1}{p_k})\\end{aligned}$$\n素因数分解求欧拉函数的算法 时间复杂度: $\\mathcal{O}(\\sqrt{n})$\n1 2 3 4 5 6 7 8 9 10 int euler_phi(int n) { int ret = n; for (int i = 2; i * i \u003c= n; ++i) if (n % i == 0) { ret = ret / i * (i - 1);//先除后乘可以一定程度上避免爆 int while (n % i == 0) n /= i; } if (n \u003e 1) ret = ret / n * (n - 1); return ret; } 埃氏筛法预处理欧拉函数值 时间复杂度: $\\mathcal{O}(n\\log{\\log{n}})$\n1 2 3 4 5 6 7 8 9 10 11 int phi[N]; void euler_phi(int n) { for (int i = 2; i \u003c= n; ++i) phi[i] = i; for (int i = 2; i * i \u003c= n; ++i) if (phi[i] == i) { phi[i] = i - 1; for (int j = i; j \u003c= n; j += i)//注意这里 j 的起点是 i 而不是 i * i phi[j] = phi[j] / i * (i - 1); } } 欧拉函数的性质 若 $a\\bot b$ , 则 $\\varphi(a)\\varphi(b)=\\varphi(ab)$ , 即欧拉函数具有积性函数的性质.\n上式分别将 $a, b$ 用整数惟一分解定理表示, 然后带入欧拉函数计算式即可得到证明.\n例题 「POJ 3090」Visible Lattice Points\n设某点坐标为 $(x_0, y_0)$ , 若该点能被看见, 则这个点一定是直线 $y=\\frac{y_0}{x_0}x$ 上距离原点最近的一个整数点.\n我们设一点 $(x_1, y_1)$ 满足 $\\frac{y_1}{x_1}=\\frac{y_0}{x_0}, x_1\u003ex_0$ , 则该点显然不可见, 从这个式子中我们可以知道, $x_1, y_1$ 必然存在一个公约数, 而 $x_0, y_0$ 不存在公约数, 即 $x_0, y_0$ 互质, 因此可见点就是图中所有满足 $x_0, y_0$ 互质的点再加上 $(1, 0), (0, 1), (1, 1)$ .\n固定 $y=y_0$ , 当 $x\u003cy_0$ 时, 满足条件的点的数量就是 $\\varphi(y_0)$ , 当 $x\u003ey_0$ 时, 将点 $(x, y_0)$ 以 $y=x$ 对称过去得到的点就是固定 $x=x_i$ 时 $y\u003cx_i$ 的情况, 根据坐标轴关于 $y=x$ 对称的性质, $x\u003cy_0$ 和 $x\u003ey_0$ 两种情况下的答案数相等, 所以我们只需考虑 $x\u003cy_0$ 的情况, 然后乘 2 即可.\n最终的答案为: $3+2\\cdot\\sum_{i=2}^N \\varphi(i)$\n「Luogu P2303」Longge 的问题\n考虑满足 $\\gcd(i, n)=d$ 的 $i$ 的个数.\n由 $\\gcd(i, n)=d$ 可以推出 $\\gcd(\\frac{i}{d}, \\frac{n}{d})=1$, 即 $\\frac{i}{d}, \\frac{n}{d}$ 互质, 又 $\\frac{i}{d}\u003c\\frac{n}{d}$ , 所以这样的 $\\frac{i}{d}$ 的个数为 $\\varphi(\\frac{n}{d})$ , 也就是 $i$ 的个数为 $\\varphi(\\frac{n}{d})$\n所以答案为 $\\sum_{d|n}d\\varphi(\\frac{n}{d})$\n同余 剩余系 剩余系指模正整数 $n$ 的余数所组成的集合. 完全剩余系: 如果一个剩余系中包含了这个正整数 $n$ 所有可能的余数 ($0, 1, \\cdots, n-1$) , 那么就称它为模 $n$ 的一个完全剩余系, 记作 $Z_n$ . 简化剩余系:完全剩余系中与 $n$ 互质的数的集合, 记作 $Z_n^*$ . 同余等价类: $Z_n$ 里的每一个元素代表所有模 $n$ 意义下与它同余的整数, 我们把满足同余关系的所有整数看作一个同余等价类. 在 $Z_n$ 中的四则运算结果全部都要在模 $n$ 意义下. 模运算 如果 $a\\equiv b\\pmod{m}$ 且有 $c\\equiv d\\pmod{m}$ , 那么:\n$$a+c\\equiv b+d\\pmod{m}$$\n$$a-c\\equiv b-d\\pmod{m}$$\n$$a\\times c\\equiv b\\times d\\pmod{m}$$\n$$(a+b)\\bmod m=((a\\bmod m)+(b\\bmod m))\\bmod m$$\n$$(a-b)\\bmod m=((a\\bmod m)-(b\\bmod m)+m)\\bmod m$$\n$$(a\\times b)\\bmod m=((a\\bmod m)\\times(b\\bmod m))\\bmod m$$\n快速幂 右转 快速幂复习笔记\n费马小定理 若 $p$ 为素数, 且 $a\\bot p$ , 则 $a^{p-1}\\equiv 1\\pmod{p}$ .\n因为 $p$ 为素数, 则 $2, 3, \\cdots, p-1$ 与 $p$ 互质, 且不存在两个数模 $p$ 同余.\n又 $a\\bot p$ , 所以 $a, 2a, 3a, \\cdots, (p-1)a$ 与 $p$ 互质, 且不存在两个数模 $p$ 同余.\n因此 $a\\cdot 2a\\cdot 3a\\cdots(p-1)a=(p-1)!a^{p-1}$ 与 $p$ 互质, 且 $(p-1)!a^{p-1}\\equiv (p-1)!\\pmod{p}$\n两边同时除以 $(p-1)!$ 得到 $a^{p-1}\\equiv 1\\pmod{p}$\n费马小定理的另一种形式: 若 $p$ 为素数, 则对任意正整数 $a$ 有 $a^p\\equiv a\\pmod{p}$. 应用: $p$ 是素数, $a, p$ 互质, 则 $a^b\\bmod{p}= a^{b\\bmod (p-1)}\\bmod{p}$ . 费马小定理判断素数 多次选取 $a$ 来判断 $p$ 是否满足费马小定理, 正确的概率随 $a$ 选取的次数的增加而增加. 时间复杂度: 设选取 $k$ 次 $a$ , 每次用快速幂处理的时间为 $\\mathcal{O}(\\log{p})$ , 则总时间复杂度为 $\\mathcal{O}(k\\log{p})$ . 由于存在 Carmichael 数, 因此上述算法存在缺陷, 即存在合数满足费马小定理. $10^4$ 以内的 Carmichael 数有: 561, 1105, 1729, 2465, 2821, 6601, 8911. 欧拉定理 (在 $p$ 不是素数的情况下, 可以使用欧拉定理)\n对于和 $m$ 互素的 $a$ , 有: $a^{\\varphi(m)}\\equiv1\\pmod{m}$ .\n证明方法和费马小定理差不多.\n引理: 若 $a, m$ 互质, 满足 $a^x\\equiv 1\\pmod{m}$ 的最小正整数 $x_0$ 是 $\\varphi(m)$ 的约数.\n欧拉定理的推论 $a, m(m\u003e1)$ 互素, 则有 $a^b\\bmod{m}=a^{b\\bmod\\varphi(m)}\\bmod m$ .\n例题 「POJ 3696」The Luckiest number\n设 $n$ 个 8 连在一起的正整数为 $A_n$ , 则 $A_n=10A_{n-1}+8$ , 容易求得 $A_n=\\frac{8}{9}(10^n-1)$ .\n若 $L|A_n$ , 即 $L|\\frac{8}{9}(10^n-1)$, 可以得到 $9L|8(10^n-1)$ , 令 $d=\\gcd(9L, 8)$ , 则有 $\\frac{9L}{d}|(10^n-1)$\n于是 $10^n\\equiv 1\\pmod{\\frac{9L}{d}}$\n根据欧拉定理的引理, 只需求出 $\\varphi(\\frac{9L}{d})$ , 然后枚举它的约数, 一一验证后取最小的一个数即可.\n时间复杂度: $\\mathcal{O}(\\sqrt{L}\\log{L})$\n扩展欧几里得算法 裴蜀定理 ( Bézout 定理 ) 对任何整数 $a, b$ , 关于未知数 $x, y$ 的线性不定方程 ( 称为裴蜀等式 ) $ax+by=c$ 有整数解当且仅当 $c$ 为 $\\gcd{(a, b)}$ 的倍数.\n裴蜀等式有解时必有无穷多个解.\n推论: $a, b$ 互素等价于 $ax+by=1$ 有整数解.\n例题 「BZOJ 1441」Min\n假设 $S$ 已知, 于是有方程 $A_1x_1+A_2x_2+\\cdots+A_nx_n=S$\n根据裴蜀定理, $S$ 必然是 $\\gcd{(A_1, A_2, \\cdots, A_n)}$ 的倍数, 取 $S_{min}=\\gcd{(A_1, A_2, \\cdots, A_n)}$ 即可.\n扩展欧几里得算法 见 gcd \u0026 lcm 复习笔记\n根据裴蜀定理, $ax+by=\\gcd{(a, b)}$ 有无穷组解, 而扩展欧几里得算法求出来的只是其中一组特解 $(x_0, y_0)$ .\n下面考虑求 $ax+by=c$ 的一般解.\n首先设 $c=t\\gcd(a, b)$ ( $t$ 为整数 ) , 则使用扩展欧几里得算法求出 $ax+by=\\gcd{(a, b)}$ 的特解 $(x_0, y_0)$ 后, 容易得到 $ax+by=c$ 特解为 $(tx_0, ty_0)$ .\n由于之后考虑的是 $ax+by=c$ , 所以后面用 $(x_0, y_0)$ 代替 $(tx_0, ty_0)$ .\n将方程的所有解按照 $x$ 的大小排序, 则特解后的下一组解 $(x_1, y_1)$ 可以表示为 $(x_0+d_1, y_0+d_2)$ , 其中 $d_1$ 为满足条件的最小正整数.\n带入方程后得到 $ad_1+bd_2=0$ , 变形后有 $-\\dfrac{d_1}{d_2}=\\dfrac{b}{a}=\\dfrac{\\frac{b}{\\gcd{(a, b)}}}{\\frac{a}{\\gcd{(a, b)}}}$ .\n因此方程的一般解可以表示为 $\\left(x_0+k\\dfrac{b}{\\gcd{(a, b)}}, y_0-k\\dfrac{a}{\\gcd{(a, b)}}\\right)(k\\in \\mathbf{Z})$ .\n为什么这里要将 $\\dfrac{b}{a}$ 再变形为 $\\dfrac{\\frac{b}{\\gcd{(a, b)}}}{\\frac{a}{\\gcd{(a, b)}}}$ 呢?\n因为 $\\frac{b}{a}$ 不是最简分数, 这一步变形是化简 $\\frac{b}{a}$ , 直接用 $(x_0+kb, y_0-ka)$ 来表示特解的话会漏掉一些情况, 如 $(x_0+\\frac{b}{\\gcd{(a, b)}}, y_0-\\frac{a}{\\gcd{(a, b)}})$ 就不能被 $(x_0+kb, y_0-ka)$ 表示.\n逆元 模 $n$ 意义下乘法的逆 如果在 $Z_n$ 中两元素 $a, b$ 满足 $a\\cdot b=1$ , 那么我们就说 $a, b$ 互为模 $n$ 意义下乘法的逆元, 记作 $a=b^{-1}, b=a^{-1}$ .\n逆元 当 $a, m$ 互素的时候, 若 $ax\\equiv 1\\pmod{m}$ , 则称 $x$ 为 $a$ 关于模 $m$ 的逆元, 记作 $a^{-1}$ .\n在 $[0, m)$ 的范围内, 逆元是唯一的.\n求解逆元 求解逆元等价于解方程 $ax+my=1$\n直接使用扩展欧几里得算法即可.\n欧拉定理求逆元 因为 $a, m$ 互素, 根据欧拉定理, 有 $a\\cdot a^{\\varphi(m)-1}\\equiv 1\\pmod{m}$ , 因此 $a^{\\varphi(m)-1}$ 为所求逆元.\n线性求逆元: 递推法 递推法求解 $1\\sim n$ 的逆元.\n假设当前求解的是 $i$ 关于模 $p$ 的逆元.\n根据带余除法, $p=iq+r$ , 两边分别对 $p$ 取模得到 $iq+r\\equiv 0\\pmod{p}$\n若 $i$ 不为 $p$ 的倍数, 则 $r$ 不为 0 , 因此 $r^{-1}$ 存在.\n在上式两边乘 $i^{-1}r^{-1}$ 得到 $qr^{-1}+i^{-1}\\equiv 0\\pmod{p}$ , 即\n$$r^{-1}\\equiv -qr^{-1}=-r^{-1}\\left\\lfloor \\dfrac{p}{i}\\right\\rfloor\\pmod{p}$$\n为了防止答案为负数, 使用 $r^{-1}(p-\\left\\lfloor \\frac{p}{i}\\right\\rfloor)$ 代替 $-r^{-1}\\left\\lfloor \\frac{p}{i}\\right\\rfloor$ .\n时间复杂度: $\\mathcal{O}(n)$\n1 2 3 inv[1] = 1; for (int i = 2; i \u003c= n; ++i) inv[i] = inv[p % i] * (p - p / i) % p; 线性求逆元: 倒推法 先直接求解 $n!$ 的逆元, 然后利用 $((n-1)!)^{-1}\\equiv(n!)^{-1}\\cdot n\\pmod{p}$ 倒推求得 $1!\\sim (n-1)!$ 的逆元.\n接着再利用 $n^{-1}\\equiv (n!)^{-1}\\cdot (n-1)!\\pmod{p}$ 求解 $1\\sim n$ 的逆元.\n例题 「POJ 1845」Sumdiv\n首先利用整数惟一分解定理将 $A$ 表示为 $A=p_1^{r_1}p_2^{r_2}\\cdots p_n^{r_n}$ .\n则 $A^B$ 约数和为\n$$(1+p_1+p_1^2+\\cdots +p_1^{B\\cdot r_1})(1+p_2+p_2^2+\\cdots+p_2^{B\\cdot r_2})\\cdots(1+p_n+p_n^2+\\cdots+p_n^{B\\cdot r_n})$$\n可以发现, 每一个括号里都是一个等比数列求和, 以 $p_i$ 为例, 它的和可以写成 $\\dfrac{p_i^{B\\cdot r_i+1}-1}{p_i-1}$ , 然后我们可以利用快速幂求解分子 $p_i^{B\\cdot r_i+1}\\bmod{9901}$ , 这时若 $p_i-1\u003e(p_i^{B\\cdot r_i+1}-1)\\bmod{9901}$ , 我们会得到 $0$ , 这显然是错的, 而模数 $9901$ 正好为素数, 因此考虑用 $p_i-1$ 的逆元与分子的结果相乘来代替除法.\n当 $p_i-1$ 为 $9901$ 的倍数时不存在逆元, 这时我们可以发现 $p_i\\equiv 1\\pmod{9901}$ , 因此 $1, p_i, p_i^2, \\cdots, p_i^{B\\cdot r_i+1}\\equiv 1\\pmod{9901}$ , 所以 $1+p_i+p_i^2+\\cdots+p_i^{B\\cdot r_i}\\equiv B\\cdot r_i+1\\pmod{9901}$ .\n线性同余方程 形如 $ax\\equiv c\\pmod{m}$ 的方程，称为线性同余方程。\n朴素算法 将 $x=1, 2, \\cdots, m-1$ 一次带进去验证即可，这个朴素算法的复杂度取决于 $m$ 。 扩展欧几里得算法 可以将方程看作 $ax+my=c$ ，然后利用扩展欧几里得方法求解。 根据裴蜀定理，当且仅当 $\\gcd{(a, m)}|c$ 时方程有解。 令 $d=\\gcd(a, m)$ ，则方程一共有 $d$ 个解，我们用扩展欧几里得算法求得特解 $x_0$ ，则方程的通解 $x_i=x_0+i\\cdot \\dfrac{m}{d}(i=0, 1, \\cdots, d-1)$ 。 欧拉定理 令 $d=\\gcd{(a, m)}$ ，若 $d \\nmid c$ 则方程无解。 然后令 $a'=\\dfrac{a}{d}, c'=\\dfrac{c}{d}, m'=\\dfrac{m}{d}$ ，则 $\\gcd{(a', m')}=1$ ，原方程变为 $a'x\\equiv c'\\pmod{m'}$ ，由欧拉定理，$a'^{\\varphi(m')}\\equiv 1\\pmod{m'}$ ，在方程两边分别乘上上式，得到 $a'x\\equiv c'a'^{\\varphi(m')}\\pmod{m'}$ ，即 $x\\equiv c'a'^{\\varphi(m')-1}\\pmod{m'}$ ，于是我们得到原方程的特解 $x_0=dc'a'^{\\varphi(m')-1}$ ，因此原方程的解为 $x_i=x_0+i\\cdot m’(i=1, 2, \\cdots,d-1)$ 。 例题 线性组合\n对应整数数列 $A_1, A_2, \\cdots, A_n$ 是否存在 $X_1, X_2, \\cdots, X_n$ ， 使得 $A_1X_1+A_2X_2+\\cdots+A_nX_n=C$ ，其中 $\\gcd{(A_1, A_2, \\cdots, A_n)}\\mid C(n\\ge2)$ 。如有，请找出一组整数解 $(x_1, x_2, x_3, x_4)$ 满足 $12x_1+24x_2+18x_3+15x_4=3$ .\n题中的方程是 n 元形式的扩展欧几里得方程，我们尝试将 n 元逐步降为二元得到最终解。\n设 $d=\\gcd{(A_1, A_2, \\cdots, A_n)}$ ，令 $C'=\\dfrac{C}{d},A_i'=\\dfrac{A_i}{d}(i=1, 2, \\cdots, n)$ ，首先将方程变形为 $A_1'X_1+A_2'X_2+\\cdots+A_n'X_n=C'$ ，此时满足 $\\gcd{(A_1', A_2', \\cdots, A_n', C')}=1$ 。\n然后我们考虑求解方程 $A_1'X_1+\\gcd(A_2', A_3', \\cdots, A_n')Y_1=C'$ ，利用扩展欧几里得方法求得特解 $X_1,Y_1$ ，由于题中仅要求得到一组解，因此我们只取特解即可，然后再以同样的方法求解 $A_2'X_2+A_3'X_3+\\cdots+A_n'X_n=\\gcd(A_2', A_3', \\cdots, A_n')Y_1$ 便可以实现逐渐降元了。\n线性同余方程组（模互素） 考虑形如 $x\\equiv a_i\\pmod{m_i}$ 的若干个线性同余方程联合得到的方程组，例如 $$ \\begin{cases} x \u0026\\equiv\u0026 2\\pmod{3} \\\\ x \u0026\\equiv\u0026 3\\pmod{5} \\\\ x \u0026\\equiv\u0026 5\\pmod{7} \\end{cases} $$ 一种可行的解法是令 $x=3y+2$ ，然后将方程 $(2)$ 改写成 $y\\equiv 2\\pmod{5}$ ，接着再令 $y=5z+2$ 代入方程 $(3)$ 得到 $z\\equiv 4\\pmod{7}$ ，再令 $z=7k+4$ ，最后我们可以得到解 $x\\equiv68\\pmod{105}$ 。\n中国剩余定理 若线性同余方程组 $x\\equiv a_i\\pmod{m_i}(i=1, \\cdots, n)$ 的模数 $m_i$ 两两互素，则 $x$ 在 $\\bmod{M}(M=\\prod_{i=1}^n m_i)$ 下有唯一解。\n令 $M_i=\\dfrac{M}{m_i}$ ，有 $\\gcd{(M_i, m_i)}=1$ ，因此 $M_i$ 在 $\\bmod{m_i}$ 下的逆元存在，设其为 $t_i$ ，于是有 $a_iM_it_i\\equiv a_i\\pmod{m_i},a_iM_it_i\\equiv0\\pmod{m_j}(j\\not= i)$ 。\n可以得到解 $x\\equiv\\sum_{i=1}^na_iM_it_i\\pmod{M}$ 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //China Remainer Theorem int CRT(const int a[], const int m[], int n) { int M = 1, ret = 0; for (int i = 1; i \u003c= n; ++i) M *= m[i]; for (int i = 1; i \u003c= n; ++i) { int ti = getinv(m[i], a[i]), Mi = M / m[i]; ret = (ret + a[i] * ti * Mi % M) % M; } return ret; } //利用 exgcd 求逆元 int getinv(int a, int b) { int x, y; exgcd(a, b, x, y); return x; } 线性同余方程组（模不互素） 对于模不互素的线性同余方程组 $$ \\begin{cases} x \u0026\\equiv a_1\\pmod{m_1} \\\\ x \u0026\\equiv a_2\\pmod{m_2} \\\\ \u0026\\cdots \\\\ x \u0026\\equiv a_n\\pmod{m_n} \\end{cases} $$\n考虑求解方程数量为 2 的情形，当方程数量大于 2 时迭代求解。\n$$ \\begin{cases} x \u0026\\equiv a_1\\pmod{m_1} \\\\ x \u0026\\equiv a_2\\pmod{m_2} \\end{cases} $$ 设 $y=x-a_1$ ，则方程组变为 $$ \\begin{cases} y \u0026\\equiv 0 \u0026\\pmod{m_1} \\\\ y \u0026\\equiv a_2-a_1 \u0026\\pmod{m_2} \\end{cases} $$ 设 $d=\\gcd{(m_1, m_2)}$ ，根据裴蜀定理，若 $d \\nmid (a_2-a_1)$ ，则方程组无解，否则令 $y'=\\dfrac{y}{d},a'=\\dfrac{a_2-a_1}{d}, m_i'=\\dfrac{m_1}{d}(i=1,2)$ ，有 $$ \\begin{cases} y' \u0026\\equiv{0} \u0026\\pmod{m_1’} \\\\ y' \u0026\\equiv{a'} \u0026\\pmod{m_2’} \\end{cases} $$ 此时 $\\gcd{(m_1', m_2')}=1$ ，令 $y'=km_1'$ ，再由欧拉定理可得 $k\\equiv{a'm_1'^{\\varphi(m_2')-1}}\\pmod{m_2'}$ ，于是 $y\\equiv{da'm_1'^{\\varphi{(m_2')}}}\\pmod{dm_1'm_2'}$ ，最后代回去可以得到 $x\\equiv{(a_2-a_1)m_1'^{\\varphi{(m_2')}}+a_1}\\pmod{dm_1'm_2'}$ 。\n例题 「POJ 2891」Strange Way to Express Integers\n算法和上述一致。\n假设我们已经通过迭代求解得到前 $k-1$ 个方程的一个解 $x_0$ ，令 $M=\\prod_{i=1}^{k-1}m_i$ ，则 $x=x_0+i\\cdot M$ 是前 $k-1$ 个方程的通解。\n考虑第 $k$ 个方程，我们可以将其改写为 $x_0+t\\cdot M\\equiv{a_k}\\pmod{m_k}$ ，即 $t\\cdot M\\equiv{a_k-x_0}\\pmod{m_k}$ ，接下来找到一个合适的 $t$ 即可，也就是求解一个同余方程了，利用欧拉定理求解即可。\n高次同余方程 第一类高次同余方程 形如 $a^x\\equiv{b}\\pmod{p}$ 的方程称为第一类高次同余方程，其中 $\\gcd(a, p)=1$ 。\nBSGS 解决这一类方程主要采用 BSGS (Baby Step Giant Step) 算法。\n将 $x$ 写成 $x=kt-m(0\\le m\\le t-1)$ 的形式，则原方程可变形为 $(a^t)^k\\equiv{b\\cdot a^m\\pmod{p}}$ 。\n假设 $t$ 已知，那么我们只需枚举 $k$ ，然后计算相应的 $b\\cdot a^m$ ，判断是否满足变形后的等式即可。\n因为在枚举 $k$ 的过程中 $m$ 的取值也在变化，但 $m$ 的取值范围是不变的，因此我们可以预处理所有可能的 $b\\cdot a^m$ 值，用一个 Hash 表储存。\n由欧拉定理可知，有 $a^{\\varphi(p)}\\equiv{1}\\pmod{p}$ ，而 $\\varphi(p)\u003cp$ ，因此从 1~p ，模 $p$ 意义下 $a$ 的幂至少完成了一次循环，所以最小整数解 $x\u003cp$ ，进而我们可以从 $0$ 到 $\\dfrac{p}{t}$ 枚举 $k$ ，而 $m\\in[0,t-1]$ ，因此时间复杂度为 $\\mathcal{O}(\\dfrac{p}{t}+t)$ ，当 $t=\\sqrt{p}$ 时复杂度最小。\n时间复杂度：$\\mathcal{O}(2\\sqrt{p})$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int BSGS(int a, int b, int p) { b %= p; if (a % p == 0) return b ? 1 : -1; map \u003cint, int\u003e hash; int t = sqrt(p) + 1; for (int i = 0; i \u003c t; ++i) { int val = (long long)b * power(a, i, p) % p;//快速幂 hash[val] = i; } a = power(a, t, p); for (int i = 0; i \u003c= t; ++i) { int val = power(a, i, p); int j = hash.find(val) == hash.end() ? -1 : hash[val]; if (j \u003e= 0 \u0026\u0026 i * t - j \u003e= 0) return i * t - j; } return -1; } 第二类高次同余方程 形如 $x^k\\equiv{b}\\pmod{p}$ 的方程称为第二类高次同余方程。\n首先引入阶和原根的概念，这一部分和抽象代数相关，我目前还不会 QAQ 。\n阶 满足同余式 $a^n\\equiv{1}\\pmod{p}$ 的最小整数 $n$ 称为 $a$ 模 $p$ 的阶，记作 $\\delta_p(a)$ 。\n由欧拉定理可知，当 $\\gcd(a, p)=1$ 时，有 $a^{\\varphi(p)}\\equiv{1}\\pmod{p}$ ，因此阶的存在性得证。\n性质 1 ：$a,a^2,\\cdots,a^{\\delta_p(a)}$ 模 $m$ 两两不同余。\n性质 2 ：若 $a^n\\equiv{1}\\pmod{p}$ ，则 $n \\mid \\delta_p(a)$ 。\n​\t推论 ：若 $a^m\\equiv{a^n}\\pmod{p}$ ，则 $m\\equiv{n}\\pmod{\\delta_p(a)}$ 。\n性质 3 ：设 $p\\in\\mathbb{N}^*,, a,b\\in\\mathbb{Z},\\gcd(a,p)=\\gcd(b,p)=1$ ，则 $\\delta_p(ab)=\\delta_p(a)\\delta_p(b)$ 的充要条件是 $\\gcd(\\delta_p(a),\\delta_p(b))=1$ 。\n性质 4 ：设 $k\\in\\mathbb{N},p\\in\\mathbb{N}^*,a\\in\\mathbb{Z},\\gcd(a,p)=1$ ，则 $\\delta_p(a^k)=\\dfrac{\\delta_p(a)}{\\gcd(\\delta_p(a),k)}$ 。\n原根 设 $p\\in\\mathbb{N}^*,a\\in\\mathbb{Z}$ ，若 $\\gcd(a,p)=1$ ，且 $\\delta_p(a)=\\varphi(p)$ ，则称 $a$ 为模 $m$ 的原根。\n以下基于 $p$ 为质数的情况进行讨论。\n如何判断 $a$ 是否是 $p$ 的原根？\n由费马小定理，方程 $a^x\\equiv{1}\\pmod{p}$ 的一个解为 $x=p-1$ ，因此最小整数解 $x_{min}\\mid (p-1)$ ，而满足 $x_{min}=p-1$ 的整数 $a$ 是 $p$ 的原根，所以我们逐个枚举 $p-1$ 的约数 $k$ ，如果只有当 $k=p-1$ 时满足 $a^k\\equiv{1}\\pmod{p}$ ，则 $a$ 是 $p$ 的原根。\n下面考虑求解 $x^k\\equiv{b}\\pmod{p}$ 。\n由阶的性质 1 ，存在唯一的正整数 $m$ ，满足 $a^m\\equiv{b}\\pmod{p},0\\le m\\le p-1$ ，其中 $a$ 是 $p$ 的原根，$m$ 可以由第一类高次同余方程求出。\n同样，存在唯一正整数 $y$ ，使得 $x\\equiv{a^y}\\pmod{p}$ ，于是上述方程变为 $a^{ky}\\equiv{a^m}\\pmod{p}$ 。\n由阶的性质 2 的推论，$ky\\equiv{m}\\pmod{p-1}$ ，于是我们求解这个线性同余方程得到 $y$ 便可以得到 $x$ 。\n","description":"旧文搬运","tags":["Math","Number Theory"],"title":"基础数论复习","uri":"/posts/basic-number-theory/"},{"categories":["Algorithm"],"content":"Miller Rabin 定理是一种素性测试方法，其中利用到了素数的一些性质，还有费马小定理，以及二次探测定理。\n素数的一些性质 我们首先看一下素数的 4 条有趣的性质：\n不存在最大的素数 假设最大的素数为 $p_k$ ，小于它的所有素数为 $p_1, p_2, \\dots, p_{k-1}$ ，那么我们可以构造出数 $p_1p_2\\cdots p_k+1$ ，它不能被 $p_1, \\cdots, p_k$ 中的任何一个数整除，故它是素数，又它显然大于 $p_k$ ，于是可以得出不存在最大的素数。\n相邻素数之间的间隔任意大\n考虑数 $a$ 满足 $0\\le a\\le n$ ，那么 $n!+a$ 一定能被 $a$ 整除，因此长度为 $n$ 的数列 $n!,n!+2, \\cdots, n!+n$ （注意没有 $n!+1$ ）都是合数，由于 $n$ 可以任意大，所以相邻素数之间的间隔可以任意大。\n所有大于 2 的素数都可以被唯一的表示为两个平方数之差\n所有大于 2 的素数都是奇数，假设它是 $2n+1$ ，那么它可以被表示为 $(n+1)^2-n^2$ 。\n下面证明这种表示法是唯一的。假设素数 $p$ 可以被表示为 $a^2-b^2$ ，即 $p=(a+b)(a-b)$ ，因为 $p$ 是素数，所以只能有 $a-b=1,a+b=p$ ，得证。\n当 $n$ 为大于 2 的整数时，$2^n+1$ 和 $2^n-1$ 两个数中，如果其中一个数是素数，那么另一个数一定是合数\n显然 $2^n\\nmid 3(n\u003e2)$ ，如果 $2^n\\equiv 1\\pmod{3}$ ，那么 $(2^n-1)\\mid 3$ 为合数；如果 $2^n\\equiv 2\\pmod{3}$ ，那么 $(2^n+1)\\mid 3$ 为合数。\nFermat 素性测试 回顾一下费马小定理：\n若 $p$ 为素数，且 $a\\bot p$ ，那么有 $a^{p-1}\\equiv 1\\pmod{p}$ 。\n根据费马小定理，我们很容易想到能不能利用它的逆定理来判定素数呢？很遗憾，费马小定理的逆定理是伪的。\n人们用伪素数来称呼满足费马小定理的合数，如果是令 $a=2$ 的情况下的伪素数，就叫它以 2 为底的伪素数，其他取值情况下的名字以此类推。\n为了提高这个素数测试的正确率，一个很自然的想法就是多次选取 $a$ 来判断，一旦不满足费马小定理就判定它为合数，显然正确率随 $a$ 的选取次数的增加而增加。我们随机选取若干个小于 $n$ 的数来作为 $a$ 的取值进行测试，这个判定素数的方法就是所谓的 Fermat 素性测试。\n然而不幸的是，存在 Carmichael 数，它们满足当 $a$ 取遍所有小于 $n$ 的数时都满足费马小定理，自身却是合数。\n二次探测定理 要继续加强素数的判定方法，就轮到二次探测定理出场了。\n当需要判定的数 $n\u003e2$ 时，显然 $n-1$ 是偶数，如果小于 $n$ 的数 $a$ 满足 $a^{n-1}\\equiv 1\\pmod{n}$ ，那么 $a^{n-1}-1=(a^{\\frac{n-1}{2}}+1)(a^{\\frac{n-1}{2}}-1)\\mid n$ ，若 $n$ 为素数，则 $a^{\\frac{n-1}{2}}\\equiv n-1\\pmod{n}$ 或 $a^{\\frac{n-1}{2}}\\equiv n+1\\pmod{n}$ ，我们可以利用这一性质来继续加强素数的判定。\n二次探测定理就是指，如果 $p$ 是奇素数，那么对于正整数 $x$ ，若 $x^2\\equiv1\\pmod{p}$ ，则 $x\\equiv1\\pmod{p}$ 或 $x\\equiv p-1\\pmod{p}$ 。\nMiller Rabin 素性测试 Miller Rabin 素性测试综合以上方法，不断提取 $n-1$ 的因子 2 ，将 $n-1$ 表示为 $d\\times2^r$ 的形式（其中 $d$ 为奇数），首先得到 $a^d$ ，然后不断将其平方直到变为 $a^{n-1}$ ，每次平方后首先测试是否满足 $(a^{d\\times 2^s})^2\\equiv 1\\pmod{n}$ ，看是否满足二次探测定理的条件，如果满足就立即判断是否满足它的结论，一旦不满足就判断 $n$ 为合数。\nMiller Rabin 素性测试也是不确定算法，我们可以把以 $a$ 为底的满足 Miller Rabin 素性测试的合数称为以 $a$ 为底的强伪素数。第一个以 2 为底的强伪素数是 2047 ，而第一个以 2 和 3 为底的强伪素数则大到了 1 373 653 。\n对于大数的 Miller Rabin 测试，底数一般是随机选取，但是当待测数不太大时，底数的选取就有一些技巧了。如，当 $n\u003c4,759,123,141$ 时，选取 $2,7,61$ 进行测试即可。随机选取 $k$ 个底数进行测试的失误率大概是 $4^{-k}$ 。\n另外还有第一个多项式的、确定的、无需其它条件的素性判断算法 AKS 算法，之后有空可以了解一下。\nMiller Rabin 的一点小优化：当某一次平方后得到 $a^{d\\times 2^s}\\equiv n-1\\pmod{n}$ ，那么之后所有的平方操作都会得到 1 ，可以直接通过此次测试。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 bool MillerRabin(int n, int t = 8) { if (n \u003c 3 || n % 2 == 0) return false;\t// n = 2 时虽然是素数，但是不满足 MillerRabin 素性测试的条件 int d = n - 1, r = 0; while (d % 2 == 0) d \u003e\u003e= 1, r++; while (t--) {\t// t 为测试次数，最好大于 8 int a = rand() % (n - 2) + 2, s;\t//为了不让 a = 1 ，所以最后是 +2 int u = qpow(a, d, n); if (u == 1) continue;\t//此时后面平方总会得到 1 ，必然满足测试，直接跳过 for (s = 0; s \u003c r; ++s) { if (u == n - 1) break;\t//小优化 u = (long long)u * u % n; } if (s == r) return false;\t//如果存在一次平方后不满足条件，s 会增加到 r ，说明此次测试失败 } return true; } 参考：\n数论部分第一节：素数与素性测试 | Matrix67: The Aha Moments\n素数 - OI Wiki (oi-wiki.org)\n","description":"旧文搬运","tags":["Math","Number Theory","Miller Rabin"],"title":"Miller Rabin","uri":"/posts/miller-rabin/"},{"categories":["Math"],"content":" Info\n本文写于 2022 年大一上学期，谢惠民上册的课后练习题大部分都写了，但是很可惜，由于时间原因没能把我认为的一些好题摘录完。\n几个常用初等不等式 关于 Bernoulli 不等式的推广\n（3）证明：若 $a_i\u003e-1(i=1,2,\\cdots,n)$ 且同号，则成立不等式 $$\\prod_{i=1}^n(1+a_i)\\ge1+\\sum_{i=1}^na_i$$\n$\\color{red}{\\textbf{Proof}}$\n构造辅助数列 ${x_n}$ 使 $x_n=\\prod_{i=1}^n(1+a_i)-(1+\\sum_{i=1}^na_i)$\n显然有 $x_1=0$ ，只需证明 ${x_n}$ 为单调递增数列即可.\n$$x_{n+1}-x_n=[\\prod_{i=1}^n(1+a_i)-1]a_{n+1}\\ge0 \\Leftrightarrow x_{n+1}\\ge x_n$$\n则有 $x_n\\ge x_1=0$ ，即 $\\prod_{i=1}^n(1+a_i)\\ge1+\\sum_{i=1}^na_i$\n$\\color{blue}{\\textbf{Thoughts}}$\n在存在多项求和的情况下构造辅助数列可以消除绝大多数项，从而化繁为简，同时也能够利用数列的单调性.\n阶乘 $n!$ 在数学分析以及其他课程中经常出现，以下是几个有关不等式，它们都可以从平均值不等式得到\n（2）利用 $(n!)^2=(1\\cdot n)[2\\cdot (n-1)]\\cdots(n\\cdot 1)$ 证明：当 $n\u003e1$ 时成立 $$n!\u003c\\left(\\frac{n+2}{\\sqrt{6}} \\right)^n $$\n$\\color{red}{\\textbf{Proof}}$\n首先根据提示和不等式中的 $\\sqrt{6}$ 都应该想到将待证不等式平方，有\n$$(n!)^2\u003c\\left(\\frac{n^2+4n+4}{6} \\right)^n$$\n然后对它使用放缩魔法.由于将 $(1\\cdot n)[2\\cdot (n-1)]\\cdots(n\\cdot 1)$ 一项一项地放缩会有较大的误差，所以这里直接将这 n 项一起放缩，得到\n$$(n!)^2=(1\\cdot n)[2\\cdot (n-1)]\\cdots(n\\cdot 1)\\le \\left(\\frac{(1\\cdot n)+[2\\cdot (n-1)]+\\cdots+(n\\cdot 1)}{n}\\right)^n$$\n下面构造辅助数列求解分子的表达式.\n设 $x_n=(1\\cdot n)+[2\\cdot (n-1)]+\\cdots+(n\\cdot 1)$ ，则 $x_1=n$ ，作差得\n$$x_{n+1}-x_n=1+2+\\cdots+n+n+1=\\frac{n^2+3n+2}{2}$$\n累加后得到\n$$x_{n+1}-x_1=\\frac{n^3+6n^2+11n}{6} $$\n于是 $x_n=\\frac{n^3+3n^2+8n-12}{6}$ ，代入上面的式子有\n$$(n!)^2\\le \\left(\\frac{(1\\cdot n)+[2\\cdot (n-1)]+\\cdots+(n\\cdot 1)}{n}\\right)^n=\\left(\\frac{n^3+3n^2+8n-12}{6n}\\right)^n $$\n因为 $\\frac{n^3+3n^2+8n-12}{n}-(n^2+4n+4)=4-(n+\\frac{12}{n})\u003c4-4\\sqrt{3}\u003c0$ ，所以 $n!\u003c\\left(\\frac{n+2}{\\sqrt{6}} \\right)^n$ 成立.\n$\\color{blue}{\\textbf{Thoughts}}$\n这里为什么要将 $n!$ 写成倒序的乘积的形式呢？假如我们将其写成正序的乘积形式，会得到 $(n!)^2\\le \\left(\\frac{1^2+2^2+\\cdots+n^2}{n}\\right)^n$ ，带入平方和公式有 $\\left(\\frac{1^2+2^2+\\cdots+n^2}{n}\\right)^n=\\left[\\frac{(n+1)(2n+1)}{6}\\right]^n$ ，然后我们会发现 $(n+1)(2n+1)\\ge(n+2)^2$ ，这不就放多了嘛.\n于是我们想到排序不等式，逆序和 $\\le$ 正序和，为了使放缩的精度尽量大，所以我们将 $(n!)^2$ 写成逆序的乘积的形式，从而得到一个比 $(n+2)^2$ 小的式子.\n证明下列不等式\n(3) $$\\frac{|a+b|}{1+|a+b|}\\le\\frac{|a|}{1+|a|}+\\frac{|b|}{1+|b|}$$\n$\\color{red}{\\textbf{Proof}}$\n首先左边的取的是 $a+b$ 的绝对值，而右边则是分别取 $a$ 和 $b$ 的绝对值，因此应该要用到三点不等式 $|a+b|\\le |a|+|b|$ ，但是问题来了，左边的分子和分母都有 $|a+b|$ 该咋办捏？\n这里我们将分子分母同时除以 $|a+b|$ 得到 $\\frac{1}{\\frac{1}{|a+b|}+1}$，然后再带入三点不等式得到\n$$\\frac{|a+b|}{1+|a+b|}=\\frac{1}{\\frac{1}{|a+b|}+1}\\le\\frac{1}{\\frac{1}{|a|+|b|}+1}=\\frac{|a|+|b|}{|a|+|b|+1}$$\n然后将右边的式子通分\n$$\\frac{|a|}{1+|a|}+\\frac{|b|}{1+|b|}=\\frac{|a|+|b|+2|ab|}{|a|+|b|+|ab|+1}$$\n这时，我们发现两个式子长得十分相似，分母相差一个 $|ab|$ ，分子相差 2 个 $|ab|$ ，而左式放缩后的式子是真分数，于是利用糖水不等式放缩得到\n$$\\frac{|a|+|b|}{|a|+|b|+1}\\le\\frac{|a|+|b|+|ab|}{|a|+|b|+|ab|+1}\\le\\frac{|a|+|b|+2|ab|}{|a|+|b|+|ab|+1}$$\n综上所述，\n$$\\frac{|a+b|}{1+|a+b|}\\le\\frac{|a|+|b|}{|a|+|b|+1}\\le\\frac{|a|+|b|+2|ab|}{|a|+|b|+|ab|+1}=\\frac{|a|}{1+|a|}+\\frac{|b|}{1+|b|}$$\n试按下列提示，给出 Cauchy 不等式的几个不同证明\n(3) 用不等式 $|AB|\\le \\frac{A^2+B^2}{2}$\n$\\color{red}{\\textbf{Proof}}$\n先列出 Cauchy 不等式好了.\n$$\\sum_{i=1}^n|a_ib_i|\\le\\sqrt{\\sum_{i=1}^na_i^2}\\sqrt{\\sum_{i=1}^nb_i^2}\\left(当且仅当\\frac{a_1}{b_1}=\\frac{a_2}{b_2}=\\cdots=\\frac{a_n}{b_n}时取等\\right)$$\n当 $\\sum_{i=1}^na_i=0$ 或 $\\sum_{i=1}^nb_i=0$ 时，不等式显然成立.\n考虑他们不为 0 的情况，不等式即\n$$\\frac{\\sum_{i=1}^n|a_ib_i|}{\\sqrt{\\sum_{i=1}^na_i^2}\\sqrt{\\sum_{i=1}^nb_i^2}}\\le 1$$\n对于 $i=k$ ，有\n$$\\frac{|a_kb_k|}{\\sqrt{\\sum_{i=1}^na_i^2}\\sqrt{\\sum_{i=1}^nb_i^2}}=\\frac{|a_k|}{\\sqrt{\\sum_{i=1}^na_i^2}}\\cdot\\frac{|b_k|}{\\sqrt{\\sum_{i=1}^nb_i^2}}\\le \\frac{1}{2}\\cdot\\left(\\frac{a_k^2}{\\sum_{i=1}^na_i^2}+\\frac{b_k^2}{\\sum_{i=1}^nb_i^2}\\right)$$\n那么对于 $i=1,2,\\cdots,n$ ，求和有\n$$\\frac{\\sum_{i=1}^n|a_ib_i|}{\\sqrt{\\sum_{i=1}^na_i^2}\\sqrt{\\sum_{i=1}^nb_i^2}}\\le\\frac{1}{2}\\cdot(1+1)=1$$\n不等式得证.\n$\\color{blue}{\\textbf{Thoughts}}$\n均值不等式的一个好处就是把乘积变成加法的形式，在这个不等式中，如果我们直接对 $a_ib_i$ 使用均值不等式将会得到 $\\sum_{i=1}^n|a_ib_i|\\le\\frac{\\sum_{i=1}^na_i^2+\\sum_{i=1}^nb_i^2}{2}$ ，然后我们想要证明 $\\frac{\\sum_{i=1}^na_i^2+\\sum_{i=1}^nb_i^2}{2}\\le\\sqrt{\\sum_{i=1}^na_i^2\\cdot\\sum_{i=1}^nb_i^2}$ ，左边是加法，右边则是根号下乘积的形式，显然是不好处理的，所以我们想啊，要是右边的也是加法的形式就好了，因此我们想对 $\\sum_{i=1}^na_i^2\\cdot\\sum_{i=1}^nb_i^2$ 也使用均值不等式，一个办法就是在一开始把他们移到不等式左边的分母上，然后拆成 $\\frac{|a_k|}{\\sqrt{\\sum_{i=1}^na_i^2}}\\cdot\\frac{|b_k|}{\\sqrt{\\sum_{i=1}^nb_i^2}}$ 的形式，再使用均值不等式，会发现求和后的结果刚好就是 1 .\n用向前 - 向后数学归纳法证明 Fan Ky 不等式\n设 $0\u003cx_i\\le\\frac{1}{2},i=1,2,\\cdots,n$ ，则 $$\\frac{\\prod_{i=1}^nx_i}{\\left(\\sum_{i=1}^nx_i\\right)^n}\\le\\frac{\\prod_{i=1}^n(1-x_i)}{\\left[\\sum_{i=1}^n(1-x_i)\\right]^n}$$\n$\\color{red}{\\textbf{Proof}}$\n不等式即\n$$\\frac{\\prod_{i=1}^nx_i}{\\prod_{i=1}^n(1-x_i)}\\le\\left[\\frac{\\sum_{i=1}^nx_i}{\\sum_{i=1}^n(1-x_i)}\\right]^n$$\n考虑 $n=2^k(k\\in \\mathbb{N_+})$ 的情形.\n当 $k=1$ 时，不等式为 $\\frac{x_1x_2}{(1-x_1)(1-x_2)}\\le\\frac{(x_1+x_2)^2}{[(1-x_2)+(1-x_2)]^2}$\n这里均值不等式不好使，而参数只有两项，因此使用直接作差法，得到\n$$\\frac{x_1x_2}{(1-x_1)(1-x_2)}-\\frac{(x_1+x_2)^2}{[(1-x_2)+(1-x_2)]^2}=\\frac{(x_1-x_2)^2(x_1+x_2-1)}{(1-x_2)(1-x_2)(2-x_1-x_2)^2}\\le 0$$\n得证.\n当 $k=2$ 时，\n$$\\begin{aligned} 左边 =\u0026 \\frac{x_1x_2}{(1-x_1)(1-x_2)}\\cdot\\frac{x_3x_4}{(1-x_3)(1-x_4)} \\ \\le\u0026 \\left(\\frac{x_1+x_2}{1-x_1+1-x_2}\\cdot\\frac{x_3+x_4}{1-x_3+1-x_4}\\right)^2 \\ \\le\u0026 \\left[\\frac{x_1+x_2+x_3+x_4}{(1-x_1)+(1-x_2)+(1-x_3)+(1-x_4)}\\right]^4 \\end{aligned}$$\n以此类推，可以证明当 $n=2^k$ 时不等式成立.\n下面进行反向归纳：\n假设不等式在 $n$ 时已然成立，现在我们要推出它在 $n-1$ 时也成立.\n令 $\\frac{\\sum_{i=1}^{n-1}x_i}{n-1}=A$ ，则 $\\frac{\\sum_{i=1}^{n-1}(1-x_i)}{n-1}=1-A$ ，于是 $\\left[\\frac{\\sum_{i=1}^{n-1}x_i}{\\sum_{i=1}^{n-1}(1-x_i)}\\right]^{n-1}=\\left(\\frac{A}{1-A}\\right)^{n-1}$ .\n待证不等式即\n$$\\left(\\frac{A}{1-A}\\right)^{n-1}\\ge\\frac{\\prod_{i=1}^{n-1}x_i}{\\prod_{i=1}^{n-1}(1-x_i)}=\\frac{\\prod_{i=1}^{n}x_i}{\\prod_{i=1}^{n}(1-x_i)}\\cdot\\frac{1-x_n}{x_n}$$\n等价于\n$$\\left(\\frac{A}{1-A}\\right)^{n-1}\\cdot\\frac{x_n}{1-x_n}\\ge\\frac{\\prod_{i=1}^{n}x_i}{\\prod_{i=1}^{n}(1-x_i)}$$\n由于不等式在 $n$ 时成立，显然有\n$$\\left(\\frac{A}{1-A}\\right)^n\\ge\\frac{\\prod_{i=1}^{n}x_i}{\\prod_{i=1}^{n}(1-x_i)}$$\n将 $\\frac{x_n}{1-x_n}$ 看成 $\\frac{A}{1-A}$ ，因而不等式在 $n-1$ 时也成立.\n从而 Fan Ky 不等式得证.\n$\\color{blue}{\\textbf{Thoughts}}$\n显然我们如果从待证不等式（即 n - 1 的情况）出发，向已知不等式（即 n 的情况）转化，会多出来一个 $\\frac{1-x_n}{x_n}$ ，这是很自然的思路.\n这道题的关键在于发现 $\\sum_{i=1}^{n-1}x_i$ 与 $\\sum_{i=1}^{n-1}(1-x_i)$ 在均值形式下的高度相似性，将它们相除后的式子又与 $\\frac{1-x_n}{x_n}$ 高度一致.\n2.1 数列极限的基本概念 例题 2.1.1\n证明数列 ${\\frac{n^5}{2^n}}$ 收敛于 $0$ .\n$\\color{red}{\\textbf{Proof}}$\n这里用定义法.\n使用 $2^n=(1+1)^n=1+\\binom{n}{1}+\\cdots+\\binom{n}{n}$ 来进行适当放大.\n$$\\frac{n^5}{2^n}\u003c\\frac{n^5}{\\binom{n}{6}}=\\frac{n^4\\cdot 6!}{(n-1)(n-2)(n-3)(n-4)(n-5)}\u003c\\frac{6!}{n}\u003c\\epsilon$$\n只需取 $N=\\left\\lfloor\\frac{720}{\\epsilon}\\right\\rfloor$ 即可.\n$\\color{blue}{\\textbf{Thoughts}}$\n主要是要注意 $2^n=\\sum_{i=0}^n\\binom{n}{i}$ 的变形技巧.\n例题 2.1.2\n证明数列 ${\\sqrt[n]{n}}$ 的极限是 $1$ .\n$\\color{red}{\\textbf{Proof \\ 1}}$\n在 $n\\ge2$ 时，根据均值不等式有\n$$1\\le\\sqrt[n]{n}=\\sqrt[n]{\\sqrt{n}\\cdot\\sqrt{n}\\cdot\\underbrace{1\\cdot1\\cdots\\cdot1}_{n-2个1}}\\le\\frac{2\\sqrt{n}+n-2}{n}\\le1+\\frac{2}{\\sqrt{n}}$$\n因此有 $0\\le\\sqrt[n]{n}-1\\le\\frac{2}{\\sqrt{n}}$\n取 $N=\\max{2,\\lceil\\frac{4}{\\epsilon^2}\\rceil}$ 即可.\n$\\color{blue}{\\textbf{Thoughts}}$\n这个地方利用了 1 的任意次方等于 1 的性质和一个数乘以 1 还是它本身的性质来干掉指数的 $\\frac{1}{n}$ .\n$\\color{red}{\\textbf{Proof \\ 2}}$\n构造辅助数列.\n由于 $\\sqrt[n]{n}\\ge1$ ，只需关心 $\\sqrt[n]{n}-1\\le\\epsilon$ .\n令 $y_n=\\sqrt[n]{n}-1$ ，则 $y_n\\ge0$ ，且当 $n\u003e1$ 时有\n$$n=(1+y_n)^n\\ge \\frac{n(n-1)}{2}y_n^2$$\n于是有 $y_n\\le\\sqrt{\\frac{2}{n-1}}\u003c\\epsilon$ ，只需取 $N=[\\frac{2}{\\epsilon^2}]+1$ 即可.\n$\\color{blue}{\\textbf{Thoughts}}$\n将待证不等式直接构造为辅助数列可以更方便地放缩从而找出一个合适的 N .\n2.1.5 练习题 5\n设 $a\u003e1$ ，证明 $\\lim\\limits_{n\\to \\infty}\\frac{\\log_{a}n}{n}=0$ .\n（可以利用已知极限 $\\lim\\limits_{n\\to\\infty}\\sqrt[n]{n}=1$ ）\n$\\color{red}{\\textbf{Proof}}$\n因为 $\\frac{\\log_an}{n}=\\log_a\\sqrt[n]{n}$ ，所以 $\\lim\\limits_{n\\to\\infty}\\frac{\\log_an}{n}=\\lim\\limits_{n\\to\\infty}\\log_{a}\\sqrt[n]{n}=0$\n2.2 收敛数列的基本性质 例题 2.2.2\n若 $\\lim\\limits_{n\\to\\infty}\\frac{x_n-a}{x_n+a}=0$ ，证明 $\\lim\\limits_{n\\to\\infty}x_n=a$ .\n$\\color{red}{\\textbf{Proof \\ 1}}$\n定义法.\n由题设， $a\\not ={0}$ ，且 $\\forall\\epsilon\u003e0,\\exist N,s.t \\ n\u003eN,\\left|\\frac{x_n-a}{x_n+a}\\right|\u003c\\epsilon$\n于是有\n$$|x_n-a|\u003c\\epsilon|x_n+a|=\\epsilon|x_n-a+2a|\\le\\epsilon(|x_n-a|+2|a|)$$\n即\n$$(1-\\epsilon)|x_n-a|\u003c2\\epsilon|a|$$\n限定 $\\epsilon\u003c1$ 得到 $|x_n-a|\u003c\\frac{2\\epsilon|a|}{1-\\epsilon}$ ，再限定 $\\epsilon\u003c\\frac{1}{2}$ ，可以得到 $|x_n-a|\u003c4|a|\\epsilon$ ，满足 $\\lim\\limits_{n\\to\\infty}x_n=a$ 的定义，得证.\n$\\color{blue}{\\textbf{Thoughts}}$\n这里利用绝对值不等式的时候不能直接放缩，而是将内部凭空捏造出一个待证式来，然后将多出来的东西减去之后再进行放缩.\n$\\color{red}{\\textbf{Proof \\ 2}}$\n构造辅助数列.\n令 $y_n=\\left|\\frac{x_n-a}{x_n+a}\\right|$ ，则 $y_n$ 极限已知，为 0 .\n将 $x_n$ 用 $y_n$ 表示，得到\n$$x_n=a\\cdot\\frac{1+y_n}{1-y_n}$$\n再由极限的四则运算法则，可以得到 $\\lim\\limits_{n\\to\\infty}x_n=a$ .\n$\\color{blue}{\\textbf{Thoughts}}$\n直接将已知式构造辅助数列，可以利用已知极限直接计算出要求的极限.\n2.2.4 练习题 2.(4)\n设 ${ a_n }$ 为正数列，并且已知它收敛于 $a\u003e0$ ，证明 $\\lim\\limits_{n\\to\\infty}\\sqrt[n]{a_n}=1$ .\n$\\color{red}{\\textbf{Proof}}$\n由 $a_n\\rightarrow a$ 可知，$\\forall \\epsilon\u003e0$ , $\\exists N$ ,当 $n\u003eN$ 时, 满足 $a-\\epsilon\u003ca_n\u003ca+\\epsilon$ .\n令 $\\epsilon\u003c\\frac{a}{2}$ ，则 $\\frac{a}{2}\u003ca_n\u003c\\frac{3}{2}a$ ，因为 $\\lim\\limits_{n\\to\\infty}\\sqrt[n]{\\frac{a}{2}}=\\lim\\limits_{n\\to\\infty}\\sqrt[n]{\\frac{3}{2}a}$ ，所以 $\\lim\\limits_{n\\to\\infty}\\sqrt[n]{a_n}=1$ .\n2.2.4 练习题 3.(1)\n求 $\\lim\\limits_{n\\to\\infty}(1+x)(1+x^2)\\cdots(1+x^{2^n})$ ，其中 $|x|\u003c1$ .\n$\\color{red}{\\textbf{Proof}}$\n$$(1+x)(1+x^2)\\cdots(1+x^{2^n})=\\frac{(1-x)(1+x)\\cdots(1+x^{2^n})}{1-x}=\\frac{1-x^{2^{n+1}}}{1-x}$$\n则 $\\lim\\limits_{n\\to\\infty}(1+x)(1+x^2)\\cdots(1+x^{2^n})=\\lim\\limits_{n\\to\\infty}\\frac{1-x^{2^{n+1}}}{1-x}=\\frac{1}{1-x}$\n2.2.4 练习题 3.(5)\n$\\lim\\limits_{n\\to\\infty}\\sum_{k=1}^n\\frac{1}{k(k+1)\\cdots(k+\\nu)}$（其中 $\\nu$ 为正整数）.\n$\\color{red}{\\textbf{Proof}}$\n注意到\n$$\\frac{1}{k(k+1)\\cdots(k+\\nu)}=\\frac{1}{\\nu}\\left[\\frac{1}{k(k+1)\\cdots(k+\\nu-1)}-\\frac{1}{(k+1)\\cdots(k+v)}\\right]$$\n所以\n$$\\lim\\limits_{n\\to\\infty}\\sum_{k=1}^n\\frac{1}{k(k+1)\\cdots(k+\\nu)}=\\lim\\limits_{n\\to\\infty}\\frac{1}{\\nu}(\\frac{1}{\\nu!}-\\frac{1}{(n+1)\\cdots(n+\\nu)})=\\frac{1}{\\nu\\cdot\\nu!}$$\n$\\color{blue}{\\textbf{Thoughts}}$\n记住这里的注意到.\n2.3 单调数列 例题 2.3.6\n求数列 ${a_n}$ 的极限，其中$a_n=\\frac{1!+2!+\\cdots+n!}{n!}$ .\n$\\color{red}{\\textbf{Proof}}$\n首先证明 ${a_n}$ 收敛，研究相继两项之比，有\n$$\\frac{a_{n+1}}{a_n}=\\frac{1!+2!+\\cdots+(n+1)!}{(n+1)(1!+2!+\\cdots+n!)}=\\frac{1!+2!+\\cdots+(n+1)!}{1!+(n+1)+2!(n+1)+\\cdots+n!(n+1)}$$\n分子分母从第三项开始对应有分母的项大于分子的项，因此 $\\frac{a_{n+1}}{a_n}\u003c1$ ，即 ${a_n}$ 为单调递减数列.\n又有\n$$a_n\u003c\\frac{(n-2)(n-1)!+(n-1)!+n!}{n!}=\\frac{(n-1)(n-1)!+n!}{n!}\u003c\\frac{2n!}{n!}=2$$\n所以 ${a_n}$ 单调有界，故 ${a_n}$ 收敛.\n可以发现\n$$a_{n+1}=1+\\frac{a_n}{n+1}$$\n两边令 $n\\to\\infty$ ，可知 $\\lim\\limits_{n\\to\\infty}a_n=1$ .\n当然，这题用 Stolz 定理证会更简单.\n2.3.2 练习题 12\n对每个正整数 $n$ ，用 $x_n$ 表示方程 $x+x^2+\\cdots+x^n=1$ 在闭区间 $[0,1]$ 中的根.求 $\\lim\\limits_{n\\to\\infty}x_n$ .\n$\\color{red}{\\textbf{Proof}}$\n由题意，\n$$ x_n+x_n^2+\\cdots+x_n^n=1 \\quad (1) \\\\ x_{n+1}+x_{n+1}^2+\\cdots+x_{n+1}^{n+1}=1 $$\n通过比较可以发现 $x_n\u003ex_{n+1}$ ，即 ${x_n}$ 为单调递减数列，又有 $x_n\u003c1$ ，所以 $x_n$ 收敛.\n$$x_{n+1}+x_{n+1}^2+\\cdots+x_{n+1}^{n+1}=x_{n+1}(1+x_{n+1}+\\cdots+x_{n+1}^n)=1$$\n即\n$$x_{n+1}+\\cdots+x_{n+1}^n=\\frac{1}{x_{n+1}}-1\\quad(2)$$\n令 $n\\to\\infty$ ，用 （2）式减去（1）式得\n$$0=\\frac{1}{A}-2(\\lim\\limits_{n\\to\\infty}x_n=A)$$\n所以 $A=\\frac{1}{2}$ .\n2.4 Cauchy 命题与 Stolz 定理 命题 2.4.1（Cauchy 命题）\n设 ${x_n}$ 收敛于 $l$ ，则它的前 $n$ 项的算术平均值（所成的数列）也收敛于 $l$ ，即有 $$\\lim\\limits_{n\\to\\infty}\\dfrac{x_1+x_2+\\cdots+x_n}{n}=l$$\n$\\color{blue}{\\textbf{Thoughts}}$\n因为这个证明相对简单，所以就不列了，但是它的证明很重要，体现了分治的思想.\nP.S. Cauchy 命题在数列 ${x_n}$ 为有确定符号的无穷大量时也是成立的.\n命题 2.4.2（$\\frac{0}{0}$ 型的 Stolz 定理）\n设 ${a_n}$ 和 ${b_n}$ 都是无穷小量，其中 ${a_n}$ 还是严格单调减少数列，又存在 $\\lim\\limits_{n\\to\\infty}\\dfrac{b_{n+1}-b_n}{a_{n+1}-a_n}=l$ （其中 $l$ 为有限或 $\\pm\\infin$），则有 $\\lim\\limits_{n\\to\\infin}\\dfrac{b_n}{a_n}=l$ .\n$\\color{red}{\\textbf{Proof}}$\n这里只对有限的 $l$ 作证明，其他情况的证明也是类似的.\n根据条件，$\\forall \\epsilon\u003e0,\\exists N,s.t.$ 当 $n\u003eN$ 时有 $\\left|\\dfrac{b_n-b_{n+1}}{a_n-a_{n+1}}-l\\right|\u003c\\epsilon$ .\n因为 ${a_n}$ 单调减少，所以有\n$$(l-\\epsilon)(a_n-a_{n+1})\u003cb_n-b_{n+1}\u003c(l+\\epsilon)(a_n-a_{n+1})$$\n取 $m\u003en$ 并累加得\n$$(l-\\epsilon)(a_n-a_m)\u003cb_n-b_m\u003c(l+\\epsilon)(a_n-a_m)$$\n即\n$$\\left|\\dfrac{b_n-b_m}{a_n-a_m}-l\\right|\u003c\\epsilon$$\n令 $m\\to\\infty$ ，并利用 $\\lim\\limits_{m\\to\\infin}a_m=\\lim\\limits_{m\\to\\infin}b_m=0$ ，便可以得到当 $n\u003eN$ 时，成立\n$$\\left|\\dfrac{b_n}{a_n}-l\\right|\\le\\epsilon$$\n$\\color{blue}{\\textbf{Thoughts}}$\n在这里有一个问题，既然后面可以用到 $\\lim\\limits_{n\\to\\infin}a_n=\\lim\\limits_{n\\to\\infin}b_n=0$ ，那为什么一开始不直接用然后直接由极限的四则运算法则得到 $\\lim\\limits_{n\\to\\infin}\\dfrac{b_n}{a_n}=l$ 呢？\n答案的关键就在于这个 m \u003e n .\n当我们直接对 $\\lim\\limits_{n\\to\\infty}=\\dfrac{b_{n+1}-b_n}{a_{n+1}-a_n}$ 使用极限的四则运算法则时，会发现分母 $\\lim\\limits_{n\\to\\infty}(a_{n+1}-a_n)=0$ ，此时显然是不能用极限的四则运算法则的.\n而若我们取 $m\u003en$ ，然后令 $m\\to\\infin$ ，这里 $n$ 并没有 $\\to\\infin$ ，相当于我们固定了 n ，而 m 才是不确定的那个，此时 $a_n,b_n$ 都是一个确定的数，进而 $\\lim\\limits_{m\\to\\infty}(a_n-a_m)=a_n$ 而不是 0 ，也就满足了利用 $\\lim\\limits_{m\\to\\infin}a_m=\\lim\\limits_{m\\to\\infin}b_m=0$ 的条件限制，从而有了 $\\left|\\dfrac{b_n}{a_n}-l\\right|\\le\\epsilon$ ，最后通过定义证明了 $\\lim\\limits_{n\\to\\infin}\\dfrac{b_n}{a_n}=l$ .\n还要注意一点，这个方法必须是通过定义来证明，因为直接利用极限的四则运算法则必然要令 $n\\to\\infin$ ，这样就无法避免分母为 0 了.\n命题 2.4.3 （$\\frac{*}{\\infin}$）型的 Stolz 定理\n设数列 ${a_n}$ 是严格单调增加的无穷大量，又存在 $\\lim\\limits_{n\\to\\infty}\\dfrac{b_{n+1}-b_n}{a_{n+1}-a_n}=l$（其中 $l$ 为有限或 $\\pm\\infin$），则有 $\\lim\\limits_{n\\to\\infin}\\dfrac{b_n}{a_n}=l$ .\n$\\color{red}{\\textbf{Proof}}$\n此处同样只针对 l 为有限的情况证明.\n根据题意，$\\forall\\epsilon\u003e0,\\exists N,s.t.$ 当 $n\u003eN$ 时有 $\\left|\\dfrac{b_n-b_{n+1}}{a_n-a_{n+1}}-l\\right|\u003c\\epsilon$ .\n因为 ${a_n}$ 单调增加，所以\n$$(l-\\epsilon)(a_{n+1}-a_n)\u003cb_{n+1}-b_n\u003c(l+\\epsilon)(a_{n+1}-a_n)$$\n将上式的 n 改成 n - 1 并累加到 N ，得到\n$$(l-\\epsilon)(a_n-a_N)\u003cb_{n}-b_N\u003c(l+\\epsilon)(a_{n}-a_N)$$\n即\n$$\\left|\\dfrac{b_n-b_{N}}{a_n-a_{N}}-l\\right|\u003c\\epsilon$$\n我们又有恒等式\n$$\\frac{b_n}{a_n}-l=\\left(1-\\frac{a_N}{a_n}\\right)\\cdot\\left(\\frac{b_n-b_N}{a_n-a_N}-l\\right)+\\frac{b_N-la_N}{a_n}$$\n其中，由于 $\\lim\\limits_{n\\to\\infty}a_n=+\\infty$ ，存在 $N_1$ ，使得当 $n\u003eN_1$ 时，成立 $1-\\dfrac{a_N}{a_n}\u003c2$ 和 $\\left|\\dfrac{b_N-la_N}{a_n-a_N}\\right|\u003c\\epsilon$ .\n因此，当 $n\u003e\\max(N, N_1)$ 时，有 $\\left|\\frac{b_n}{a_n}-l\\right|\u003c3\\epsilon$ .\n$\\color{blue}{\\textbf{Thoughts}}$\n这里的证明思路和前一个 $\\frac{0}{0}$ 型的类似，但是此处 ${a_n}$ 是无穷大量，因此不能利用极限来解决最后一步.\n为了方便放缩和利用 ${a_n}$ 的极限，我们仍然需要在已知式中引入固定的数 $a_N$ 和 $b_N$ ，然后这里“强行”将待证式用已知式表示，再借助 ${a_n}$ 的极限进行放缩，从而证明.\n这个地方的待证式和已知式看上去好像不能转化，但实际上转化是完全可行的，所谓的 trick 其实也不过是很朴素的思想，当想不到其他巧妙的方法时，这个“强行”转化的方法可能会很好用.\n$$\\color{yellow}{\\textbf{Attention}}$$\n以上三个命题的逆命题都不成立. 若在这三个命题中将 $l$ 改为不带符号的无穷大量 $\\infin$ ，则结论均不成立. 例题 2.4.3\n设已知 $\\lim\\limits_{n\\to\\infty}a_n=a$ ，证明：$\\lim\\limits_{n\\to\\infty}\\frac{1}{2^n}\\sum_{k=0}^n\\binom{n}{k}=a$ .\n$\\color{red}{\\textbf{Proof}}$\n利用 $2^n=(1+1)^n=\\sum_{k=0}^n\\binom{n}{k}$ ，有\n$$\\left|\\frac{1}{2^n}\\sum_{k=0}^n\\binom{n}{k}a_k-a\\right|=\\left|\\frac{1}{2^n}\\sum_{k=0}^n\\binom{n}{k}(a_k-a)\\right|\\le\\frac{1}{2^n}\\sum_{k=0}^n\\binom{n}{k}|a_k-a|$$\n由题意，$\\forall\\epsilon\u003e0,\\exists N,s.t.$ 当 $n\u003eN$ 时有 $|a_n-a|\u003c\\epsilon$ .\n将上面转化后的式子分拆得到\n$$\\frac{1}{2^n}\\sum_{k=0}^n\\binom{n}{k}|a_k-a|=\\frac{1}{2^n}\\sum_{k=0}^N\\binom{n}{k}|a_k-a|+\\frac{1}{2^n}\\sum_{k=N+1}^n\\binom{n}{k}|a_k-a|$$\n对第二部分的估计是很容易的\n$$\\frac{1}{2^n}\\sum_{k=N+1}^n\\binom{n}{k}|a_k-a|\u003c\\frac{\\epsilon}{2^n}\\sum_{k=N+1}^n\\binom{n}{k}\u003c\\frac{\\epsilon}{2^n}\\sum_{k=0}^n\\binom{n}{k}=\\epsilon$$\n而对于前一项，我们需要用到一个不等式 ——$\\binom{n}{k}\u003cn^k$ .\n记 $M=\\max|a_k-a|$ ，放缩有\n$$\\frac{1}{2^n}\\sum_{k=0}^N\\binom{n}{k}|a_k-a|\u003c\\frac{M(n^0+n^1+\\cdots+n^N)}{2^n}$$\n因为 $N$ 固定，当 $n\\to\\infin$ 时，右边的式子的极限为 0 ，因此存在 $N_1\u003eN$ ，当 $n\u003eN_1$ 时成立 $\\frac{1}{2^n}\\sum_{k=0}^N\\binom{n}{k}|a_k-a|\u003c\\epsilon$ .\n合并两式的估计，有当 $n\u003eN_1$ 时成立\n$$\\left|\\frac{1}{2^n}\\sum_{k=0}^n\\binom{n}{k}a_k-a\\right|\u003c2\\epsilon$$\n$\\color{blue}{\\textbf{Thoughts}}$\n此处的证明用了两个很重要的 trick ：\n$2^n=(1+1)^n=\\sum_{k=0}^n\\binom{n}{k}$ $\\binom{n}{k}\u003cn^k$ 同时在对 $\\frac{M(n^0+n^1+\\cdots+n^N)}{2^n}$ 的估计中，分子只是一个最大指数确定的 n 的多项式，而分母则是指数趋于 $\\infty$ 且底数大于 1 的指数函数，因此整个表达式一定是无穷小量.\n2.4.3 练习题 5\n设 ${a_n}$ 为正数列，且收敛于 $A$ ，证明：$\\lim\\limits_{n\\to\\infty}(a_1a_2\\cdots a_n)^{\\frac{1}{n}}=A$ .\n$\\color{red}{\\textbf{Proof}}$\n我们利用夹逼准则来证.\n$$(a_1a_2\\cdots a_n)^{\\frac{1}{n}}\\le\\frac{a_1+a_2+\\cdots+a_n}{n}$$\n根据 Cauchy 命题，$\\lim\\limits_{n\\to\\infty}\\frac{a_1+a_2+\\cdots+a_n}{n}=\\lim\\limits_{n\\to\\infty}a_n=A$ .\n考虑 $\\frac{\\frac{1}{a_1}+\\frac{1}{a_2}+\\cdots+\\frac{1}{a_n}}{n}$ 的极限.\n由 Stolz 定理可知， $\\lim\\limits_{n\\to\\infty}\\frac{\\frac{1}{a_1}+\\frac{1}{a_2}+\\cdots+\\frac{1}{a_n}}{n}=\\lim\\limits_{n\\to\\infty}\\frac{1}{a_n}=\\frac{1}{A}$ ，因此 $\\lim\\limits_{n\\to\\infty}\\frac{n}{\\frac{1}{a_1}+\\frac{1}{a_2}+\\cdots+\\frac{1}{a_n}}=A$ ,进而\n$$(a_1a_2\\cdots a_n)^{\\frac{1}{n}}\\ge\\frac{n}{\\frac{1}{a_1}+\\frac{1}{a_2}+\\cdots+\\frac{1}{a_n}}$$\n从而左右两边极限都为 A ，根据夹逼准则有 $\\lim\\limits_{n\\to\\infty}(a_1a_2\\cdots a_n)^{\\frac{1}{n}}=A$ .\n$\\color{blue}{\\textbf{Thoughts}}$\n右边的式子很好想，但左边的式子却不太好处理.\n首先容易想到的比几何均值要小的只有调和均值，由于调和均值的分子分母都可以写成和的形式，我们想到利用 Stolz 定理，但是问题来了，它既不满足 $\\frac{0}{0}$ 的形式也不满足 $\\frac{*}{\\infty}$ 的形式，该怎么办呢？\n这时我们注意到它的分子满足 $\\infin$ 的形式，于是我们可以利用 Stolz 定理求出它的倒数的极限值，也就求出了它的极限值.\n2.4.3 练习题 9\n设数列 ${a_n}$ 满足条件 $0\u003ca_1\u003c1$ 和 $a_{n+1}=a_n(1-a_n)(n\\ge1)$ ，证明：$\\lim\\limits_{n\\to\\infty}na_n=1$ .\n$\\color{red}{\\textbf{Proof}}$\n可以发现 ${a_n}$ 是迭代数列，我们只需证明出 ${a_n}$ 单调有界，便可以很快求出它的极限值.\n由题意，有 $a_{n+1}-a_n=-a_n^2\u003c0$ ，因此 ${a_n}$ 严格单调减少.\n因为 $0\u003ca_1\u003c1$ ，所以 $0\u003ca_2=a_1(1-a_1)\u003c1$ ，于是我们可以归纳地得出 $0\u003ca_n=a_{n-1}(1-a_{n-1})\u003c1$ ，进而得到 ${a_n}$ 存在下界 0 ，因此 ${a_n}$ 收敛.\n在 $a_{n+1}=a_n(1-a_n)(n\\ge1)$ 两边令 $n\\to\\infin$ ，可以求得 $\\lim\\limits_{n\\to\\infty}a_n=0$（等于 1 的情况要排除，此处证明略）.\n又 $na_n=\\dfrac{n}{\\frac{1}{a_n}}$ ，满足 $\\frac{*}{\\infty}$ 型 Stolz 定理，于是可以求出 $\\lim\\limits_{n\\to\\infty}na_n=\\lim\\limits_{n\\to\\infty}\\dfrac{1}{\\frac{1}{a_n}-\\frac{1}{a_{n-1}}}$ .\n将 $a_{n+1}=a_n(1-a_n)(n\\ge1)$ 变形为 $\\frac{1}{a_n}-\\frac{1}{a_{n-1}}=\\frac{1}{1-a_n}$ ，因此得到 $\\lim\\limits_{n\\to\\infty}(\\frac{1}{a_n}-\\frac{1}{a_{n-1}})=1$ ，所以 $\\lim\\limits_{n\\to\\infty}na_n=1$ .\n$\\color{blue}{\\textbf{Thoughts}}$\n这是一个需要变形的 Stolz 定理题，关键就在于想到将 $na_n$ 变形为满足 Stolz 定理的形式.\n我们不知道 ${a_n}$ 中任何一项的具体值，已知的大小关系也仅有它和 1 与 0 的关系，$na_n$ 简单的表达式也不好想到它能怎样放缩，因此定义法和夹逼准则都不好做，这时就要考虑 Stolz 定理了.\n由于 ${a_n}$ 是迭代数列，所以它的极限很好求，也很容易求得相邻两项之间的关系，而 $na_n$ 中含有 n ，这显然是很适合用 Stolz 定理的，我们只需将其适当变形即可.\n2.5 自然对数的底 $e$ 和 Euler 常数 $\\gamma$ 更不完了 /dk\n","description":"旧文补档，可惜当初只写了很少一部分","tags":["Calculus"],"title":"谢惠民做题记录","uri":"/posts/%E8%B0%A2%E6%83%A0%E6%B0%91%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["折腾"],"content":" Note\n本博客已更改主题为 MemE ，同样进行了一些细节上的魔改，但是懒的再水一篇 blog 了（\n本来之前的服务器到期了准备放弃 Typecho ，暑假自学 web 然后写一个自己的博客，然而，事实是到了现在都还没新建文件夹 ╮(╯-╰)╭\n但是博客肯定还是要写的。继续用以前的 hexo ？看了一眼 Github ，纯 JavaScript！算了算了，感觉没意思。用回 Typecho 吗？虽然部署方便，但是一堆 PHP 文件更不会了啊，这下几乎不能 DIY 了。\n上网一顿乱搜，最终将目标锁定（其实只是一时心血来潮）在了以前使用过几天（指对着文档一顿乱搞）的 Hugo 上，费了点工夫终于折腾出个样子了。\nBuild 直接抄作业！\n（1）带着Stack主题入坑Hugo\n这一步貌似没有遇到什么问题，下一步吧。\nDeploy 还是抄作业😋\n（2）部署你的Hugo博客\n上面这位大佬在这里有一些问题，一些没写清楚容易混淆，一些写错了 XD ，让我在这一步耗了不少时间👿\n获取 SSH Key 密钥 在 1.3 步骤「获取 SSH Key 密钥」中，正确的 Shell 指令如下：\n1 ssh-keygen -t rsa -b 4096 -C \"$(git config user.email)\" -f gh-pages -N \"\" 如果你的电脑之前生成过对应 git 账号的 ssh-key ，那么按照他的指令会生成一个和原来一样的 ssh-key ，也就相当于没有变化，而使用上面的命令会生成名为 gh-pages 的 ssh-key ，再分别填入对应的地方，这样在之后的 Github Action 上才能成功 deploy 到 blog 仓库。\n还要注意一点，ACTIONS_DEPLOY_KEY 的值是没有 .pub 后缀的私钥的值。\n部署 hugo 博客 在 1.4 步骤「部署 hugo 博客」中，deploy.xml 文件的后缀应该是 .yml ，不然在 VSCode 中打开连高亮都没，还一堆红线。\n然后 deploy.yml 文件中要注意看你仓库的默认 branch 是 main 还是 master ，如果是 master 就要把文件中的 branch 名改为 master 。\n1 2 3 4 on: push: branches: - master # 原来是 main 同样的，之后的 deploy.sh 也要注意看你的 blog-file 仓库的默认 branch ，然后改掉最后一行，而且还要在 # 前加一个空格。\n1 git push -f git@github.com:username/blog-file.git master #向存储库推送 之后应该就没有问题了，然后我跳过了 Vercel 。\nDIY 重头戏终于来了😼，暑假看的 weblab 虽然一知半解，自觉也还是搭建不出自己的博客系统，但是对我的 DIY 和文件纠错起到了救星的作用，这里衷心感谢 MIT 的大力支持😁\n第一步当然是先把能抄的作业抄上！\n（3）Stack主题的自定义\n这里我除了「首页添加欢迎横幅」没加之外全都照着搞了。\nKateX 按照 Stack 主题文档的说明在 config.yml 中打开了公式开关 math: true 但是仍然失败了，按照网上教程搞了半天也搞不出来，Stack 实际也内置了 KateX 但是就是渲染失败，半天摸不着脑袋时，突然想起来可以 F12 查错来着！\n于是开启 hugo server -D 之后按下 F12 ，打开控制台，好家伙，原来是 KateX 的文件打不开，查了一下，原来 https://cdn.jsdelivr.net 也是不存在的网站（看来是我没开全局的锅 XD\n东翻西找之后在主题文件夹里找到了引用 KateX 的文件。\n新建 blog\\data\\external.yaml 文件，把 blog\\themes\\hugo-theme-stack\\data\\external.yaml 里的内容粘贴进来，然后把所有 https://cdn.jsdelivr.net 修改为可以访问的镜像网站地址，如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 Vibrant: - src: https://cdnjs.cloudflare.com/ajax/libs/vibrant.js/1.0.0/Vibrant.min.js integrity: sha512-V6rhYmJy8NZQF8F0bhJiTM0iI6wX/FKJoWvYrCM15UIeb6p38HjvTZWfO0IxJnMZrHWUJZJqLuWK0zslra2FVw== type: script PhotoSwipe: - src: https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.3/photoswipe.min.js integrity: sha512-2R4VJGamBudpzC1NTaSkusXP7QkiUYvEKhpJAxeVCqLDsgW4OqtzorZGpulE3eEA7p++U0ZYmqBwO3m+R2hRjA== type: script defer: true - src: https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.3/photoswipe-ui-default.min.js integrity: sha512-SxO0cwfxj/QhgX1SgpmUr0U2l5304ezGVhc0AO2YwOQ/C8O67ynyTorMKGjVv1fJnPQgjdxRz6x70MY9r0sKtQ== type: script defer: true - src: https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.3/default-skin/default-skin.min.css type: style - src: https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.3/photoswipe.min.css type: style KaTeX: - src: https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.css integrity: sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn type: style - src: https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.js integrity: sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx type: script defer: true - src: https://cdn.staticfile.org/KaTeX/0.16.8/contrib/auto-render.min.js integrity: sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 type: script defer: true 再次查看 blog ，公式渲染成功！\nFont 审美参考 ouuan 大佬的 blog ，正文的中文字体使用 思源宋体 ，英文使用主题自带的 Lato ，标题则使用自带的 苹方 ，引用块内使用 霞鹜文楷 。\n首先建立 blog\\layouts\\custom-font.html 文件，写入以下内容覆写原有字体\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u003c!-- \u003cscript\u003e (function () { const customFont = document.createElement('link'); customFont.href = \"https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700\u0026display=swap\"; customFont.type = \"text/css\"; customFont.rel = \"stylesheet\"; document.head.appendChild(customFont); }()); \u003c/script\u003e --\u003e \u003clink rel=\"preconnect\" href=\"https://fonts.googleapis.com\"\u003e \u003clink rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin\u003e \u003clink href=\"https://fonts.googleapis.com/css2?family=Fira+Code\u0026family=JetBrains+Mono\u0026family=Noto+Sans+SC:wght@500\u0026family=Noto+Serif+HK:wght@500\u0026family=Noto+Serif+SC:wght@500\u0026family=Ubuntu+Mono\u0026display=swap\" rel=\"stylesheet\"\u003e 这里我在 Google Font 中引入部分字体，虽然最后没有使用。。。\n然后下载好思源宋体和霞鹜文楷的 .ttf 文件，放在 blog\\static\\fonts 目录下，接着在 blog\\assets\\scss\\custom.scss 中引入字体文件，这里使用 unicode-range 方法将思源宋体的作用域限制在中文。\n1 2 3 4 5 6 7 8 9 10 @font-face { font-family: \"LXGWWenKai-Regular\"; src: url(\"/fonts/LXGWWenKai-Regular.ttf\") format(\"truetype\"); } @font-face { font-family: \"SourceHanSerif\"; src: url(\"/fonts/SourceHanSerifSC-VF.ttf\") format(\"truetype\"); unicode-range: U+1000-fffff } 之后如果想要修改某一部分的字体，直接 F12 选中相应的部分，查看对应的 css 类名称，如图\n然后在 blog\\assets\\scss\\custom.scss 中加入\n1 2 3 4 5 6 7 8 9 10 11 12 body, .article-content { // font-family: 'Fira Code', monospace; // font-family: 'JetBrains Mono', monospace; // font-family: 'Noto Sans SC', sans-serif; // font-family: 'Noto Serif HK', serif; // font-family: 'Noto Serif SC', serif; // font-family: 'Ubuntu Mono', monospace; font-family: \"SourceHanSerif\", \"Lato\"; font-size: 1.7rem; font-weight: 480; } Sidebar 主题原有侧边栏的主页和关于页面的是中文，而其余三个都是英文，看着难受，于是在 blog\\content\\page 目录下找到 /about 目录将两个 .md 文件的 title 都改为英文的 About ，主页则是将在 blog\\content 目录下的两个 .md 文件的 title 改为英文的 Home.\n一言 在页面 footer 部分加入「一言」\n主要参考一言 官方文档，新建文件 blog\\assets\\scss\\partials\\footer.scss ，先将主题文件下的 footer.scss 内容蒯进来，然后加入一言的内容，之后文件内容如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 footer.site-footer { padding: 20px 0 var(--section-separation) 0; font-size: 1.4rem; line-height: 1.75; \u0026:before { content: \"\"; display: block; height: 3px; width: 50px; background: var(--body-text-color); margin-bottom: 20px; } .copyright { color: var(--accent-color); font-weight: bold; margin-bottom: 5px; } .hitokoto { color: var(--body-text-color); font-weight: normal; font-size: 1.3rem; font-family: \"LXGWWenKai-Regular\"; p { margin: 0%; } a { color: var(--body-text-color); } } .powerby { color: var(--body-text-color); font-weight: normal; font-size: 1.2rem; a { color: var(--body-text-color); } } } 接着建立文件 blog\\layouts\\partials\\footer\\footer.html ，同样将主题文件夹内同一文件的内容蒯过来，再加入一言的内容，如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 {{- $ThemeVersion := \"3.18.0\" -}} \u003cfooter class=\"site-footer\"\u003e \u003csection class=\"copyright\"\u003e \u0026copy; {{ if and (.Site.Params.footer.since) (ne .Site.Params.footer.since (int (now.Format \"2006\"))) }} {{ .Site.Params.footer.since }} - {{ end }} {{ now.Format \"2006\" }} {{ default .Site.Title .Site.Copyright }} \u003c/section\u003e \u003csection class=\"hitokoto\"\u003e \u003cp id=\"hitokoto\"\u003e \u003ca href=\"#\" id=\"hitokoto_text\"\u003e:D 获取中...\u003c/a\u003e \u003c/p\u003e \u003cp id=\"hitofrom\" align=\"right\"\u003e \u003ca href=\"#\" id=\"hitokoto_text\"\u003e:D 获取中...\u003c/a\u003e \u003c/p\u003e \u003cscript\u003e fetch('https://v1.hitokoto.cn') .then(function (res) { return res.json(); }) .then(function (data) { var hitokoto = document.getElementById('hitokoto'); hitokoto.innerText = data.hitokoto; var hitofrom = document.getElementById('hitofrom'); hitofrom.innerText = \"——\" + data.from + '\\xa0'; }) .catch(function (err) { console.error(err); }) \u003c/script\u003e \u003c/section\u003e \u003csection class=\"powerby\"\u003e {{ with .Site.Params.footer.customText }} {{ . | safeHTML }} \u003cbr /\u003e {{ end }} {{- $Generator := `\u003ca href=\"https://gohugo.io/\" target=\"_blank\" rel=\"noopener\"\u003eHugo\u003c/a\u003e` -}} {{- $Theme := printf `\u003cb\u003e\u003ca href=\"https://github.com/CaiJimmy/hugo-theme-stack\" target=\"_blank\" rel=\"noopener\" data-version=\"%s\"\u003eStack\u003c/a\u003e\u003c/b\u003e` $ThemeVersion -}} {{- $DesignedBy := `\u003ca href=\"https://jimmycai.com\" target=\"_blank\" rel=\"noopener\"\u003eJimmy\u003c/a\u003e` -}} {{ T \"footer.builtWith\" (dict \"Generator\" $Generator) | safeHTML }} \u003cbr /\u003e {{ T \"footer.designedBy\" (dict \"Theme\" $Theme \"DesignedBy\" $DesignedBy) | safeHTML }} \u003c/section\u003e \u003c/footer\u003e Comment 使用 Waline 评论系统，直接照着 官方文档 搞就行了，就是这个 Vercel 只支持 gmail 邮箱就离谱，害得我还特地注册了个 gmail 邮箱😠\nColor Style 纯色背景感觉太平淡，想搞个 Blue Archive 风格的界面，但是又没那设计 UI 的能力，只能瞎 jb 改改背景还有一点颜色细节了。\n先说说颜色吧，主要是从 Blue Archive 官网上用浏览器插件吸取的一些颜色，然后再从中选取一部分整合到 blog 上。\n之后就和前面修改字体一样，在修改颜色的地方 F12 然后选中，查找到对应 CSS 类名再在 blog\\assets\\scss\\custom.scss 中修改即可。\n这里我修改了选中文本后的颜色还有代码的颜色。\n1 2 3 4 5 6 7 ::selection { background: #99d1fa; } .article-content code { color: #81b6f0; } 之后还修改了 tags 标签的背景颜色，同样是创建文件 blog\\assets\\scss\\variables.scss 然后把主题文件夹下对应文件内容复制过来，再修改顶部内容。\n1 2 $defaultTagBackgrounds: #99d1fa, #5ecfd8, #f08f89, #f1c782, #9969ff; $defaultTagColors: #fff, #fff, #fff, #fff, #fff; 最后就是最折腾我的背景图片了。首先当然还是 F12 找 CSS 样式名，然后添加 Background 相关属性，这里我还 F12 了 吕楪 大佬的博客，因为他是放了背景图片的。\n然后我使用了 Blue Archive 最终章的图片，放上去和前面白色的文章块有点突兀，想搞一个模糊效果，于是想到之前很喜欢的 hexo 主题 nexmoe ，于是找到使用 nexmoe 主题的 折影清梦 ，再次使用 F12 神器，查找背景相关的 CSS 代码，如下\n于是在 custom.scss 中加入以下代码\n1 2 3 4 5 6 7 body { background-image: url(\"/img/WhereAllMiraclesBegin.png\"); background-position: fixed; background-size: cover; backdrop-filter: blur(75px); background-color: transparent; } 这时模糊效果是实现了，但是点开较长的文章会发现图片被拉长到与网页一样长度了，之后上 MDN 查找 background 相关属性，添加了 background-attachment: fixed; 之后终于实现了想要的效果。\n因为图片是后截的，所以忽略我的阴影效果\n但是这时候又会发现，文章的白色贴片像是直接放上去的一样，又会很有违和感，继续观察 折影清梦 ，发现他的网站有明显的阴影效果，配合 blur 的效果观感会很好， Google 一顿发现这种效果叫 box-shadow ，于是接着 F12 ，瞎 jb 乱搞之后决定仅仅修改 variables.scss 中的 --shadow-l1 为 --shadow-l1: 0px 4px 8px rgba(89, 110, 131, 0.4); ，同时在 custom.scss 中加入以下代码修改头像的阴影\n1 2 3 .sidebar header .site-avatar .site-logo { box-shadow: 0px 2px 12px rgba(89, 110, 131, 1); } 这下应该差不多了。\nTo-do more things… References action-gh-pages （1）带着Stack主题入坑Hugo （2）部署你的Hugo博客 时隔半年，博客又有了那些新变化？！ Hugo Stack主题更新小记 Hugo博客自定义字体 ouuan’s blog 用 CSS3 指定网页的中英文分别使用不同字体 一言 Waline nexmoe 折影清梦 MDN-background ","description":"","tags":["blog"],"title":"Hugo Stack 魔法改造记","uri":"/posts/magic-on-hugo-stack/"},{"categories":["Algorithm"],"content":"Introduction 考虑一个经典问题，给出一张图，一个起点 S ，一个终点 G ，求代价最小的路径。\n当每条边的权值相同时，显然使用经典的 BFS 算法就可以了，但是无论是空间还是时间复杂度都不够优秀，而且当每条边权值不同时 BFS 就失效了。\n能不能优化？将 BFS 队列中的结点记为 frontiers ，在 frontiers 中，每个结点都存储下扩展到它时的花费 cost ，然后将队列换成优先队列，每次优先取出 cost 最小的结点，若这个结点是 G 则完成，否则用它扩展其他结点并加入 frontiers 。这样一来，貌似是满足了最优性，但是由于一个结点可能离 S 很近，但是却离 G 很远，我们会发现一个结点会被加入队列多次，产生了大量的冗余状态。\n上面这个算法称为 UCS (Uniform Cost Search) ，它仅仅只考虑了结点到 S 的花费来评估一个结点，我们希望能再结合考虑结点到 G 的花费来优化时间和空间。\n具体而言，设 $g(x)$ 表示 S 到结点 x 的 cost ，启发式函数 $h(x)$ 表示结点 x 到 G 的估计 cost ，将 $f(x)=g(x)+h(x)$ 作为从 S 经过 x 到 G 的预估 cost 。我们每次扩展到一个结点 x 时便可以得到实际的 $g(x)$ ，这时我们计算出它的 $f(x)$ 合并上 x 作为一个状态丢进优先队列，每次优先取出 $f(x)$ 最小的状态，若这个状态的结点是 G ，则找到最优路径。\n这便是 A* 算法的流程，它的难点在于设计一个合理、优秀的启发式函数 $h(x)$ 。\nConstraints 一个合理的启发式函数需要满足两个约束条件：Admissibility（不高估结点到 G 的花费）和 Consistency（不高估 S 到 G 经过该结点的最优路径的花费）\nAdmissibility 设 $h^*(x)$ 表示 x 到 G 实际花费，若满足：\n$$ \\forall n, 0\\le h(n)\\le h^*(n) $$\n则 A* 算法一定能找到最优解。\nProof 设 G 可以由可达结点 A' 和 B' 扩展得到，其中 A' 位于最优路径上，B' 不位于最优路径，设 A 和 B 分别表示 G 由A' 和 B' 扩展得到存入 frontiers 中的状态。\n记 n 为 A' 的祖先结点，有 $h^{\\ast}(n)-h^{\\ast}(A)=g(A)-g(n)$ ，于是\n$$ f(n)=g(n)+h(n)\\le g(n)+h^*(n)=g(A)+h(A)=f(A)\u003cf(B) $$\n也就是说，最优路径上的状态一定会在 B 之前被扩展到，从而 A* 算法一定能找出一条最优路径。\nConsistency 仅仅满足 Admissibility 会发现 A* 算法与 UCS 并没有多少区别，同样会把一个结点扩展多次，于是还需要满足 Consistency 约束：\n$$ \\forall A, C \\ h(A)-h(C)\\le cost(A, C) $$\n这样一来，A* 算法便不会加入重复结点。\nProof 设 C 由 A 扩展而来，则有\n$$ f(C)=g(C)+h(C)=g(A)+cost(A, C)+h(C)\\le g(A)+h(A)=f(A) $$\n也就是说，一条路径上的结点对应的 $f(n)$ 是单调不增的。\n假设 A 和 B 都可以扩展到 C ，我们一开始用 A 扩展了 C ，于是可以得到 $f(C)\\le f(A)\u003cf(B)$ ，又考虑到 $g(B)\u003cg(C)$ ，即便用 C 去扩展 B 也不会让 $f(B)$ 变小，更何况 B 已经在 frontiers 中了我们不会再次加入 B ，也就不可能用 B 来重复扩展 C 了，从而 A* 算法不会加入重复结点。\nDominance 对于两个满足 constraints 的启发式函数 $h_a$ 和 $h_b$ ，若 $\\forall n, h_a(n)\\ge h_b(n)$ ，则说明 $h_a$ 比 $h_b$ 更接近实际函数 $h^*$ ，也就更优秀。\nExample P1379 八数码难题\n将每个状态看作一个结点，$h(x)$ 定义为当前状态中每个数字到目标位置的曼哈顿距离（记得排除数字 0 的），然后跑 A* 即可。\nOI-wiki 上将 $h(x)$ 定义为当前状态中位置不在目标位置上的数字的数量，这个定义并不能保证找到的是最优路径，在 Luogu 上提交会发现如果 dx 和 dy 数组与标答不同会有一个点过不去。\nReferences A Star Algorithm 总结与实现 | Cheng Wei’s Blog (scm_mos.gitlab.io) A星寻路算法介绍 - 莫水千流 - 博客园 (cnblogs.com) A* - OI Wiki (oi-wiki.org) cs188-fa22-note02 ","description":"","tags":["Graph","A*"],"title":"A* 算法总结","uri":"/posts/a-star/"}]